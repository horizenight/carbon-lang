"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3805],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=i.createContext({}),l=function(e){var n=i.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=l(e.components);return i.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=l(t),m=a,f=h["".concat(c,".").concat(m)]||h[m]||d[m]||r;return t?i.createElement(f,o(o({ref:n},p),{},{components:t})):i.createElement(f,o({ref:n},p))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=h;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<r;l++)o[l]=t[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}h.displayName="MDXCreateElement"},1628:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var i=t(7462),a=(t(7294),t(3905));const r={},o="Principle: One static open extension mechanism",s={unversionedId:"principles/static_open_extension",id:"principles/static_open_extension",title:"Principle: One static open extension mechanism",description:"\x3c!--",source:"@site/../docs/project/principles/static_open_extension.md",sourceDirName:"principles",slug:"/principles/static_open_extension",permalink:"/project/principles/static_open_extension",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/../docs/project/principles/static_open_extension.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Safety strategy",permalink:"/project/principles/safety_strategy"},next:{title:"Principle: Success criteria",permalink:"/project/principles/success_criteria"}},c={},l=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Background",id:"background",level:2},{value:"Principle",id:"principle",level:2},{value:"Alternatives considered",id:"alternatives-considered",level:2}],p={toc:l};function d(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"principle-one-static-open-extension-mechanism"},"Principle: One static open extension mechanism"),(0,a.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#background"},"Background")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#principle"},"Principle")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#alternatives-considered"},"Alternatives considered"))),(0,a.kt)("h2",{id:"background"},"Background"),(0,a.kt)("p",null,"In C++, a single function may be overloaded with definitions in multiple files.\nThe ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Argument-dependent_name_lookup"},"ADL")," name\nlookup rule even allows an unqualified call to resolve to functions defined in\ndifferent namespaces. These rules are used to define extension points with\nstatic dispatch for operator overloading and functions like\n",(0,a.kt)("a",{parentName:"p",href:"https://www.cplusplus.com/reference/algorithm/swap/"},(0,a.kt)("inlineCode",{parentName:"a"},"swap")),"."),(0,a.kt)("p",null,"Nothing in C++ restricts the signatures of function overloads. This means that\nif overloading is used as an extension point to define an operation for a\nvariety of types, there is no way to type check generic code that tries to\ninvoke that operation over those types."),(0,a.kt)("p",null,"Further, in C++, all non-member functions can be found in this way, if they are\ndeclared in the same namespace as a type that could be associated with an\nargument list in a call. There is no straightforward opt-out mechanism in a\nfunction declaration, and while there are opt-out mechanisms at call sites, they\nare rarely used. As a consequence, many non-member functions with the same name\ncan form part of an overload set, even if they provide unrelated functionality,\nand there is no indication in the code of which functions in different\nnamespaces are intended to expose the same capability."),(0,a.kt)("h2",{id:"principle"},"Principle"),(0,a.kt)("p",null,"In Carbon, ",(0,a.kt)("a",{parentName:"p",href:"/docs/design/generics/overview.md"},(0,a.kt)("inlineCode",{parentName:"a"},"interface"),"s")," are the only static\nopen extension mechanism."),(0,a.kt)("p",null,"Each type may define its own implementation of each interface. Generic code can\nbe written that works with any type implementing the interface. That code can be\ntype checked independent of which type the generic code is instantiated with by\nusing the fact that the interface specifies the signatures of the calls."),(0,a.kt)("p",null,"To keep the language simple, this is the only static open extension mechanism in\nCarbon. This means that function overloading is limited in Carbon to only\nsignatures defined together in the same library. It also means that to\ninteroperate with C++, the operators and ",(0,a.kt)("inlineCode",{parentName:"p"},"swap")," need to have corresponding\ninterfaces on the Carbon side."),(0,a.kt)("p",null,"The main advantage of interfaces as an open extension mechanism over open\noverloading is allowing generics to be type checked separately. In addition,\nthey are less ",(0,a.kt)("a",{parentName:"p",href:"/project/principles/low_context_sensitivity"},"context sensitive"),". Generics are\n",(0,a.kt)("a",{parentName:"p",href:"/docs/design/generics/terminology.md#coherence"},"coherent"),", while open function\noverloading can resolve names differently depending on what is imported. Closed\noverloading in Carbon also simplifies what gets exported to C++ from Carbon.\nInterface implementations express intent by being explicit, in contrast to how\nadding a function to a cross-file overload set can be accidental."),(0,a.kt)("p",null,"Interfaces provide an way to group functions together, and express the\nconstraint that all of the functions in the group are implemented. Consider a\nrandom-access iterator, which has a number of methods. If a C++ template\nfunction only accesses some of those methods which happens to match the subset\ndefined for a type, the code will work temporarily but fail later when the code\nis changed to use a different subset."),(0,a.kt)("p",null,"This helps achieve the Carbon Goal of\n",(0,a.kt)("a",{parentName:"p",href:"/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write"},"code that is easy to read, understand, and write"),"."),(0,a.kt)("h2",{id:"alternatives-considered"},"Alternatives considered"),(0,a.kt)("p",null,"Another approach to operator overloading is to use methods with a specific name.\nIn C++ these start with the\n",(0,a.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/operators"},(0,a.kt)("inlineCode",{parentName:"a"},"operator")," keyword"),".\n",(0,a.kt)("a",{parentName:"p",href:"https://docs.python.org/3/reference/datamodel.html#special-method-names"},"Python uses method with names starting and ending with double underscores"),".\nInterfaces are more flexible about where implementations may be defined. For\nexample, with special method names, ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," on a ",(0,a.kt)("inlineCode",{parentName:"p"},"Vector(T)")," class could only be\ndefined as part of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Vector(T)")," definition. With interfaces, additionally ",(0,a.kt)("inlineCode",{parentName:"p"},"+"),"\nfor ",(0,a.kt)("inlineCode",{parentName:"p"},"Vector(MyType)")," could be implemented with ",(0,a.kt)("inlineCode",{parentName:"p"},"MyType"),". C++ provides this\nflexibility by also permitting non-method operator overloads, but this brings\nwith it the cost of selecting a best-matching operator from a potentially very\nlarge open overload set."))}d.isMDXComponent=!0}}]);