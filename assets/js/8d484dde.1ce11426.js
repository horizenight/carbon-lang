"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4983],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>u});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=i.createContext({}),m=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},s=function(e){var n=m(e.components);return i.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},c=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),c=m(t),u=a,h=c["".concat(l,".").concat(u)]||c[u]||d[u]||o;return t?i.createElement(h,r(r({ref:n},s),{},{components:t})):i.createElement(h,r({ref:n},s))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=c;var p={};for(var l in n)hasOwnProperty.call(n,l)&&(p[l]=n[l]);p.originalType=e,p.mdxType="string"==typeof e?e:a,r[1]=p;for(var m=2;m<o;m++)r[m]=t[m];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}c.displayName="MDXCreateElement"},4145:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>p,toc:()=>m});var i=t(7462),a=(t(7294),t(3905));const o={},r="`if` expressions",p={unversionedId:"expressions/if",id:"expressions/if",title:"`if` expressions",description:"\x3c!--",source:"@site/../docs/design/expressions/if.md",sourceDirName:"expressions",slug:"/expressions/if",permalink:"/carbon-lang/design/expressions/if",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/expressions/if.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Comparison operators",permalink:"/carbon-lang/design/expressions/comparison_operators"},next:{title:"Implicit conversions",permalink:"/carbon-lang/design/expressions/implicit_conversions"}},l={},m=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Semantics",id:"semantics",level:2},{value:"Finding a common type",id:"finding-a-common-type",level:2},{value:"Symmetry",id:"symmetry",level:3},{value:"Same type",id:"same-type",level:3},{value:"Implicit conversions",id:"implicit-conversions",level:3},{value:"Alternatives considered",id:"alternatives-considered",level:2},{value:"References",id:"references",level:2}],s={toc:m};function d(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"if-expressions"},(0,a.kt)("inlineCode",{parentName:"h1"},"if")," expressions"),(0,a.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#overview"},"Overview")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#syntax"},"Syntax")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#semantics"},"Semantics")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#finding-a-common-type"},"Finding a common type"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#symmetry"},"Symmetry")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#same-type"},"Same type")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#implicit-conversions"},"Implicit conversions")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#alternatives-considered"},"Alternatives considered")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#references"},"References"))),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"An ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," expression is an expression of the form:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"if")," ",(0,a.kt)("em",{parentName:"p"},"condition")," ",(0,a.kt)("inlineCode",{parentName:"p"},"then")," ",(0,a.kt)("em",{parentName:"p"},"value1")," ",(0,a.kt)("inlineCode",{parentName:"p"},"else")," ",(0,a.kt)("em",{parentName:"p"},"value2"))),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"condition")," is converted to a ",(0,a.kt)("inlineCode",{parentName:"p"},"bool")," value in the same way as the condition\nof an ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," statement."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Note:")," These conversions have not yet been decided.")),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"value1")," and ",(0,a.kt)("em",{parentName:"p"},"value2")," are implicitly converted to their\n",(0,a.kt)("a",{parentName:"p",href:"#finding-a-common-type"},"common type"),", which is the type of the ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," expression."),(0,a.kt)("h2",{id:"syntax"},"Syntax"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"if")," expressions have very low precedence, and cannot appear as the operand of\nany operator, except as the right-hand operand in an assignment. They can appear\nin other context where an expression is permitted, such as within parentheses,\nas the operand of a ",(0,a.kt)("inlineCode",{parentName:"p"},"return")," statement, as an initializer, or in a\ncomma-separated list such as a function call."),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"value1")," and ",(0,a.kt)("em",{parentName:"p"},"value2")," expressions are arbitrary expressions, and can\nthemselves be ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," expressions. ",(0,a.kt)("em",{parentName:"p"},"value2")," extends as far to the right as\npossible. An ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," expression can be parenthesized if the intent is for ",(0,a.kt)("em",{parentName:"p"},"value2"),"\nto end earlier."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// OK, same as `if cond then (1 + 1) else (2 + (4 * 6))`\nvar a: i32 = if cond then 1 + 1 else 2 + 4 * 6;\n\n// OK\nvar b: i32 = (if cond then 1 + 1 else 2) + 4 * 6;\n")),(0,a.kt)("p",null,"An ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," keyword at the start of a statement is always interpreted as an\n",(0,a.kt)("a",{parentName:"p",href:"/design/control_flow/conditionals"},(0,a.kt)("inlineCode",{parentName:"a"},"if")," statement"),", never as an ",(0,a.kt)("inlineCode",{parentName:"p"},"if"),"\nexpression, even if it is followed eventually by a ",(0,a.kt)("inlineCode",{parentName:"p"},"then")," keyword."),(0,a.kt)("h2",{id:"semantics"},"Semantics"),(0,a.kt)("p",null,"The converted ",(0,a.kt)("em",{parentName:"p"},"condition")," is evaluated. If it evaluates to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),", then the\nconverted ",(0,a.kt)("em",{parentName:"p"},"value1")," is evaluated and its value is the result of the expression.\nOtherwise, the converted ",(0,a.kt)("em",{parentName:"p"},"value2")," is evaluated and its value is the result of\nthe expression."),(0,a.kt)("h2",{id:"finding-a-common-type"},"Finding a common type"),(0,a.kt)("p",null,"The common type of two types ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"U")," is ",(0,a.kt)("inlineCode",{parentName:"p"},"(T as CommonType(U)).Result"),", where\n",(0,a.kt)("inlineCode",{parentName:"p"},"CommonType")," is the ",(0,a.kt)("inlineCode",{parentName:"p"},"Carbon.CommonType")," constraint. ",(0,a.kt)("inlineCode",{parentName:"p"},"CommonType")," is notionally\ndefined as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"constraint CommonType(U:! CommonTypeWith(Self)) {\n  extend CommonTypeWith(U) where .Result == U.Result;\n}\n")),(0,a.kt)("p",null,"The actual definition is a bit more complex than this, as described in\n",(0,a.kt)("a",{parentName:"p",href:"#symmetry"},"symmetry"),"."),(0,a.kt)("p",null,"The interface ",(0,a.kt)("inlineCode",{parentName:"p"},"CommonTypeWith")," is used to customize the behavior of\n",(0,a.kt)("inlineCode",{parentName:"p"},"CommonType"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"interface CommonTypeWith(U:! Type) {\n  let Result:! Type\n    where Self is ImplicitAs(.Self) and\n          U is ImplicitAs(.Self);\n}\n")),(0,a.kt)("p",null,"The implementation ",(0,a.kt)("inlineCode",{parentName:"p"},"A as CommonTypeWith(B)")," specifies the type that ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," would\nlike to result from unifying ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"B")," as its ",(0,a.kt)("inlineCode",{parentName:"p"},"Result"),"."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Note:")," It is required that both types implicitly convert to the common type.\nSome blanket ",(0,a.kt)("inlineCode",{parentName:"p"},"impl"),"s for ",(0,a.kt)("inlineCode",{parentName:"p"},"CommonTypeWith")," are provided as part of the prelude.\nThese are described in the following sections."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Note:")," The same mechanism is expected to eventually be used to compute common\ntypes in other circumstances."),(0,a.kt)("h3",{id:"symmetry"},"Symmetry"),(0,a.kt)("p",null,"The common type of ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"U")," should always be the same as the common type of\n",(0,a.kt)("inlineCode",{parentName:"p"},"U")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"T"),". This is enforced in two steps:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A ",(0,a.kt)("inlineCode",{parentName:"li"},"SymmetricCommonTypeWith")," interface implicitly provides a\n",(0,a.kt)("inlineCode",{parentName:"li"},"B as CommonTypeWith(A)")," implementation whenever one doesn't exist but an\n",(0,a.kt)("inlineCode",{parentName:"li"},"A as CommonTypeWith(B)")," implementation exists."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CommonType")," is defined in terms of ",(0,a.kt)("inlineCode",{parentName:"li"},"SymmetricCommonTypeWith"),", and requires\nthat both ",(0,a.kt)("inlineCode",{parentName:"li"},"A as SymmetricCommonTypeWith(B)")," and\n",(0,a.kt)("inlineCode",{parentName:"li"},"B as SymmetricCommonTypeWith(A)")," produce the same type.")),(0,a.kt)("p",null,"The interface ",(0,a.kt)("inlineCode",{parentName:"p"},"SymmetricCommonTypeWith")," is an implementation detail of the\n",(0,a.kt)("inlineCode",{parentName:"p"},"CommonType")," constraint. It is defined and implemented as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"interface SymmetricCommonTypeWith(U:! Type) {\n  let Result:! Type\n    where Self is ImplicitAs(.Self) and\n          U is ImplicitAs(.Self);\n}\nmatch_first {\n  impl [T:! Type, U:! CommonTypeWith(T)] T as SymmetricCommonTypeWith(U) {\n    let Result:! Type = U.Result;\n  }\n  impl [U:! Type, T:! CommonTypeWith(U)] T as SymmetricCommonTypeWith(U) {\n    let Result:! Type = T.Result;\n  }\n}\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"SymmetricCommonTypeWith")," interface is not exported, so user-defined ",(0,a.kt)("inlineCode",{parentName:"p"},"impl"),"s\ncan't be defined, and only the two blanket ",(0,a.kt)("inlineCode",{parentName:"p"},"impl"),"s above are used. The\n",(0,a.kt)("inlineCode",{parentName:"p"},"CommonType")," constraint is then defined as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"constraint CommonType(U:! SymmetricCommonTypeWith(Self)) {\n  extend SymmetricCommonTypeWith(U) where .Result == U.Result;\n}\n")),(0,a.kt)("p",null,"When computing the common type of ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"U"),", if only one of the types provides\na ",(0,a.kt)("inlineCode",{parentName:"p"},"CommonTypeWith")," implementation, that determines the common type. If both\ntypes provide a ",(0,a.kt)("inlineCode",{parentName:"p"},"CommonTypeWith")," implementation and their ",(0,a.kt)("inlineCode",{parentName:"p"},"Result")," types are the\nsame, that determines the common type. Otherwise, if both types provide\nimplementations but their ",(0,a.kt)("inlineCode",{parentName:"p"},"Result")," types differ, there is no common type, and\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"CommonType")," constraint is not met. For example, given:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Implementation #1\nimpl [T:! Type] MyX as CommonTypeWith(T) {\n  let Result:! Type = MyX;\n}\n\n// Implementation #2\nimpl [T:! Type] MyY as CommonTypeWith(T) {\n  let Result:! Type = MyY;\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"MyX as CommonTypeWith(MyY)")," will select #1, and ",(0,a.kt)("inlineCode",{parentName:"p"},"MyY as CommonTypeWith(MyX)"),"\nwill select #2, but the constraints on ",(0,a.kt)("inlineCode",{parentName:"p"},"MyX as CommonType(MyY)")," will not be met\nbecause result types differ."),(0,a.kt)("h3",{id:"same-type"},"Same type"),(0,a.kt)("p",null,"If ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," is the same type as ",(0,a.kt)("inlineCode",{parentName:"p"},"U"),", the result is that type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"final impl [T:! Type] T as CommonTypeWith(T) {\n  let Result:! Type = T;\n}\n")),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Note:")," This rule is intended to be considered more specialized than the other\nrules in this document."),(0,a.kt)("p",null,"Because this ",(0,a.kt)("inlineCode",{parentName:"p"},"impl")," is declared ",(0,a.kt)("inlineCode",{parentName:"p"},"final"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"T.(CommonType(T)).Result")," is always\nassumed to be ",(0,a.kt)("inlineCode",{parentName:"p"},"T"),", even in contexts where ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," involves a generic parameter and\nso the result would normally be an unknown type whose type-of-type is ",(0,a.kt)("inlineCode",{parentName:"p"},"Type"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"fn F[T:! Hashable](c: bool, x: T, y: T) -> HashCode {\n  // OK, type of `if` expression is `T`.\n  return (if c then x else y).Hash();\n}\n")),(0,a.kt)("h3",{id:"implicit-conversions"},"Implicit conversions"),(0,a.kt)("p",null,"If ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," implicitly converts to ",(0,a.kt)("inlineCode",{parentName:"p"},"U"),", the common type is ",(0,a.kt)("inlineCode",{parentName:"p"},"U"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"impl [T:! Type, U:! ImplicitAs(T)] T as CommonTypeWith(U) {\n  let Result:! Type = T;\n}\n")),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Note:")," If an implicit conversion is possible in both directions, and no more\nspecific implementation exists, the constraints on ",(0,a.kt)("inlineCode",{parentName:"p"},"T as CommonType(U)")," will not\nbe met because ",(0,a.kt)("inlineCode",{parentName:"p"},"(T as CommonTypeWith(U)).Result")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"(U as CommonTypeWith(T)).Result")," will differ. In order to define a common type\nfor such a case, ",(0,a.kt)("inlineCode",{parentName:"p"},"CommonTypeWith")," implementations in both directions must be\nprovided to override the blanket ",(0,a.kt)("inlineCode",{parentName:"p"},"impl"),"s in both directions:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"impl MyString as CommonTypeWith(YourString) {\n  let Result:! Type = MyString;\n}\nimpl YourString as CommonTypeWith(MyString) {\n  let Result:! Type = MyString;\n}\nvar my_string: MyString;\nvar your_string: YourString;\n// The type of `also_my_string` is `MyString`.\nvar also_my_string: auto = if cond then my_string else your_string;\n")),(0,a.kt)("h2",{id:"alternatives-considered"},"Alternatives considered"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0911.md#no-conditional-expression"},"Provide no conditional expression")),(0,a.kt)("li",{parentName:"ul"},"Use\n",(0,a.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0911.md#use-c-syntax"},(0,a.kt)("inlineCode",{parentName:"a"},"cond ? expr1 : expr2"),", like in C and C++"),"\nsyntax"),(0,a.kt)("li",{parentName:"ul"},"Use ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0911.md#no-then"},(0,a.kt)("inlineCode",{parentName:"a"},"if (cond) expr1 else expr2"))," syntax"),(0,a.kt)("li",{parentName:"ul"},"Use\n",(0,a.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0911.md#require-parentheses-around-the-condition"},(0,a.kt)("inlineCode",{parentName:"a"},"if (cond) then expr1 else expr2")),"\nsyntax"),(0,a.kt)("li",{parentName:"ul"},"Allow\n",(0,a.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0911.md#never-require-enclosing-parentheses"},(0,a.kt)("inlineCode",{parentName:"a"},"1 + if cond then expr1 else expr2"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0911.md#implicit-conversions-in-both-directions"},"Only require one ",(0,a.kt)("inlineCode",{parentName:"a"},"impl")," to specify the common type if implicit conversions in both directions are possible")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/proposals/p0911.md#support-lvalue-conditionals"},"Introduce special rules for lvalue conditionals"))),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Proposal\n",(0,a.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/911"},"#911: Conditional expressions"),".")))}d.isMDXComponent=!0}}]);