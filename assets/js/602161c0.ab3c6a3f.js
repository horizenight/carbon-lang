"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4162],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=i,f=m["".concat(o,".").concat(d)]||m[d]||c[d]||r;return n?a.createElement(f,l(l({ref:t},u),{},{components:n})):a.createElement(f,l({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6521:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={},l="Tuples",s={unversionedId:"tuples",id:"tuples",title:"Tuples",description:"\x3c!--",source:"@site/../docs/design/tuples.md",sourceDirName:".",slug:"/tuples",permalink:"/carbon-lang/design/tuples",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/tuples.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Templates",permalink:"/carbon-lang/design/templates"},next:{title:"Type inference",permalink:"/carbon-lang/design/type_inference"}},o={},p=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"TODO",id:"todo",level:2},{value:"Overview",id:"overview",level:2},{value:"Empty tuples",id:"empty-tuples",level:3},{value:"Indices as compile-time constants",id:"indices-as-compile-time-constants",level:3},{value:"Operations performed field-wise",id:"operations-performed-field-wise",level:3},{value:"Open questions",id:"open-questions",level:2},{value:"Slicing ranges",id:"slicing-ranges",level:3},{value:"Single-value tuples",id:"single-value-tuples",level:3},{value:"Function pattern match",id:"function-pattern-match",level:3},{value:"Type vs tuple of types",id:"type-vs-tuple-of-types",level:3}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tuples"},"Tuples"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#todo"},"TODO")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#overview"},"Overview"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#empty-tuples"},"Empty tuples")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#indices-as-compile-time-constants"},"Indices as compile-time constants")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#operations-performed-field-wise"},"Operations performed field-wise")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#open-questions"},"Open questions"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#slicing-ranges"},"Slicing ranges")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#single-value-tuples"},"Single-value tuples")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#function-pattern-match"},"Function pattern match")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-vs-tuple-of-types"},"Type vs tuple of types"))))),(0,i.kt)("h2",{id:"todo"},"TODO"),(0,i.kt)("p",null,"This is a skeletal design, added to support ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/carbon-lang/design/"},"the overview"),". It should\nnot be treated as accepted by the core team; rather, it is a placeholder until\nwe have more time to examine this detail. Please feel welcome to rewrite and\nupdate as appropriate."),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,'The primary composite type involves simple aggregation of other types as a tuple\n(called a "product type" in formal type theory):'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn DoubleBoth(x: i32, y: i32) -> (i32, i32) {\n  return (2 * x, 2 * y);\n}\n")),(0,i.kt)("p",null,"This function returns a tuple of two integers represented by the type\n",(0,i.kt)("inlineCode",{parentName:"p"},"(i32, i32)"),". The expression to return it uses a special tuple syntax to build a\ntuple within an expression: ",(0,i.kt)("inlineCode",{parentName:"p"},"(<expression>, <expression>)"),". This is actually the\nsame syntax in both cases. The return type is a tuple expression, and the first\nand second elements are expressions referring to the ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," type. The only\ndifference is the type of these expressions. Both are tuples, but one is a tuple\nof types."),(0,i.kt)("p",null,"Element access uses subscript syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn Bar(x: i32, y: i32) -> i32 {\n  var t: (i32, i32) = (x, y);\n  return t[0] + t[1];\n}\n")),(0,i.kt)("p",null,"Tuples also support multiple indices and slicing to restructure tuple elements:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn Baz(x: i32, y: i32, z: i32) -> (i32, i32) {\n  var t1: (i32, i32, i32) = (x, y, z);\n  var t2: (i32, i32, i32) = t1[(2, 1, 0)];\n  return t2[0 .. 2];\n}\n")),(0,i.kt)("p",null,"This code first reverses the tuple, and then extracts a slice using a half-open\nrange of indices."),(0,i.kt)("h3",{id:"empty-tuples"},"Empty tuples"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"()")," is the empty tuple. This is used in other parts of the design, such as\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/carbon-lang/design/functions"},"functions"),"."),(0,i.kt)("h3",{id:"indices-as-compile-time-constants"},"Indices as compile-time constants"),(0,i.kt)("p",null,"In the example ",(0,i.kt)("inlineCode",{parentName:"p"},"t1[(2, 1, 0)]"),", we will likely want to restrict these indices to\ncompile-time constants. Without that, run-time indexing would need to suddenly\nswitch to a variant-style return type to handle heterogeneous tuples. This would\nboth be surprising and complex for little or no value."),(0,i.kt)("h3",{id:"operations-performed-field-wise"},"Operations performed field-wise"),(0,i.kt)("p",null,"Like some other aggregate data types like\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/blob/trunk/carbon-lang/design/classes#struct-types"},"struct types"),", there are some operations are defined\nfor tuples field-wise:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"initialization"),(0,i.kt)("li",{parentName:"ul"},"assignment"),(0,i.kt)("li",{parentName:"ul"},"equality and inequality comparison"),(0,i.kt)("li",{parentName:"ul"},"ordered comparison"),(0,i.kt)("li",{parentName:"ul"},"implicit conversion for argument passing"),(0,i.kt)("li",{parentName:"ul"},"destruction")),(0,i.kt)("p",null,"For binary operations, the two tuples must have the same number of components\nand the operation must be defined for the corresponding component types of the\ntwo tuples."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"References:")," The rules for assignment, comparison, and implicit conversion\nfor argument passing were decided in\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/710"},"question-for-leads issue #710"),"."),(0,i.kt)("h2",{id:"open-questions"},"Open questions"),(0,i.kt)("h3",{id:"slicing-ranges"},"Slicing ranges"),(0,i.kt)("p",null,"The intent of ",(0,i.kt)("inlineCode",{parentName:"p"},"0 .. 2")," is to be syntax for forming a sequence of indices based\non the half-open range [0, 2). There are a bunch of questions we'll need to\nanswer here:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Is this valid anywhere? Only some places?"),(0,i.kt)("li",{parentName:"ul"},"What ",(0,i.kt)("em",{parentName:"li"},"is")," the sequence?",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"If it is a tuple of indices, maybe that solves the above issue, and\nunlike function call indexing with multiple indices is different from\nindexing with a tuple of indexes."))),(0,i.kt)("li",{parentName:"ul"},"Do we need syntax for a closed range (",(0,i.kt)("inlineCode",{parentName:"li"},"...")," perhaps, unclear if that ends up\n",(0,i.kt)("em",{parentName:"li"},"aligned")," or in ",(0,i.kt)("em",{parentName:"li"},"conflict")," with other likely uses of ",(0,i.kt)("inlineCode",{parentName:"li"},"...")," in pattern\nmatching)?"),(0,i.kt)("li",{parentName:"ul"},"All of these syntaxes are also very close to ",(0,i.kt)("inlineCode",{parentName:"li"},"0.2"),", is that similarity of\nsyntax OK?",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Do we want to require the ",(0,i.kt)("inlineCode",{parentName:"li"},"..")," to be surrounded by whitespace to\nminimize that collision?")))),(0,i.kt)("h3",{id:"single-value-tuples"},"Single-value tuples"),(0,i.kt)("p",null,"This remains an area of active investigation. There are serious problems with\nall approaches here. Without the collapse of one-tuples to scalars we need to\ndistinguish between a parenthesized expression (",(0,i.kt)("inlineCode",{parentName:"p"},"(42)"),") and a one tuple (in\nPython or Rust, ",(0,i.kt)("inlineCode",{parentName:"p"},"(42,)"),"), and if we distinguish them then we cannot model a\nfunction call as simply a function name followed by a tuple of arguments; one of\n",(0,i.kt)("inlineCode",{parentName:"p"},"f(0)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"f(0,)")," becomes a special case. With the collapse, we either break\ngenericity by forbidding ",(0,i.kt)("inlineCode",{parentName:"p"},"(42)[0]")," from working, or it isn't clear what it means\nto access a nested tuple's first element from a parenthesized expression:\n",(0,i.kt)("inlineCode",{parentName:"p"},"((1, 2))[0]"),"."),(0,i.kt)("h3",{id:"function-pattern-match"},"Function pattern match"),(0,i.kt)("p",null,"There are some interesting corner cases we need to expand on to fully and more\nprecisely talk about the exact semantic model of function calls and their\npattern match here, especially to handle variadic patterns and forwarding of\ntuples as arguments. We are hoping for a purely type system answer here without\nneeding templates to be directly involved outside the type system as happens in\nC++ variadics."),(0,i.kt)("h3",{id:"type-vs-tuple-of-types"},"Type vs tuple of types"),(0,i.kt)("p",null,"Is ",(0,i.kt)("inlineCode",{parentName:"p"},"(i32, i32)")," a type, a tuple of types, or is there even a difference between\nthe two? Is different syntax needed for these cases?"))}c.isMDXComponent=!0}}]);