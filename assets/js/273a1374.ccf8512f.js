"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5261],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),f=a,m=c["".concat(s,".").concat(f)]||c[f]||h[f]||r;return n?i.createElement(m,o(o({ref:t},d),{},{components:n})):i.createElement(m,o({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5902:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var i=n(7462),a=(n(7294),n(3905));const r={},o="Bitwise and shift operators",l={unversionedId:"expressions/bitwise",id:"expressions/bitwise",title:"Bitwise and shift operators",description:"\x3c!--",source:"@site/../docs/design/expressions/bitwise.md",sourceDirName:"expressions",slug:"/expressions/bitwise",permalink:"/design/expressions/bitwise",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/../docs/design/expressions/bitwise.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"`as` expressions",permalink:"/design/expressions/as_expressions"},next:{title:"Comparison operators",permalink:"/design/expressions/comparison_operators"}},s={},p=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Precedence and associativity",id:"precedence-and-associativity",level:2},{value:"Integer types",id:"integer-types",level:2},{value:"Integer constants",id:"integer-constants",level:2},{value:"Extensibility",id:"extensibility",level:2},{value:"Alternatives considered",id:"alternatives-considered",level:2},{value:"References",id:"references",level:2}],d={toc:p};function h(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"bitwise-and-shift-operators"},"Bitwise and shift operators"),(0,a.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#overview"},"Overview")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#precedence-and-associativity"},"Precedence and associativity")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#integer-types"},"Integer types")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#integer-constants"},"Integer constants")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#extensibility"},"Extensibility")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#alternatives-considered"},"Alternatives considered")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#references"},"References"))),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"Carbon provides a conventional set of operators for operating on bits:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"var a: u8 = 5;\nvar b: u8 = 3;\nvar c: i8 = -5;\n\n// 250\nvar complement: u8 = ^a;\n// 1\nvar bitwise_and: u8 = a & b;\n// 7\nvar bitwise_or: u8 = a | b;\n// 6\nvar bitwise_xor: u8 = a ^ b;\n// 40\nvar left_shift: u8 = a << b;\n// 2\nvar logical_right_shift: u8 = a >> 1;\n// -3\nvar arithmetic_right_shift: i8 = c >> 1;\n")),(0,a.kt)("p",null,"These operators have ",(0,a.kt)("a",{parentName:"p",href:"#integer-types"},"predefined meanings")," for Carbon's integer\ntypes. User-defined types can define the meaning of these operations by\n",(0,a.kt)("a",{parentName:"p",href:"#extensibility"},"implementing an interface")," provided as part of the Carbon\nstandard library."),(0,a.kt)("h2",{id:"precedence-and-associativity"},"Precedence and associativity"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-mermaid"},'%%{init: {\'themeVariables\': {\'fontFamily\': \'monospace\'}}}%%\ngraph BT\n    complement["^x"]\n    bitwise_and>"x & y"]\n    bitwise_or>"x | y"]\n    bitwise_xor>"x ^ y"]\n    shift["x << y<br>\n           x >> y"]\n    bitwise_and & bitwise_or & bitwise_xor & shift --\x3e complement\n')),(0,a.kt)("small",null,"[Instructions for reading this diagram.](/design/#precedence)"),(0,a.kt)("p",null,"Parentheses are required when mixing different bitwise and bit-shift operators.\nBinary ",(0,a.kt)("inlineCode",{parentName:"p"},"&"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"|"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"^")," are left-associative. The bit-shift operators ",(0,a.kt)("inlineCode",{parentName:"p"},"<<")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},">>")," are non-associative."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// \u2705 Same as (1 | 2) | 4, evaluates to 7.\nvar a: i32 = 1 | 2 | 4;\n\n// \u274c Error, parentheses are required to distinguish between\n//    (3 | 5) & 6, which evaluates to 6, and\n//    3 | (5 & 6), which evaluates to 7.\nvar b: i32 = 3 | 5 & 6;\n\n// \u274c Error, parentheses are required to distinguish between\n//    (1 << 2) << 3, which evaluates to 4 << 3 == 32, and\n//    1 << (2 << 3), which evaluates to 1 << 16 == 65536.\nvar c: i32 = 1 << 2 << 3;\n\n// \u274c Error, can't repeat the `^` operator. Use `^(^4)` or simply `4`.\nvar d: i32 = ^^4;\n")),(0,a.kt)("h2",{id:"integer-types"},"Integer types"),(0,a.kt)("p",null,"Bitwise and bit-shift operators are supported for Carbon's built-in integer\ntypes, and, unless that behavior is ",(0,a.kt)("a",{parentName:"p",href:"#extensibility"},"overridden"),", for types that\ncan be implicitly converted to integer types, as follows:"),(0,a.kt)("p",null,"For binary bitwise operators, if one operand has an integer type and the other\noperand can be implicitly converted to that type, then it is. If both operands\nare of integer type, this results in the following conversions:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If the types are ",(0,a.kt)("inlineCode",{parentName:"li"},"uN")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"uM"),", or they are ",(0,a.kt)("inlineCode",{parentName:"li"},"iN")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"iM"),", the operands are\nconverted to the larger type."),(0,a.kt)("li",{parentName:"ul"},"If one type is ",(0,a.kt)("inlineCode",{parentName:"li"},"iN")," and the other type is ",(0,a.kt)("inlineCode",{parentName:"li"},"uM"),", and ",(0,a.kt)("inlineCode",{parentName:"li"},"M")," < ",(0,a.kt)("inlineCode",{parentName:"li"},"N"),", the ",(0,a.kt)("inlineCode",{parentName:"li"},"uM"),"\noperand is converted to ",(0,a.kt)("inlineCode",{parentName:"li"},"iN"),".")),(0,a.kt)("p",null,"A built-in binary bitwise ",(0,a.kt)("inlineCode",{parentName:"p"},"&"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"|"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"^")," operation is performed if, after the\nabove conversion step, the operands have the same integer type. The result type\nis that type, and the result value is produced by applying the relevant\noperation -- AND, OR, or XOR -- to each pair of corresponding bits in the input,\nincluding the sign bit for a signed integer type."),(0,a.kt)("p",null,"A built-in complement operation is performed if the operand can be implicitly\nconverted to an integer type. The result type is that type, and the result value\nis produced by flipping all bits in the input, including the sign bit for a\nsigned integer type. ",(0,a.kt)("inlineCode",{parentName:"p"},"^a")," is equivalent to ",(0,a.kt)("inlineCode",{parentName:"p"},"a ^ x"),", where ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," is the\nall-one-bits value of the same type as ",(0,a.kt)("inlineCode",{parentName:"p"},"a"),"."),(0,a.kt)("p",null,"A built-in bit-shift operation is performed if both operands are, or can be\nimplicitly converted to, integer types. The result type is the converted type of\nthe first operand. The result value is produced by shifting the first operand\nleft for ",(0,a.kt)("inlineCode",{parentName:"p"},"<<")," or right for ",(0,a.kt)("inlineCode",{parentName:"p"},">>")," a number of positions equal to the second\noperand. Vacant positions are filled with ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," bits, except for a right shift\nwhere the first operand is of a signed type and has a negative value, in which\ncase they are filled with ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," bits."),(0,a.kt)("p",null,"For the purposes of bit-shifts, bits are ordered by significance, with the most\nsignificant bit being the leftmost bit and the least significant bit being the\nrightmost bit. As a consequence, in the absence of overflow a left shift is\nequivalent to a multiplication by a power of 2 and a right shift is equivalent\nto a division by a power of two, rounding downwards."),(0,a.kt)("p",null,"The second operand of a bit-shift is required to be between zero (inclusive) and\nthe bit-width of the first operand (exclusive); it is a programming error if the\nsecond operand is not within that range."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"In a development build, they will be caught immediately when they happen at\nruntime."),(0,a.kt)("li",{parentName:"ul"},"In a performance build, the optimizer may assume that this programming error\ndoes not occur."),(0,a.kt)("li",{parentName:"ul"},"In a hardened build, the result will have well the defined behavior of\neither aborting the program or performing a shift of an unspecified number\nof bits, which if wider than the first operand will result in ",(0,a.kt)("inlineCode",{parentName:"li"},"0")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"-1"),".\nIn the case where the program is aborted, the program might not in all cases\nbe aborted immediately -- for example, multiple checks might be combined\ninto one -- but no control flow or memory access that depends on the value\nwill be performed.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"TODO:")," Unify the description of these programming errors with those of\narithmetic overflow, document the behavior in a common place and link to it from\nhere."),(0,a.kt)("h2",{id:"integer-constants"},"Integer constants"),(0,a.kt)("p",null,"These operations can also be applied to a pair of integer constants, or to an\ninteger constant and a value of integer type, as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If any binary bitwise or bit-shift operator is applied to two integer\nconstants, or the unary ",(0,a.kt)("inlineCode",{parentName:"li"},"^")," operator is applied to an integer constant, the\nresult is an integer constant. Integer constants are treated as having\ninfinitely many high-order bits, where all but finitely many of those bits\nare sign bits. For example, ",(0,a.kt)("inlineCode",{parentName:"li"},"-1")," comprises infinitely many ",(0,a.kt)("inlineCode",{parentName:"li"},"1")," bits. Note\nthat there is no difference between an arithmetic and a logical right shift\non an integer constant, because every bit always has a higher-order bit to\nshift from.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"It is easy to produce extremely large numbers by left-shifting an\ninteger constant. For example, the binary representation of\n",(0,a.kt)("inlineCode",{parentName:"li"},"1 << (1 << 1000)")," is thought to be substantially larger than the total\nentropy in the observable universe. In practice, Carbon implementations\nwill set a much lower limit on the largest integer constant that they\nsupport."))),(0,a.kt)("li",{parentName:"ul"},"If a binary bitwise ",(0,a.kt)("inlineCode",{parentName:"li"},"&"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"|"),", or ",(0,a.kt)("inlineCode",{parentName:"li"},"^")," operation is applied to an integer\nconstant and a value of an integer type to which the constant can be\nimplicitly converted, the operand that is an integer constant is implicitly\nconverted to the integer type and the computation is performed as described\n",(0,a.kt)("a",{parentName:"li",href:"#integer-types"},"above"),"."),(0,a.kt)("li",{parentName:"ul"},"If the second operand of a bit-shift operator is an integer constant and the\nfirst operand is not, and the second operand is between 0 (inclusive) and\nthe bit-width of the first operand (exclusive), the integer constant is\nconverted to an integer type that can hold its value and the computation is\nperformed as described above.")),(0,a.kt)("p",null,"Other operations involving integer constants are invalid. For example, a bitwise\n",(0,a.kt)("inlineCode",{parentName:"p"},"&")," between a ",(0,a.kt)("inlineCode",{parentName:"p"},"u8")," and an integer constant ",(0,a.kt)("inlineCode",{parentName:"p"},"500")," is invalid because ",(0,a.kt)("inlineCode",{parentName:"p"},"500"),"\ndoesn't fit into ",(0,a.kt)("inlineCode",{parentName:"p"},"u8"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"1 << n")," is invalid if ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," is an integer variable\nbecause we don't know what type to use to compute the result."),(0,a.kt)("p",null,"Note that the unary ",(0,a.kt)("inlineCode",{parentName:"p"},"^")," operator applied to a non-negative integer constant\nresults in a negative integer constant, and the binary ",(0,a.kt)("inlineCode",{parentName:"p"},"^")," operator gives a\nnegative result if exactly one of the input operands was negative. For example,\n",(0,a.kt)("inlineCode",{parentName:"p"},"^0 == -1")," evaluates to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,a.kt)("h2",{id:"extensibility"},"Extensibility"),(0,a.kt)("p",null,"Bitwise and shift operators can be provided for user-defined types by\nimplementing the following family of interfaces:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Unary `^`.\ninterface BitComplement {\n  let Result:! Type = Self;\n  fn Op[me: Self]() -> Result;\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Binary `&`.\ninterface BitAndWith(U:! Type) {\n  let Result:! Type = Self;\n  fn Op[me: Self](other: U) -> Result;\n}\nconstraint BitAnd {\n  extends BitAndWith(Self) where .Result = Self;\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Binary `|`.\ninterface BitOrWith(U:! Type) {\n  let Result:! Type = Self;\n  fn Op[me: Self](other: U) -> Result;\n}\nconstraint BitOr {\n  extends BitOrWith(Self) where .Result = Self;\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Binary `^`.\ninterface BitXorWith(U:! Type) {\n  let Result:! Type = Self;\n  fn Op[me: Self](other: U) -> Result;\n}\nconstraint BitXor {\n  extends BitXorWith(Self) where .Result = Self;\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Binary `<<`.\ninterface LeftShiftWith(U:! Type) {\n  let Result:! Type = Self;\n  fn Op[me: Self](other: U) -> Result;\n}\nconstraint LeftShift {\n  extends LeftShiftWith(Self) where .Result = Self;\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Binary `>>`.\ninterface RightShiftWith(U:! Type) {\n  let Result:! Type = Self;\n  fn Op[me: Self](other: U) -> Result;\n}\nconstraint RightShift {\n  extends RightShiftWith(Self) where .Result = Self;\n}\n")),(0,a.kt)("p",null,"Given ",(0,a.kt)("inlineCode",{parentName:"p"},"x: T")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"y: U"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The expression ",(0,a.kt)("inlineCode",{parentName:"li"},"^x")," is rewritten to ",(0,a.kt)("inlineCode",{parentName:"li"},"x.(BitComplement.Op)()"),"."),(0,a.kt)("li",{parentName:"ul"},"The expression ",(0,a.kt)("inlineCode",{parentName:"li"},"x & y")," is rewritten to ",(0,a.kt)("inlineCode",{parentName:"li"},"x.(BitAndWith(U).Op)(y)"),"."),(0,a.kt)("li",{parentName:"ul"},"The expression ",(0,a.kt)("inlineCode",{parentName:"li"},"x | y")," is rewritten to ",(0,a.kt)("inlineCode",{parentName:"li"},"x.(BitOrWith(U).Op)(y)"),"."),(0,a.kt)("li",{parentName:"ul"},"The expression ",(0,a.kt)("inlineCode",{parentName:"li"},"x ^ y")," is rewritten to ",(0,a.kt)("inlineCode",{parentName:"li"},"x.(BitXorWith(U).Op)(y)"),"."),(0,a.kt)("li",{parentName:"ul"},"The expression ",(0,a.kt)("inlineCode",{parentName:"li"},"x << y")," is rewritten to ",(0,a.kt)("inlineCode",{parentName:"li"},"x.(LeftShiftWith(U).Op)(y)"),"."),(0,a.kt)("li",{parentName:"ul"},"The expression ",(0,a.kt)("inlineCode",{parentName:"li"},"x >> y")," is rewritten to ",(0,a.kt)("inlineCode",{parentName:"li"},"x.(RightShiftWith(U).Op)(y)"),".")),(0,a.kt)("p",null,"Implementations of these interfaces are provided for built-in types as necessary\nto give the semantics described above."),(0,a.kt)("h2",{id:"alternatives-considered"},"Alternatives considered"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/proposals/p1191.md#use-different-symbols-for-bitwise-operators"},"Use different symbols for bitwise operators")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/proposals/p1191.md#provide-different-operators-for-arithmetic-and-logical-shifts"},"Provide different operators for arithmetic and logical shifts")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/proposals/p1191.md#provide-rotate-operators"},"Provide rotate operators")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/proposals/p1191.md#guarantee-behavior-of-large-shifts"},"Guarantee the behavior of large shifts")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/proposals/p1191.md#support-shifting-a-constant-by-a-variable"},"Support shifting a constant by a variable"))),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Proposal\n",(0,a.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1191"},"#1191: bitwise and shift operators"),".")))}h.isMDXComponent=!0}}]);