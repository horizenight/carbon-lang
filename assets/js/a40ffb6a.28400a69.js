"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[882],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=o,h=p["".concat(l,".").concat(m)]||p[m]||u[m]||i;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9011:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const i={},r="Goals",s={unversionedId:"goals",id:"goals",title:"Goals",description:"\x3c!--",source:"@site/../docs/project/goals.md",sourceDirName:".",slug:"/goals",permalink:"/carbon-lang/project/goals",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/goals.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Project FAQ",permalink:"/carbon-lang/project/faq"},next:{title:"Groups",permalink:"/carbon-lang/project/groups"}},l={},c=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Project goals",id:"project-goals",level:2},{value:"Community and culture",id:"community-and-culture",level:3},{value:"Language tools and ecosystem",id:"language-tools-and-ecosystem",level:3},{value:"Language goals and priorities",id:"language-goals-and-priorities",level:2},{value:"Performance-critical software",id:"performance-critical-software",level:3},{value:"Software and language evolution",id:"software-and-language-evolution",level:3},{value:"Code that is easy to read, understand, and write",id:"code-that-is-easy-to-read-understand-and-write",level:3},{value:"Practical safety and testing mechanisms",id:"practical-safety-and-testing-mechanisms",level:3},{value:"Fast and scalable development",id:"fast-and-scalable-development",level:3},{value:"Modern OS platforms, hardware architectures, and environments",id:"modern-os-platforms-hardware-architectures-and-environments",level:3},{value:"Interoperability with and migration from existing C++ code",id:"interoperability-with-and-migration-from-existing-c-code",level:3},{value:"Non-goals",id:"non-goals",level:2},{value:"Stable language and library ABI",id:"stable-language-and-library-abi",level:3},{value:"Backwards or forwards compatibility",id:"backwards-or-forwards-compatibility",level:3},{value:"Legacy compiled libraries without source code or ability to rebuild",id:"legacy-compiled-libraries-without-source-code-or-ability-to-rebuild",level:3},{value:"Support for existing compilation and linking models",id:"support-for-existing-compilation-and-linking-models",level:3},{value:"Idiomatic migration of non-modern, non-idiomatic C++ code",id:"idiomatic-migration-of-non-modern-non-idiomatic-c-code",level:3},{value:"Prioritization beyond goals",id:"prioritization-beyond-goals",level:2},{value:"Acknowledgements",id:"acknowledgements",level:2}],d={toc:c};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"goals"},"Goals"),(0,o.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#overview"},"Overview")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#project-goals"},"Project goals"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#community-and-culture"},"Community and culture")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#language-tools-and-ecosystem"},"Language tools and ecosystem")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#language-goals-and-priorities"},"Language goals and priorities"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#performance-critical-software"},"Performance-critical software")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#software-and-language-evolution"},"Software and language evolution")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#code-that-is-easy-to-read-understand-and-write"},"Code that is easy to read, understand, and write")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#practical-safety-and-testing-mechanisms"},"Practical safety and testing mechanisms")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#fast-and-scalable-development"},"Fast and scalable development")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#modern-os-platforms-hardware-architectures-and-environments"},"Modern OS platforms, hardware architectures, and environments")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#interoperability-with-and-migration-from-existing-c-code"},"Interoperability with and migration from existing C++ code")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#non-goals"},"Non-goals"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#stable-language-and-library-abi"},"Stable language and library ABI")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#backwards-or-forwards-compatibility"},"Backwards or forwards compatibility")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#legacy-compiled-libraries-without-source-code-or-ability-to-rebuild"},"Legacy compiled libraries without source code or ability to rebuild")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#support-for-existing-compilation-and-linking-models"},"Support for existing compilation and linking models")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#idiomatic-migration-of-non-modern-non-idiomatic-c-code"},"Idiomatic migration of non-modern, non-idiomatic C++ code")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#prioritization-beyond-goals"},"Prioritization beyond goals")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#acknowledgements"},"Acknowledgements"))),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"Carbon is an experiment to explore a possible, distant future for the C++\nprogramming language designed around a specific set of goals, priorities, and\nuse cases."),(0,o.kt)("p",null,"A programming language is a tool, and different tools are good for different\npurposes. We think there is great value in priorities that differentiate Carbon\nfrom other programming languages. Stating Carbon\u2019s priorities clearly and\nexplicitly shapes the design of Carbon, and helps the entire community\neffectively evaluate and use the language."),(0,o.kt)("p",null,"Carbon's language goals have historically been best addressed by C++, and there\nare large ecosystems and codebases written using C++ to these ends. Carbon\nshould be attractive and easy for C++ developers to try out and incrementally\nadopt, even in individual libraries both using and used from C++ code. We expect\nthis depends on having high-performance bidirectional interoperability with C++,\nexcellent migration tooling, and an easy ramp-up for experienced C++ software\ndevelopers."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/carbon-lang/project/principles/"},"Principles")," are provided to clarify these goals.\nPrinciples do not supersede goals and priorities."),(0,o.kt)("h2",{id:"project-goals"},"Project goals"),(0,o.kt)("h3",{id:"community-and-culture"},"Community and culture"),(0,o.kt)("p",null,"Carbon has an overarching goal of promoting a healthy and vibrant community with\nan inclusive, welcoming, and pragmatic culture. While this may not directly\naffect Carbon's design, it affects how Carbon's design occurs. We cannot build a\ngood language without a good community. As the saying goes,\n",(0,o.kt)("a",{parentName:"p",href:"https://techcrunch.com/2014/04/12/culture-eats-strategy-for-breakfast/"},'"culture eats strategy for breakfast"'),".\nCarbon's community, including both maintainers and users, needs to last for\nyears and be capable of scaling up. It needs to support people working on Carbon\nacross a wide range of companies as their full time job, but also people\ncontributing in small fractions of their time, or as students, teachers, or as a\nhobby. There are several key ingredients to achieving this."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"The community and project needs a code of conduct.")," We want Carbon's\ncommunity to be welcoming and respectful, with a deep commitment to\npsychological safety. We need consistent expectations for how every community\nmember should behave, regardless of their position in the community. These\nexpectations around conduct and behavior need to be clearly articulated both to\nset expectations for people joining, and to help remind and anchor us on\nconsistent standards. It is also important that we hold ourselves accountable to\nthese expectations and have real and meaningful mechanisms to moderate the\ncommunity. When behavior steps outside of our expectations, we need tools,\nprocess, and policy for how we will recognize and correct it."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"An open, inclusive process for Carbon changes.")," The community needs to be\nable to effectively engage in the direction and evolution of the project and\nlanguage, while keeping the process efficient and effective. That means we need\nan open, inclusive process where everyone feels comfortable participating.\nCommunity members should understand how and why decisions are made, and have the\nability to both influence them before they occur and give feedback afterward. We\nwant to use this process to also ensure we stick to our language priorities and\nhave clear rationales for all of our technical designs and decisions."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Being inclusive is different from including everyone.")," We want to avoid\nexcluding or marginalizing members of the community. However, we expect to\ninevitably make choices that benefit some Carbon community members more than\nothers. We will provide justification for these decisions, but achieving\nCarbon's goals -- including that of a healthy community -- will be the guiding\nrule."),(0,o.kt)("h3",{id:"language-tools-and-ecosystem"},"Language tools and ecosystem"),(0,o.kt)("p",null,"Programming languages do not succeed in a vacuum. The Carbon project cannot\nmerely ",(0,o.kt)("em",{parentName:"p"},"design")," a language in order to succeed, it must tackle the full\necosystem of tooling that makes developers effective using the language. This\nincludes not only a compiler and standard library, but also a broad range of\nother tools that enable developers to be more effective, efficient, or\nproductive."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"We will provide a reference implementation.")," This helps the language have a\nstrong and consistent experience for developers and a clear onboarding process.\nIt also enables us to carefully consider implementation considerations\nthroughout the design of the language. However, we do ",(0,o.kt)("em",{parentName:"p"},"not")," want this to be seen\nas a replacement for a formal specification at any point."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Carbon will have a formal specification."),' Fully specifying the language\nenables other implementations and allows us to clearly document the expected\nbehavior of the reference implementation. This does not mean the specification\ndefines what is "correct"; instead, the specification and reference\nimplementation should complement each other. Any divergence is a bug that ',(0,o.kt)("em",{parentName:"p"},"must"),"\nbe resolved, and the specification and reference should always converge. Carbon\nshould not have designs or specifications which do not match the practical\nimplementation, even if that means updating designs to reflect implementation\nrealities. Having the specification will enable better analysis of the language\nas a whole and the production of other partial or full implementations which\nmatch the behavior of the reference implementation."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Approachable, developer-facing documentation.")," Developers shouldn't be\nexpected to read through the specification to ramp up with Carbon. User guides\nand other documentation will be provided to make it easy to learn how to use\nCarbon."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Compelling adoption tooling.")," We want to provide a compelling suite of tools\nout-of-the-box in order to encourage adoption of Carbon at scale where it can\naugment existing C++ codebases. For example, we expect a C++ -> Carbon code\ntranslator will be important."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Tooling for updating code when Carbon evolves.")," As Carbon evolves over time,\nwe expect to provide tooling to help automate and scale migrating existing\nCarbon code to the new version. The goal is to enable more rapid evolution of\nthe language without the churn tax and version skew becoming unsustainable."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Developer tooling.")," We need developers to be productive reading and writing\nCarbon code. We expect to provide a broad suite of development oriented tools\nranging from refactoring tools to ",(0,o.kt)("a",{parentName:"p",href:"https://langserver.org/"},"LSP")," implementations\nand editor integrations. We also plan to provide machine readable forms of many\nparts of the language, such as a grammar, to ensure consistency between tools\nand enable the development of tools by others."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Infrastructure to enable package management and other library ecosystem\nsupport.")," The goal is to support what the ecosystem needs, regardless of the\nexact form this ends up taking."),(0,o.kt)("h2",{id:"language-goals-and-priorities"},"Language goals and priorities"),(0,o.kt)("p",null,"We are designing Carbon to support:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Performance-critical software"),(0,o.kt)("li",{parentName:"ul"},"Software and language evolution"),(0,o.kt)("li",{parentName:"ul"},"Code that is easy to read, understand, and write"),(0,o.kt)("li",{parentName:"ul"},"Practical safety and testing mechanisms"),(0,o.kt)("li",{parentName:"ul"},"Fast and scalable development"),(0,o.kt)("li",{parentName:"ul"},"Modern OS platforms, hardware architectures, and environments"),(0,o.kt)("li",{parentName:"ul"},"Interoperability with and migration from existing C++ code")),(0,o.kt)("p",null,"Many languages share subsets of these goals, but what distinguishes Carbon is\ntheir combination. Where it is necessary to make tradeoffs between these goals,\nwe intend to prioritize them in this order."),(0,o.kt)("p",null,"Each goal is broad, and has several facets to consider when making decisions.\nBelow, we discuss all of these goals in more detail to give a deeper\nunderstanding of both the nature and motivation of these goals."),(0,o.kt)("h3",{id:"performance-critical-software"},"Performance-critical software"),(0,o.kt)("p",null,"All software consumes resources: time, memory, compute, power, binary size, and\nso on. In many cases, raw resource usage is not the biggest concern. Instead,\nalgorithmic efficiency or business logic dominates these concerns. However,\nthere exists software where its rate of resource consumption -- its performance\n-- is critical to its successful operation. Another way to think about when\nperformance is critical: would a performance regression be considered a bug?\nWould it even be noticed?"),(0,o.kt)("p",null,"Our goal is to support software where its performance with respect to some set\nof resource constraints is critical to its successful operation. This\noverarching goal can be decomposed into a few specific aspects."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Provide the developer control over every aspect of performance."),' When faced\nwith some performance problem, the developer should always have tools within\nCarbon to address it. This does not mean that the developer is necessarily\nconcerned with ultimate performance at every moment, but in the most constrained\nscenarios they must be able to "open up the hood" without switching to another\nlanguage.'),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Idiomatic code should be fast.")," Developers should not regularly be required\nto choose between performance and readability. Although performance tuning may\nin rare cases require complex or surprising code, Carbon's design should ensure\nregular, idiomatic code usually results in high performance."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Code should perform predictably.")," The reader and writer of code should be\nable to easily understand its expected performance, given sufficient background\nknowledge of the environment in which it will run. This need not be precise, but\ninstead can use heuristics and guidelines to avoid surprise. The key priority is\nthat performance, whether good or bad, is unsurprising to developers. Even\npleasant surprises, when too frequent, can become a problem due to establishing\nbrittle baseline performance that cannot be reliably sustained."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Leave no room for a lower level language.")," Developers should not need to\nleave the rules and structure of Carbon, whether to gain control over\nperformance problems or to gain access to hardware facilities."),(0,o.kt)("h3",{id:"software-and-language-evolution"},"Software and language evolution"),(0,o.kt)("p",null,'Titus Winters writes in "Non-Atomic Refactoring and Software Sustainability":'),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"What is the difference between programming and software engineering? These are\nnebulous concepts and thus there are many possible answers, but my favorite\ndefinition is this: Software engineering is programming integrated over time.\nAll of the hard parts of engineering come from dealing with time:\ncompatibility over time, dealing with changes to underlying infrastructure and\ndependencies, and working with legacy code or data. Fundamentally, it is a\ndifferent task to produce a programming solution to a problem (that solves the\ncurrent ","[instance]"," of the problem) versus an engineering solution (that solves\ncurrent instances, future instances that we can predict, and - through\nflexibility - allows updates to solve future instances we may not be able to\npredict).")),(0,o.kt)("p",null,'Carbon will prioritize being a "software engineering" language, in the above\nsense. We specifically are interested in dealing with the time-oriented aspects\nof software built in this language. We need to be prepared for substantive\nchanges in priority over the next decade, on par with the changes experienced in\nthe 2010s: 10x scaling of software organizations, mobile, cloud, diversification\nof platforms and architectures, and so on.'),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Support maintaining and evolving software written in Carbon for decades.")," The\nlife expectancy of some software will be long and the software will not be\nstatic or unchanging in that time. Mistakes will be made and need to be\ncorrected. New functionality will be introduced and old functionality retired\nand removed. The design of Carbon must support and ease every step of this\nprocess. This ranges from emphasizing testing and continuous integration to\ntooling and the ability to make non-atomic changes. It also includes constraints\non the design of Carbon itself: we should avoid, or at least minimize, language\nfeatures that encourage unchangeable constructs. For example, any feature with a\ncontract that cannot be strengthened or weakened without breaking the expected\nusage patterns is inherently hostile to refactoring. Analogously, features or\nconventions that require simultaneously updating all users of an API when\nextending it are inherently hostile towards long-term maintenance of software."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Support maintaining and evolving the language itself for decades.")," We will\nnot get the design of most language features correct on our first, second, or\n73rd try. As a consequence, there must be a built-in plan and ability to move\nCarbon forward at a reasonable pace and with a reasonable cost. Simultaneously,\nan evolving language must not leave software behind to languish, but bring\nsoftware forward. This requirement should not imply compatibility, but instead\nsome migratability, likely tool-assisted."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Be mindful of legacy.")," Globally, there may be as many as 50 billion lines of\nC++ code. Any evolution of Carbon that fails to account for human\ninvestment/training and legacy code, representing significant capital, is doomed\nfrom the start. Note that our priority is restricted to legacy source code; we\ndo not prioritize full support of legacy object code. While that still leaves\nmany options open, such as dedicated and potentially slower features, it does\nlimit the degree to which legacy use cases beyond source code should shape the\nCarbon design."),(0,o.kt)("h3",{id:"code-that-is-easy-to-read-understand-and-write"},"Code that is easy to read, understand, and write"),(0,o.kt)("p",null,"While this is perhaps the least unique among programming languages of the goals\nwe list here, we feel it is important to state it, explain all of what we mean\nby it, and fit it into our prioritization scheme."),(0,o.kt)("p",null,"Software has inherent complexity that burdens developers, especially at scale\nand over time. Carbon will strive to minimize that burden for reading,\nunderstanding, and writing code. The behavior of code should be easily\nunderstood, especially by those unfamiliar with the software system. Consider\ndevelopers attempting to diagnose a serious outage under time pressure -- every\nsecond spent trying to understand the ",(0,o.kt)("em",{parentName:"p"},"language")," is one not spent understanding\nthe ",(0,o.kt)("em",{parentName:"p"},"problem"),"."),(0,o.kt)("p",null,"While the source code of our software may be read far more often by machines,\nhumans are the most expensive readers and writers of software. As a consequence,\nwe need to optimize for human reading, understanding, and writing of software,\nin that order."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Excellent ergonomics."),' Human capabilities and limitations in the domains of\nperception, memory, reasoning, and decision-making affect interactions between\nhumans and systems. Ergonomic language design takes human factors into account\nto increase productivity and comfort, and reduce errors and fatigue, making\nCarbon more suitable for humans to use. We can also say that ergonomic designs\nare accessible to humans. "Readability" is a related, but a more focused\nconcept, connected to only the process of reading code. "Ergonomics" covers all\nactivities where humans interact with Carbon: reading, writing, designing,\ndiscussing, reviewing, and refactoring code, as well as learning and teaching\nCarbon. A few examples:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Carbon should not use symbols that are difficult to type, see, or\ndifferentiate from similar symbols in commonly used contexts."),(0,o.kt)("li",{parentName:"ul"},"Syntax should be easily parsed and scanned by any human in any development\nenvironment, not just a machine or a human aided by semantic hints from an\nIDE."),(0,o.kt)("li",{parentName:"ul"},"Code with similar behavior should use similar syntax, and code with\ndifferent behavior should use different syntax. Behavior in this context\nshould include both the functionality and performance of the code. This is\npart of conceptual integrity."),(0,o.kt)("li",{parentName:"ul"},"Explicitness must be balanced against conciseness, as verbosity and ceremony\nadd cognitive overhead for the reader, while explicitness reduces the amount\nof outside context the reader must have or assume."),(0,o.kt)("li",{parentName:"ul"},"Common yet complex tasks, such as parallel code, should be well-supported in\nways that are easy to reason about."),(0,o.kt)("li",{parentName:"ul"},"Ordinary tasks should not require extraordinary care, because humans cannot\nconsistently avoid making mistakes for an extended amount of time.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Support tooling at every layer of the development experience, including\nIDEs.")," The design and implementation of Carbon should make it easy to create\nsuch tools and make them effective. Carbon should avoid syntax and textual\nstructures that are difficult to recognize and mechanically change without\nlosing meaning."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Support software outside of the primary use cases well.")," There are\nsurprisingly high costs for developers to switch languages. Even when the\nprimary goal is to support performance-critical software, other kinds of\nsoftware should not be penalized unnecessarily."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},'"The right tool for the job is often the tool you are already using -- adding\nnew tools has a higher cost than many people appreciate."'),(0,o.kt)("p",{parentName:"blockquote"},"-- ",(0,o.kt)("a",{parentName:"p",href:"https://twitter.com/id_aa_carmack/status/989951283900514304"},"John Carmack"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Focus on encouraging appropriate usage of features rather than restricting\nmisuse."),' Adding arbitrary restrictions to prevent misuse of otherwise general\nfeatures of the language can create problems when they end up interfering with\nunexpected or rare but still appropriate usages. Instead, Carbon should focus on\nenabling appropriate and effective usage of features, and creating incentives\naround those. What seems initially like a "misuse" of a feature may be critical\nfor some rare or future use case. Put differently, we will not always be able to\nprevent developers from misusing features or writing unnecessarily complex code,\nand that is okay. We should instead focus on helping reduce the rate that this\noccurs accidentally, and enabling tooling and diagnostics that warn about\ndangerous or surprising patterns.'),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"The behavior and semantics of code should be clearly and simply specified\nwhenever possible.")," Leaving behavior undefined for some cases of invalid,\nbuggy, or non-portable code may be necessary, but it comes at a very high cost\nand should be avoided. Every case where behavior is left undefined should be\nclearly spelled out with a strong rationale for this tradeoff. The code patterns\nwithout defined behavior should be teachable and understandable by developers.\nFinally, there must be mechanisms available to detect undefined behavior, at\nbest statically, and at worst dynamically with high probability and at minimal\ncost."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Adhere to the principle of least surprise.")," Defaults should match typical\nusage patterns. Implicit features should be unsurprising and expected, while\nexplicit syntax should inform the reader about any behavior which might\notherwise be surprising. The core concepts of implicit versus explicit syntax\nare well articulated in\n",(0,o.kt)("a",{parentName:"p",href:"https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html#implicit-vs-explicit"},"the Rust community"),",\nalthough we may come to different conclusions regarding the principles."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Design features to be simple to implement.")," Syntax, structure, and language\nfeatures should be chosen while keeping the implementation complexity\nmanageable. Simplicity of implementation reduces bugs, and will in most cases\nmake the features easier to understand. It's also often the best way to ensure\npredictable performance, although supporting peak performance may require\noptions for more complex implementation behavior."),(0,o.kt)("h3",{id:"practical-safety-and-testing-mechanisms"},"Practical safety and testing mechanisms"),(0,o.kt)("p",null,"Our goal is to add as much language-level safety and security to Carbon as\npossible, using a hybrid strategy to balance other goals. We will do as many\nsafety checks as we can at compile time. We will also provide dynamic runtime\nchecking and a strong testing methodology ranging from unit tests through\nintegration and system tests all the way to coverage-directed fuzz testing. We\nhave specific criteria that are important for this strategy to be successful:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Make unsafe or risky aspects of Carbon code explicit and syntactically\nvisible.")," This will allow the software to use the precise flexibility needed\nand to minimize its exposure, while still aiding the reader. It can also help\nthe reader more by indicating the specific nature of risk faced by a given\nconstruct. More simply, safe things shouldn't look like unsafe things and unsafe\nthings should be easily recognized when reading code."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Common patterns of unsafe or risky code must support static checking."),"\nWaiting until a dynamic check is too late to prevent the most common errors. A\ncanonical example here are\n",(0,o.kt)("a",{parentName:"p",href:"https://clang.llvm.org/docs/ThreadSafetyAnalysis.html"},"thread-safety annotations"),"\nfor basic mutex lock management to allow static checking. This handles the\ncommon patterns, and we use dynamic checks, such as TSan and deadlock detection,\nto handle edge cases."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"All unsafe or risky operations and interfaces must support some dynamic\nchecking.")," Developers need some way to test and verify that their code using\nany such interface is in fact correct. Uncheckable unsafety removes any ability\nfor the developer to gain confidence. This means we need to design features with\nunsafe or risky aspects with dynamic checking in mind. A concrete example of\nthis can be seen in facilities that allow indexing into an array: such\nfacilities should be designed to have the bounds of the array available to\nimplement bounds checking when desirable."),(0,o.kt)("h3",{id:"fast-and-scalable-development"},"Fast and scalable development"),(0,o.kt)("p",null,'Software development iteration has a critical "edit, test, debug" cycle.\nDevelopers will use IDEs, editors, compilers, and other tools that need\ndifferent levels of parsing. For small projects, raw parsing speed is essential;\nfor large software systems, scalability of parsing is also necessary.'),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Syntax should parse with bounded, small look-ahead.")," Syntax that requires\nunbounded look-ahead or fully general backtracking adds significant complexity\nto parsing and makes it harder to provide high quality error messages. The\nresult is both slower iteration and more iterations, a multiplicative negative\nimpact on productivity. Humans aren't immune either; they can be confused by\nconstructs that appear to mean one thing but actually mean another. Instead, we\nshould design for syntax that is fast to parse, with easy and reliable error\nmessages."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"No semantic or contextual information used when parsing.")," The more context,\nand especially the more ",(0,o.kt)("em",{parentName:"p"},"semantic")," context, required for merely parsing code,\nthe fewer options available to improve the performance of tools and compilation.\nCross-file context has an especially damaging effect on the potential\ndistributed build graph options. Without these options, we will again be unable\nto provide fast developer iteration as the codebase scales up."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Support separate compilation, including parallel and distributed strategies."),"\nIteration requires frequent rebuilds of software as part of the edit/test/debug\ncycle of development. The language design should enable low-latency build\nstrategies, particularly when relatively little has changed. This minimally\nrequires separate compilation of source files, and potentially other incremental\nbuild strategies. Separate compilation also enables better scalability options\nfor build systems of large software."),(0,o.kt)("h3",{id:"modern-os-platforms-hardware-architectures-and-environments"},"Modern OS platforms, hardware architectures, and environments"),(0,o.kt)("p",null,"Carbon must have strong support for all of the major, modern OS platforms, the\nhardware architectures they run on, and the environments in which their software\nruns. Carbon must also continue supporting these over time, even as which ones\nare major or modern evolve and change."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Provide ",(0,o.kt)("em",{parentName:"strong"},"native")," support for the programming models of those platforms and\nenvironments.")," This goes beyond enabling compile-time translations from one\nabstraction to several implementations. While enabling high-level\nsynchronization primitives like mutexes and futures is good, the underlying\natomic operations provided by the hardware must also be directly available.\nSimilarly, lowering parallel constructs into a specific implementation, such as\nSIMD or SPMD, is good but insufficient. Multiple parallel implementations must\nbe directly addressable in Carbon. The need for native support repeats across\nthe landscape of OS platform, hardware, and environment distinctions; for\nexample, concurrency versus parallelism, and desktop versus mobile."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Conversely, Carbon cannot prioritize support for historical platforms.")," To\nuse a hockey metaphor, we should not skate to where the puck is, much less where\nthe puck was twenty years ago. We have existing systems to support those\nplatforms where necessary. Instead, Carbon should be forward-leaning in its\nplatform support. As these platforms evolve over time, Carbon will have to\nevolve as well to continue to effectively prioritize the modern and major\nplatforms."),(0,o.kt)("p",null,"For examples, please see Carbon's\n",(0,o.kt)("a",{parentName:"p",href:"/carbon-lang/project/principles/success_criteria#modern-os-platforms-hardware-architectures-and-environments"},"success criteria"),"."),(0,o.kt)("h3",{id:"interoperability-with-and-migration-from-existing-c-code"},"Interoperability with and migration from existing C++ code"),(0,o.kt)("p",null,"We want developers working within existing C++ ecosystems to easily start using\nCarbon, without starting from scratch. Adopting Carbon should not require\ncomplete rewrites, new programming models, or building an entire new\nstack/ecosystem. This means integrating into the existing C++ ecosystem by\nsupporting incremental migration from C++ to Carbon, which in turn requires\nhigh-quality interoperability with existing C++ code."),(0,o.kt)("p",null,"We must be able to move existing ",(0,o.kt)("em",{parentName:"p"},"large")," C++ codebases -- some with hundreds of\nmillions of lines of code and tens of thousands of active developers -- onto\nCarbon. C++ developers must also successfully switch to Carbon development. Any\nmigration of this scale will take years, will need to be incremental, and some\nlibraries -- particularly third-party -- may remain in C and C++. It must be\npossible to migrate a C++ library to Carbon without simultaneously migrating all\nof the libraries it depends on or all of the libraries that depend on it."),(0,o.kt)("p",null,"We believe incremental migrations require:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Familiarity for experienced C++ developers with a gentle learning curve.")," We\nneed a feasible plan for retraining a C++ workforce to become proficient in\nCarbon. If long and significant study is required to be minimally proficient,\nmeaning able to read, superficially understand, and do limited debugging or\nmodifications, then the inertia of C++ will inevitably win. Further, we need a\ngentle and easily traversed learning curve to basic productivity in order for\nthe transition to not become a chore or otherwise unsustainable for teams and\nindividuals."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Expressivity comparable to C++.")," If an algorithm or data structure or system\narchitecture can naturally be written in C++, it should also be possible to\nwrite it naturally in Carbon."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Automated source-to-source migration of large segments of large-scale\nidiomatic C++ code bases with high fidelity.")," We will prioritize having very\n",(0,o.kt)("a",{parentName:"p",href:"/carbon-lang/project/principles/success_criteria#migration-tooling"},"low human interaction")," to\nachieve high fidelity migration results. We do not require all C++ code to be\nmigratable in this fashion, and the resulting Carbon may be non-idiomatic. We\ncan add reasonable constraints here if those constraints are already well\nestablished best practices for C++ development, including design patterns,\ntesting coverage, or usage of sanitizers. Over many years, as Carbon evolves and\ncodebases have had time to migrate, the results of the tooling may also drift\nfurther from idiomatic Carbon and have less desirable results."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Support for bi-directional interoperability with existing C++ code.")," We need\nCarbon code to be able to call into C and C++ libraries with both reasonable API\nclarity and high performance. We will also need some ability to implement C++\ninterfaces with business logic in Carbon, although this direction can tolerate\nslightly more constraints both in supported features and performance overhead.\nIn all cases, the particular performance overhead imposed by moving between C++\nand Carbon will need to be easily exposed and understood by developers. While a\ngiven piece code only needs to be migrated once, we expect interoperability to\nbe invoked continuously to support migrated code and will thus remain important\nfor most developers."),(0,o.kt)("h2",{id:"non-goals"},"Non-goals"),(0,o.kt)("p",null,"There are common or expected goals of many programming languages that we\nexplicitly call out as non-goals for Carbon. That doesn't make these things bad\nin any way, but reflects the fact that they do not provide meaningful value to\nus and come with serious costs and/or risks."),(0,o.kt)("h3",{id:"stable-language-and-library-abi"},"Stable language and library ABI"),(0,o.kt)("p",null,"We would prefer to provide better, dedicated mechanisms to decompose software\nsubsystems in ways that scale over time rather than providing a stable ABI\nacross the Carbon language and libraries. Our experience is that providing broad\nABI-level stability for high-level constructs is a significant and permanent\nburden on their design. It becomes an impediment to evolution, which is one of\nour stated goals."),(0,o.kt)("p",null,"This doesn't preclude having low-level language features or tools to create\nspecific and curated stable ABIs, or even serializable protocols. Using any such\nfacilities will also cause developers to explicitly state where they are relying\non ABI and isolating it in source from code which does not need that stability.\nHowever, these facilities would only expose a restricted set of language\nfeatures to avoid coupling the high-level language to particular stabilized\ninterfaces. There is a wide range of such facilities that should be explored,\nfrom serialization-based systems like\n",(0,o.kt)("a",{parentName:"p",href:"https://developers.google.com/protocol-buffers"},"protobufs")," or\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.python.org/3/library/pickle.html"},"pickling in Python"),", to other\napproaches like\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/windows/win32/com/com-objects-and-interfaces"},"COM"),"\nor Swift's ",(0,o.kt)("a",{parentName:"p",href:"https://swift.org/blog/library-evolution/"},'"resilience"')," model. The\nspecific approach should be designed around the goals outlined above in order to\nfit the Carbon language."),(0,o.kt)("h3",{id:"backwards-or-forwards-compatibility"},"Backwards or forwards compatibility"),(0,o.kt)("p",null,"Our goals are focused on ",(0,o.kt)("em",{parentName:"p"},"migration")," from one version of Carbon to the next\nrather than ",(0,o.kt)("em",{parentName:"p"},"compatibility")," between them. This is rooted in our experience with\nevolving software over time more generally and a\n",(0,o.kt)("a",{parentName:"p",href:"https://abseil.io/blog/20171004-cppcon-plenary"},"live-at-head model"),". Any\ntransition, whether based on backward compatibility or a migration plan, will\nrequire some manual intervention despite our best efforts, due to\n",(0,o.kt)("a",{parentName:"p",href:"http://www.hyrumslaw.com"},"Hyrum's Law"),", and so we should acknowledge that\nupgrades require active migrations."),(0,o.kt)("h3",{id:"legacy-compiled-libraries-without-source-code-or-ability-to-rebuild"},"Legacy compiled libraries without source code or ability to rebuild"),(0,o.kt)("p",null,"We consider it a non-goal to support legacy code for which the source code is no\nlonger available, though we do sympathize with such use cases and would like the\ntooling mentioned above to allow easier bridging between ABIs in these cases.\nSimilarly, plugin ABIs aren\u2019t our particular concern, yet we\u2019re interested in\nseeing tooling which can help bridge between programs and plugins which use\ndifferent ABIs."),(0,o.kt)("h3",{id:"support-for-existing-compilation-and-linking-models"},"Support for existing compilation and linking models"),(0,o.kt)("p",null,"While it is essential to have interoperability with C++, we are willing to\nchange the compilation and linking model of C++ itself to enable this if\nnecessary. Compilation models and linking models should be designed to suit the\nneeds of Carbon and its use cases, tools, and environments, not what happens to\nhave been implemented thus far in compilers and linkers."),(0,o.kt)("p",null,"As a concrete example, Carbon will not support platforms that cannot update\ntheir compiler and linker alongside the language."),(0,o.kt)("h3",{id:"idiomatic-migration-of-non-modern-non-idiomatic-c-code"},"Idiomatic migration of non-modern, non-idiomatic C++ code"),(0,o.kt)("p",null,'While large-scale, tool-assisted migration of C++ code to Carbon is an explicit\ngoal, handling all C++ code with this is expressly not a goal. There is likely a\ngreat deal of C++ code that works merely by chance or has serious flaws that\nprevent us from understanding the developer\'s intent. While we may be able to\nprovide a minimally "correct" migration to very unfriendly code, mechanically\nreproducing exact C++ semantics even if bizarre, even this is not guaranteed and\nimproving on it is not a goal. Migration support will prioritize code that\nadheres to reasonable C++ best practices, such as avoiding undefined behavior,\nmaintaining good test coverage, and validating tests with sanitizers.'),(0,o.kt)("h2",{id:"prioritization-beyond-goals"},"Prioritization beyond goals"),(0,o.kt)("p",null,"The features, tools, and other efforts of Carbon should be prioritized based on\na clearly articulated rationale. This may be based on this document's\noverarching goals and priorities, or if those don't offer enough clarity, we\nwill fall back on rationale such as a required implementation order or a\ncost-benefit analysis."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Cost-benefit will drive many choices.")," We expect to measure both cost,\nincluding complexity, and benefit using the impact on the project and language\nas a whole. Benefit accumulates over time, which means providing incremental\nsolutions earlier will typically increase total benefit. It is also reasonable\nfor the rationale of a decision to factor in both effort already invested, and\neffort ready to commit to the feature. This should not overwhelm any fundamental\ncost-benefit analysis. However, given two equally impactful features, we should\nfocus on the solution that is moving the fastest."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Domain-motivated libraries and features are an example.")," For these, the cost\nfunction will typically be the effort required to specify and implement the\nfeature. Benefit will stem from the number of users and how much utility the\nfeature provides. We don't expect to have concrete numbers for these, but we\nexpect prioritization decisions between features to be expressed using this\nframework."),(0,o.kt)("h2",{id:"acknowledgements"},"Acknowledgements"),(0,o.kt)("p",null,"Carbon's goals are heavily based on\n",(0,o.kt)("a",{parentName:"p",href:"https://wg21.link/p2137"},'"Goals and priorities for C++"'),". Many thanks to the\nauthors and contributors for helping us formulate our goals and priorities."))}u.isMDXComponent=!0}}]);