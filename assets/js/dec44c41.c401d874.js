"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8949],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),m=r,d=c["".concat(o,".").concat(m)]||c[m]||h[m]||i;return n?a.createElement(d,l(l({ref:t},p),{},{components:n})):a.createElement(d,l({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=c;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var u=2;u<i;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},8065:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const i={},l="Trunk-based pull-request GitHub workflow",s={unversionedId:"pull_request_workflow",id:"pull_request_workflow",title:"Trunk-based pull-request GitHub workflow",description:"\x3c!--",source:"@site/../docs/project/pull_request_workflow.md",sourceDirName:".",slug:"/pull_request_workflow",permalink:"/project/pull_request_workflow",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/../docs/project/pull_request_workflow.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Principle: Success criteria",permalink:"/project/principles/success_criteria"},next:{title:"Roadmap",permalink:"/project/roadmap"}},o={},u=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Trunk based development",id:"trunk-based-development",level:2},{value:"Green tests",id:"green-tests",level:3},{value:"Always use pull requests (with review) rather than pushing directly",id:"always-use-pull-requests-with-review-rather-than-pushing-directly",level:2},{value:"Small, incremental changes",id:"small-incremental-changes",level:2},{value:"Stacking dependent pull requests",id:"stacking-dependent-pull-requests",level:3},{value:"Managing pull requests with multiple commits",id:"managing-pull-requests-with-multiple-commits",level:3},{value:"Linear history",id:"linear-history",level:2}],p={toc:u};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"trunk-based-pull-request-github-workflow"},"Trunk-based pull-request GitHub workflow"),(0,r.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#trunk-based-development"},"Trunk based development"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#green-tests"},"Green tests")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#always-use-pull-requests-with-review-rather-than-pushing-directly"},"Always use pull requests (with review) rather than pushing directly")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#small-incremental-changes"},"Small, incremental changes"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#stacking-dependent-pull-requests"},"Stacking dependent pull requests")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#managing-pull-requests-with-multiple-commits"},"Managing pull requests with multiple commits")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#linear-history"},"Linear history"))),(0,r.kt)("p",null,"Carbon repositories follow a few basic principles:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Development directly on the ",(0,r.kt)("inlineCode",{parentName:"li"},"trunk")," branch and\n",(0,r.kt)("a",{parentName:"li",href:"#green-tests"},"revert to green"),"."),(0,r.kt)("li",{parentName:"ul"},"Always use pull requests, rather than pushing directly."),(0,r.kt)("li",{parentName:"ul"},"Changes should be small, incremental, and review-optimized."),(0,r.kt)("li",{parentName:"ul"},"Preserve linear history by\n",(0,r.kt)("a",{parentName:"li",href:"https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-request-merges#rebase-and-merge-your-pull-request-commits"},"rebasing"),"\nor\n",(0,r.kt)("a",{parentName:"li",href:"https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-request-merges#squash-and-merge-your-pull-request-commits"},"squashing"),"\npull requests rather than using unsquashed merge commits.")),(0,r.kt)("p",null,"These principles try to optimize for several different uses or activities with\nversion control:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Continuous integration and bisection to identify failures and revert to\ngreen."),(0,r.kt)("li",{parentName:"ul"},"Code review both at the time of commit and follow-up review after commit."),(0,r.kt)("li",{parentName:"ul"},"Understanding how things evolve over time, which can manifest in different\nways:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"When were things introduced?"),(0,r.kt)("li",{parentName:"ul"},"How does the main branch and project evolve over time?"),(0,r.kt)("li",{parentName:"ul"},"How was a bug or surprising thing introduced?")))),(0,r.kt)("p",null,"Note that this document focuses on the mechanical workflow and branch\nmanagement. Details of the code review process are in their own\n",(0,r.kt)("a",{parentName:"p",href:"/project/code_review"},"document"),"."),(0,r.kt)("h2",{id:"trunk-based-development"},"Trunk based development"),(0,r.kt)("p",null,"We work in a simple\n",(0,r.kt)("a",{parentName:"p",href:"https://trunkbaseddevelopment.com/"},"trunk-based development")," model. This means\nall development activity takes place on a single common ",(0,r.kt)("inlineCode",{parentName:"p"},"trunk")," branch in the\nrepository (our default branch). We focus on\n",(0,r.kt)("a",{parentName:"p",href:"#small-incremental-changes"},"small, incremental changes"),' rather than feature\nbranches or the "scaled" variations of this workflow.'),(0,r.kt)("h3",{id:"green-tests"},"Green tests"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"trunk"),' branch should always stay "green". That means that if tests fail or\nif we discover bugs or errors, we revert to a "green" state by default, where\nthe failure or bug is no longer present. Fixing forward is fine if that will be\ncomparably fast and efficient. The goal isn\'t to dogmatically avoid fixing\nforward, but to prioritize getting back to green quickly. We hope to eventually\ntool this through automatic continuous-integration powered submit queues, but\neven those can fail and the principle remains.'),(0,r.kt)("h2",{id:"always-use-pull-requests-with-review-rather-than-pushing-directly"},"Always use pull requests (with review) rather than pushing directly"),(0,r.kt)("p",null,"We want to ensure that changes to Carbon are always reviewed, and the simplest\nway to do this is to consistently follow a pull request workflow. Even if the\nchange seems trivial, still go through a pull request -- it'll likely be trivial\nto review. Always wait for someone else to review your pull request rather than\njust merging it, even if you have permission to do so."),(0,r.kt)("p",null,"Our GitHub repositories are configured to require pull requests and review\nbefore they are merged, so this rule is enforced automatically."),(0,r.kt)("h2",{id:"small-incremental-changes"},"Small, incremental changes"),(0,r.kt)("p",null,"Developing in small, incremental changes improves code review time, continuous\nintegration, and bisection. This means we typically squash pull requests into a\nsingle commit when landing. We use two fundamental guides for deciding how to\nsplit up pull requests:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Ensure that each pull request builds and passes any tests cleanly when you\nrequest review and when it lands. This will ensure bisection and continuous\nintegration can effectively process them.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Without violating the first point, try to get each pull request to be \"just\nright\": not too big, not too small. You don't want to separate a pattern of\ntightly related changes into separate requests when they're easier to review\nas a set or batch, and you don't want to bundle unrelated changes together.\nTypically you should try to keep the pull request as small as you can without\nbreaking apart tightly coupled changes. However, listen to your code reviewer\nif they ask to split things up or combine them."))),(0,r.kt)("p",null,"While the default is to squash pull requests into a single commit, ",(0,r.kt)("em",{parentName:"p"},"during")," the\nreview you typically want to leave the development history undisturbed until the\nend so that comments on any particular increment aren't lost. We typically use\nthe GitHub squash-and-merge functionality to land things."),(0,r.kt)("h3",{id:"stacking-dependent-pull-requests"},"Stacking dependent pull requests"),(0,r.kt)("p",null,"Carbon uses pull requests in the common, distributed GitHub model where you\nfirst fork the repository, typically into your own private GitHub fork, and then\ndevelop on feature branches in that fork. When a branch is ready for review, it\nis turned into a pull request against the official repository. This flow should\nalways be where you start when contributing to Carbon, and it scales well even\nwith many independent changes in flight."),(0,r.kt)("p",null,"However, a common limitation to hit is when you want to create a ",(0,r.kt)("em",{parentName:"p"},"stack")," of\n",(0,r.kt)("em",{parentName:"p"},"dependent"),", small, and incremental changes and allow them to be reviewed in\nparallel. Each of these should be its own pull request to facilitate our desire\nfor small and incremental changes and review. Unfortunately, GitHub has very\npoor support for managing the ",(0,r.kt)("em",{parentName:"p"},"review")," of these stacked pull requests.\nSpecifically, one pull request cannot serve as the ",(0,r.kt)("em",{parentName:"p"},"base")," for another pull\nrequest, so each pull request will include all of the commits and diffs of the\npreceding pull requests in the stack."),(0,r.kt)("p",null,"We suggest a specific workflow to address this (note, commit access is\nrequired):"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Create your initial pull request from a branch of your fork, nothing special\nis needed at this step. Let's say you have a branch ",(0,r.kt)("inlineCode",{parentName:"p"},"feature-basic")," in your\nclone of your fork, and that the ",(0,r.kt)("inlineCode",{parentName:"p"},"origin")," remote is your fork."),(0,r.kt)("p",{parentName:"li"},"Push the branch to your fork:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"git checkout feature-basic\ngit push origin\n")),(0,r.kt)("p",{parentName:"li"},"And create a pull request for it using the\n",(0,r.kt)("a",{parentName:"p",href:"/docs/project/contribution_tools.md#gh-cli"},(0,r.kt)("inlineCode",{parentName:"a"},"gh"))," tool:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"gh pr create\n")),(0,r.kt)("p",{parentName:"li"},"Let's imagine this creates a pull request ",(0,r.kt)("inlineCode",{parentName:"p"},"N")," in the upstream repository.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"If")," you end up needing to create a subsequent pull request based on the\nfirst one, we need to create a ",(0,r.kt)("em",{parentName:"p"},"branch")," in the upstream repository that\ntracks the first pull request and serves as the base for the subsequent pull\nrequest. Assuming your fork ",(0,r.kt)("inlineCode",{parentName:"p"},"$USER/carbon-lang")," is remote ",(0,r.kt)("inlineCode",{parentName:"p"},"origin")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"carbon-language/carbon-lang")," is remote ",(0,r.kt)("inlineCode",{parentName:"p"},"upstream")," in your repository:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"git checkout feature-basic\ngit push upstream HEAD:pull-N-feature-basic\n")),(0,r.kt)("p",{parentName:"li"},"Everyone marked as a contributor to Carbon is allowed to push branches if\nthe name matches ",(0,r.kt)("inlineCode",{parentName:"p"},"pull-*"),", skipping pull request review processes. They can\nbe force pushed as necessary and deleted. These branch names should only be\nused for this ephemeral purpose. All other branch names are protected.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Create your stacked branch on your fork:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"git checkout -b next-feature-extension\ngit commit -a -m 'Some initial work on the next feature.'\ngit push origin\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Create the pull request using the upstream branch tracking your prior pull\nrequest as the base:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"gh pr create --base pull-N-feature-basic\n")),(0,r.kt)("p",{parentName:"li"},"This creates a baseline for the new, stacked pull request that you have\nmanually synced to your prior pull request.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Each time you update the original pull request by pushing more commits to\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"feature-basic")," branch on your ",(0,r.kt)("inlineCode",{parentName:"p"},"origin"),", you'll want to re-push to the\nupstream tracking branch as well:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"git checkout feature-basic\ngit commit -a -m 'Address some code review feedback...'\ngit push\ngit push upstream HEAD:pull-N-feature-basic\n")),(0,r.kt)("p",{parentName:"li"},"Then ",(0,r.kt)("em",{parentName:"p"},"merge")," those changes into your subsequent pull request:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"git checkout next-feature-extension\ngit merge feature-basic\ngit push\n")),(0,r.kt)("p",{parentName:"li"},"The merge will prevent disrupting the history of ",(0,r.kt)("inlineCode",{parentName:"p"},"next-feature-extension"),"\nwhere you may have code review comments on specific commits, while still\nallowing the pull request diff view to show the new delta after\nincorporating the new baseline.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Follow a similar process as in 5 above for merging updates from the main\nbranch of ",(0,r.kt)("inlineCode",{parentName:"p"},"upstream"),":"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"git checkout trunk\ngit pull --rebase upstream\n\n# Update your fork (optional).\ngit push\n\n# Merge changes from upstream into your bracnh without disrpting history.\ngit checkout feature-basic\ngit merge trunk\n# Push to the first PR on your fork.\ngit push\n# Synchronize the upstream tracking branch for the first PR.\ngit push upstream HEAD:pull-N-feature-basic\n\n# Merge changes from the the first PR (now including changes from trunk)\n# without disrupting history.\ngit checkout next-feature-extension\ngit merge feature-basic\n# And push to the second PR on your fork.\ngit push\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"When the first pull request lands in the main upstream branch, merge those\nchanges from upstream trunk into the stacked branch:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"# Pick up the first PR's changes from upstream trunk.\ngit checkout trunk\ngit pull --rebase upstream\n\n# Merge those changes into the stacked PR branch.\ngit checkout next-feature-extension\ngit merge trunk\ngit push\n")),(0,r.kt)("p",{parentName:"li"},"Then update the stacked PR's base branch to be ",(0,r.kt)("inlineCode",{parentName:"p"},"carbon-language:trunk"),'\nrather than the upstream tracking branch. To do this, go to the page for the\nPR on GitHub, click the "Edit" button to the right of the PR title, and then\nselect ',(0,r.kt)("inlineCode",{parentName:"p"},"trunk"),' from the "base" drop-down box below the PR title.'),(0,r.kt)("p",{parentName:"li"},"Once that's done, delete the upstream tracking branch:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"git push upstream --delete pull-N-feature-basic\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"When landing the second, stacked pull request, it will require actively\nrebasing or squashing due to the complex merge history used while updating."))),(0,r.kt)("p",null,"Additional notes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If you need to create a third or more stacked pull requests, simply repeat\nthe steps starting from #2 above for each pull request in the stack, but\nstarting from the prior pull request's branch.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If you want to split the two pull requests so they become independent, you\ncan explicitly edit the base branch of a pull request in the GitHub UI. The\nresult will be two pull requests with an overlapping initial sequence of\ncommits. You can then restructure each one to make sense independently."))),(0,r.kt)("h3",{id:"managing-pull-requests-with-multiple-commits"},"Managing pull requests with multiple commits"),(0,r.kt)("p",null,"Sometimes, it will make sense to ",(0,r.kt)("em",{parentName:"p"},"land")," a series of separate commits for a\nsingle pull request through rebasing. This can happen when there is important\noverarching context that should feed into the review, but the changes can be\nusefully decomposed when landing them. When following this model, each commit\nyou intend to end up on the ",(0,r.kt)("inlineCode",{parentName:"p"},"trunk")," branch needs to follow the same fundamental\nrules as the pull request above: they should each build and pass tests when\nlanded in order, and they should have well written, cohesive commit messages."),(0,r.kt)("p",null,'Prior to landing the pull request, you are expected to rebase it to produce this\nfinal commit sequence, either interactively or not. This kind of rebase rewrites\nthe history in Git, which can make it hard to track the resolution of code\nreview comments. Typically, only do this as a cleanup step when the review has\nfinished, or when it won\'t otherwise disrupt code review. It is healthy and\nexpected to add "addressing review comments" commits during the review and then\nsquashing them away before the pull request is merged.'),(0,r.kt)("h2",{id:"linear-history"},"Linear history"),(0,r.kt)("p",null,"We want the history of the ",(0,r.kt)("inlineCode",{parentName:"p"},"trunk")," branch of each repository to be as simple and\neasy to understand as possible. While Git has strong support for managing\ncomplex history and merge patterns, we find understanding and reasoning about\nthe history -- especially for humans -- to be at least somewhat simplified by\nsticking to a linear progression. As a consequence, we either squash pull\nrequests or rebase them when merging them."))}h.isMDXComponent=!0}}]);