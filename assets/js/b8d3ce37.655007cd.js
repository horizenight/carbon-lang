"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[442],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(n),u=i,d=h["".concat(l,".").concat(u)]||h[u]||m[u]||r;return n?a.createElement(d,o(o({ref:t},c),{},{components:n})):a.createElement(d,o({ref:t},c))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6559:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={},o="Generics: Goals",s={unversionedId:"generics/goals",id:"generics/goals",title:"Generics: Goals",description:"\x3c!--",source:"@site/../docs/design/generics/goals.md",sourceDirName:"generics",slug:"/generics/goals",permalink:"/carbon-lang/design/generics/goals",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/../docs/design/generics/goals.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Generics: Details",permalink:"/carbon-lang/design/generics/details"},next:{title:"Generics: Overview",permalink:"/carbon-lang/design/generics/overview"}},l={},p=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Purpose of this document",id:"purpose-of-this-document",level:2},{value:"Background",id:"background",level:2},{value:"Generic parameters",id:"generic-parameters",level:3},{value:"Interfaces",id:"interfaces",level:3},{value:"Relationship to templates",id:"relationship-to-templates",level:3},{value:"Goals",id:"goals",level:2},{value:"Use cases",id:"use-cases",level:3},{value:"Generic programming",id:"generic-programming",level:4},{value:"Upgrade path from C++ abstract interfaces",id:"upgrade-path-from-c-abstract-interfaces",level:4},{value:"Dependency injection",id:"dependency-injection",level:4},{value:"Generics instead of open overloading and ADL",id:"generics-instead-of-open-overloading-and-adl",level:4},{value:"Performance",id:"performance",level:3},{value:"Better compiler experience",id:"better-compiler-experience",level:3},{value:"Encapsulation",id:"encapsulation",level:3},{value:"Predictability",id:"predictability",level:3},{value:"Dispatch control",id:"dispatch-control",level:3},{value:"Upgrade path from templates",id:"upgrade-path-from-templates",level:3},{value:"Path from regular functions",id:"path-from-regular-functions",level:3},{value:"Coherence",id:"coherence",level:3},{value:"No novel name lookup",id:"no-novel-name-lookup",level:3},{value:"Learn from others",id:"learn-from-others",level:3},{value:"Interfaces are nominal",id:"interfaces-are-nominal",level:3},{value:"Interop and evolution",id:"interop-and-evolution",level:3},{value:"Bridge for C++ customization points",id:"bridge-for-c-customization-points",level:3},{value:"What we are not doing",id:"what-we-are-not-doing",level:2},{value:"Not the full flexibility of templates",id:"not-the-full-flexibility-of-templates",level:3},{value:"Template use cases that are out of scope",id:"template-use-cases-that-are-out-of-scope",level:3},{value:"Generics will be checked when defined",id:"generics-will-be-checked-when-defined",level:3},{value:"Specialization strategy",id:"specialization-strategy",level:3},{value:"References",id:"references",level:2}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"generics-goals"},"Generics: Goals"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#purpose-of-this-document"},"Purpose of this document")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#background"},"Background"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#generic-parameters"},"Generic parameters")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interfaces"},"Interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#relationship-to-templates"},"Relationship to templates")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#goals"},"Goals"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#use-cases"},"Use cases"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#generic-programming"},"Generic programming")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#upgrade-path-from-c-abstract-interfaces"},"Upgrade path from C++ abstract interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#dependency-injection"},"Dependency injection")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#generics-instead-of-open-overloading-and-adl"},"Generics instead of open overloading and ADL")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#performance"},"Performance")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#better-compiler-experience"},"Better compiler experience")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#encapsulation"},"Encapsulation")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#predictability"},"Predictability")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#dispatch-control"},"Dispatch control")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#upgrade-path-from-templates"},"Upgrade path from templates")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#path-from-regular-functions"},"Path from regular functions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#coherence"},"Coherence")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#no-novel-name-lookup"},"No novel name lookup")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#learn-from-others"},"Learn from others")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interfaces-are-nominal"},"Interfaces are nominal")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interop-and-evolution"},"Interop and evolution")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#bridge-for-c-customization-points"},"Bridge for C++ customization points")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#what-we-are-not-doing"},"What we are not doing"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#not-the-full-flexibility-of-templates"},"Not the full flexibility of templates")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#template-use-cases-that-are-out-of-scope"},"Template use cases that are out of scope")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#generics-will-be-checked-when-defined"},"Generics will be checked when defined")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#specialization-strategy"},"Specialization strategy")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#references"},"References"))),(0,i.kt)("h2",{id:"purpose-of-this-document"},"Purpose of this document"),(0,i.kt)("p",null,"This document attempts to clarify our goals for the design of the generics\nfeature for Carbon. While these are not strict requirements, they represent the\nyardstick by which we evaluate design decisions. We do expect to achieve most of\nthese goals, though some of these goals are somewhat aspirational or\nforward-looking."),(0,i.kt)("h2",{id:"background"},"Background"),(0,i.kt)("p",null,"Carbon will support\n",(0,i.kt)("a",{parentName:"p",href:"/carbon-lang/design/generics/terminology#generic-versus-template-parameters"},"generics")," to support generic\nprogramming by way of\n",(0,i.kt)("a",{parentName:"p",href:"/carbon-lang/design/generics/terminology#parameterized-language-constructs"},"parameterization of language constructs"),"\nwith ",(0,i.kt)("a",{parentName:"p",href:"/carbon-lang/design/generics/terminology#early-versus-late-type-checking"},"early type checking")," and\n",(0,i.kt)("a",{parentName:"p",href:"/carbon-lang/design/generics/terminology#complete-definition-checking"},"complete definition checking"),"."),(0,i.kt)("p",null,"This is in contrast with the\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Duck_typing#Templates_or_generic_types"},"compile-time duck typing"),"\napproach of C++ templates, and ",(0,i.kt)("em",{parentName:"p"},"in addition")," to\n",(0,i.kt)("a",{parentName:"p",href:"#relationship-to-templates"},"template support in Carbon"),", if we decide to\nsupport templates in Carbon beyond interoperability with C++ templates."),(0,i.kt)("h3",{id:"generic-parameters"},"Generic parameters"),(0,i.kt)("p",null,'Generic functions and generic types will all take some "generic parameters",\nwhich will frequently be types, and in some cases will be\n',(0,i.kt)("a",{parentName:"p",href:"/carbon-lang/design/generics/terminology#deduced-parameter"},"deduced")," from the types of the values of\nexplicit parameters."),(0,i.kt)("p",null,"If a generic parameter is a type, the generic function's signature can specify\nconstraints that the caller's type must satisfy. For example, a resizable array\ntype (like C++'s ",(0,i.kt)("inlineCode",{parentName:"p"},"std::vector"),") might have a generic type parameter with the\nconstraint that the type must be movable and have a static size. A sort function\nmight apply to any array whose elements are comparable and movable."),(0,i.kt)("p",null,"A constraint might involve multiple generic parameters. For example, a merge\nfunction might apply to two arbitrary containers so long as their elements have\nthe same type."),(0,i.kt)("h3",{id:"interfaces"},"Interfaces"),(0,i.kt)("p",null,'We need some way to express the constraints on a generic type parameter. In\nCarbon we express these "type constraints" by saying we restrict to types that\nimplement specific ',(0,i.kt)("a",{parentName:"p",href:"/carbon-lang/design/generics/terminology#interface"},(0,i.kt)("em",{parentName:"a"},"interfaces")),". Interfaces describe\nan API a type could implement; for example, it might specify a set of functions,\nincluding names and signatures. A type implementing an interface may be passed\nas a generic type argument to a function that has that interface as a\nrequirement of its generic type parameter. Then, the functions defined in the\ninterface may be called in the body of the function. Further, interfaces have\nnames that allow them to be reused."),(0,i.kt)("p",null,"Similar compile-time and run-time constructs may be found in other programming\nlanguages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch10-02-traits.html"},"Rust's traits")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.swift.org/swift-book/LanguageGuide/Protocols.html"},"Swift's protocols")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Interface_(Java)"},"Java interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)"},"C++ concepts"),"\n(compile-time only)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Class_(computer_programming)#Abstract_and_concrete"},"Abstract base classes"),"\nin C++, etc. (run-time only)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gobyexample.com/interfaces"},"Go interfaces")," (run-time only)")),(0,i.kt)("p",null,"In addition to specifying the methods available on a type, we may in the future\nexpand the role of interfaces to allow other type constraints, such as on size,\nprefix of the data layout, specified method implementations, tests that must\npass, etc. This might be part of making interfaces as expressive as classes, as\npart of a strategy to migrate to a future version of Carbon that uses interfaces\ninstead of, rather than in addition to, standard inheritance-and-classes\nobject-oriented language support. For the moment, everything beyond specifying\nthe ",(0,i.kt)("em",{parentName:"p"},"methods")," available is out of scope."),(0,i.kt)("h3",{id:"relationship-to-templates"},"Relationship to templates"),(0,i.kt)("p",null,"The entire idea of statically typed languages is that coding against specific\ntypes and interfaces is a better model and experience. Unfortunately, templates\ndon't provide many of those benefits to programmers until it's too late, when\nusers are consuming the API. Templates also come with high overhead, such as\n",(0,i.kt)("a",{parentName:"p",href:"#better-compiler-experience"},"template error messages"),"."),(0,i.kt)("p",null,"We want Carbon code to move towards more rigorously type checked constructs.\nHowever, existing C++ code is full of unrestricted usage of compile-time\nduck-typed templates. They are incredibly convenient to write and so likely will\ncontinue to exist for a long time."),(0,i.kt)("p",null,"The question of whether Carbon has direct support for templates is out of scope\nfor this document. The generics design is not completely separate from\ntemplates, so it is written as if Carbon will have its own templating system. It\nis assumed to be similar to C++ templates with some specific changes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It may have some limitations to be more compatible with generics, much like\nhow we\n",(0,i.kt)("a",{parentName:"li",href:"#generics-instead-of-open-overloading-and-adl"},"restrict overloading"),"."),(0,i.kt)("li",{parentName:"ul"},"We likely will have a different method of selecting between different\ntemplate instantiations, since\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error"},"SFINAE"),"\nmakes it difficult to deliver high quality compiler diagnostics.")),(0,i.kt)("p",null,"We assume Carbon will have templates for a few different reasons:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Carbon generics will definitely have to interact with ",(0,i.kt)("em",{parentName:"li"},"C++")," templates, and\nmany of the issues will be similar."),(0,i.kt)("li",{parentName:"ul"},"We want to leave room in the design for templates, since it seems like it\nwould be easier to remove templates if they are not pulling their weight\nthan figure out how to add them in if they turn out to be needed."),(0,i.kt)("li",{parentName:"ul"},"We may want to have templates in Carbon as a temporary measure, to make it\neasier for users to transition off of C++ templates.")),(0,i.kt)("h2",{id:"goals"},"Goals"),(0,i.kt)("p",null,"Our goal for generics support in Carbon is to get most of the expressive\nbenefits of C++ templates and open overloading with fewer downsides.\nAdditionally, we want to support some dynamic dispatch use cases; for example,\nin cases that inheritance struggles with."),(0,i.kt)("h3",{id:"use-cases"},"Use cases"),(0,i.kt)("p",null,"To clarify the expressive range we are aming for, here are some specific use\ncases we expect Carbon generics to cover."),(0,i.kt)("h4",{id:"generic-programming"},"Generic programming"),(0,i.kt)("p",null,"We in particular want to support\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Generic_programming"},"generic programming"),",\nincluding:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Containers: arrays, maps, lists, and more complicated data structures like\ntrees and graphs"),(0,i.kt)("li",{parentName:"ul"},"Algorithms: sort, search"),(0,i.kt)("li",{parentName:"ul"},"Wrappers: optional, variant, expected/result, smart pointers"),(0,i.kt)("li",{parentName:"ul"},"Parameterized numeric types: ",(0,i.kt)("inlineCode",{parentName:"li"},"std::complex<T>")),(0,i.kt)("li",{parentName:"ul"},"Configurable and parametric APIs: the storage-customized ",(0,i.kt)("inlineCode",{parentName:"li"},"std::chrono")," APIs"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Modern_C%2B%2B_Design#Policy-based_design"},"Policy-based design"))),(0,i.kt)("p",null,"These would generally involve static, compile-time type arguments, and so would\ngenerally be used with ",(0,i.kt)("a",{parentName:"p",href:"#dispatch-control"},"static dispatch"),"."),(0,i.kt)("h4",{id:"upgrade-path-from-c-abstract-interfaces"},"Upgrade path from C++ abstract interfaces"),(0,i.kt)("p",null,"Interfaces in C++ are often represented by abstract base classes. Generics\nshould offer an alternative that does not rely on inheritance. This means looser\ncoupling and none of the problems of multiple inheritance. Some people, such as\n",(0,i.kt)("a",{parentName:"p",href:"https://sean-parent.stlab.cc/papers-and-presentations/#better-code-runtime-polymorphism"},"Sean Parent"),",\nadvocate for runtime polymorphism patterns in C++ that avoid inheritance because\nit can cause runtime performance, correctness, and code maintenance problems in\nsome situations. Those patterns require a lot of boilerplate and complexity in\nC++. It would be nice if those patterns were simpler to express with Carbon\ngenerics. More generally, Carbon generics will provide an alternative for those\nsituations inheritance doesn't handle as well. As a specific example, we would\nlike Carbon generics to supplant the need to support multiple inheritance in\nCarbon."),(0,i.kt)("p",null,"This is a case that would use ",(0,i.kt)("a",{parentName:"p",href:"#dispatch-control"},"dynamic dispatch"),"."),(0,i.kt)("h4",{id:"dependency-injection"},"Dependency injection"),(0,i.kt)("p",null,"Types which only support subclassing for test stubs and mocks, as in\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Dependency_injection"},'"dependency injection"'),",\nshould be able to easily migrate to generics. This extends outside the realm of\ntesting, allowing general configuration of how dependencies can be satisfied.\nFor example, generics might be used to configure how a library writes logs."),(0,i.kt)("p",null,"This would allow you to avoid the runtime overhead of virtual functions, using\n",(0,i.kt)("a",{parentName:"p",href:"#dispatch-control"},"static dispatch")," without the\n",(0,i.kt)("a",{parentName:"p",href:"#better-compiler-experience"},"poor build experience of templates"),"."),(0,i.kt)("h4",{id:"generics-instead-of-open-overloading-and-adl"},"Generics instead of open overloading and ADL"),(0,i.kt)("p",null,"One name lookup problem we would like to avoid is caused by open overloading.\nOverloading is where you provide multiple implementations of a function with the\nsame name, and the implementation used in a specific context is determined by\nthe argument types. Open overloading is overloading where the overload set is\nnot restricted to a single file or library. This works with\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Argument-dependent_name_lookup"},"Argument-dependent lookup"),",\nor ",(0,i.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/adl"},"ADL"),", a mechanism for\nenabling open overloading without having to reopen the namespace where the\nfunction was originally defined. Together these enable\n",(0,i.kt)("a",{parentName:"p",href:"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html"},"C++ customization points"),"."),(0,i.kt)("p",null,"This is commonly used to provide a type-specific implementation of some\noperation, but doesn't provide any enforcement of consistency across the\ndifferent overloads. It makes the meaning of code dependent on which overloads\nare imported, and is at odds with being able to type check a function\ngenerically."),(0,i.kt)("p",null,"Our goal is to address this use case, known more generally as\n",(0,i.kt)("a",{parentName:"p",href:"https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions"},"the expression problem"),",\nwith a generics mechanism that does enforce consistency so that type checking is\npossible without seeing all implementations. This will be Carbon's replacement\nfor open overloading. As a consequence, Carbon generics will need to be able to\nsupport operator overloading."),(0,i.kt)("p",null,"A specific example is the absolute value function ",(0,i.kt)("inlineCode",{parentName:"p"},"Abs"),". We would like to write\n",(0,i.kt)("inlineCode",{parentName:"p"},"Abs(x)")," for a variety of types. For some types ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Int32")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"Float64"),", the return type will be the same ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),". For other types, such as\n",(0,i.kt)("inlineCode",{parentName:"p"},"Complex64")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Quaternion"),", the return type will be different. The generic\nfunctions that call ",(0,i.kt)("inlineCode",{parentName:"p"},"Abs")," will need a way to specify whether they only operate\non ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," such that ",(0,i.kt)("inlineCode",{parentName:"p"},"Abs")," has signature ",(0,i.kt)("inlineCode",{parentName:"p"},"T -> T"),"."),(0,i.kt)("p",null,"This does create an issue when interoperating with C++ code using open\noverloading, which will\n",(0,i.kt)("a",{parentName:"p",href:"#bridge-for-c-customization-points"},"need to be addressed"),"."),(0,i.kt)("h3",{id:"performance"},"Performance"),(0,i.kt)("p",null,"For any real-world C++ template, there shall be an idiomatic reformulation in\nCarbon generics that has equal or better performance.\n",(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals.md#performance-critical-software"},"Performance is the top priority for Carbon"),",\nand we expect to use generics pervasively, and so they can't compromise that\ngoal in release builds."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Nice to have:")," There are cases where we should aim to do better than C++\ntemplates. For example, the additional structure of generics should make it\neasier to reduce generated code duplication, reducing code size and cache\nmisses."),(0,i.kt)("h3",{id:"better-compiler-experience"},"Better compiler experience"),(0,i.kt)("p",null,"Compared to C++ templates, we expect to reduce build times, particularly in\ndevelopment builds. We also expect the compiler to be able to report clearer\nerrors, and report them earlier in the build process."),(0,i.kt)("p",null,'One source of improvement is that the bodies of generic functions and types can\nbe type checked once when they are defined, instead of every time they are used.\nThis is both a reduction in the total work done, and how errors can be reported\nearlier. On use, the errors can be a lot clearer since they will be of the form\n"argument did not satisfy function\'s contract as stated in its signature"\ninstead of "substitution failed at this line of the function\'s implementation."'),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Nice to have:")," In development builds, we will have the option of using\n",(0,i.kt)("a",{parentName:"p",href:"#dispatch-control"},"dynamic dispatch")," to reduce build times. We may also be able\nto reduce the amount of redundant compilation work even with the\n",(0,i.kt)("a",{parentName:"p",href:"#dispatch-control"},"static strategy")," by identifying instantiations with the same\narguments or identical implementations and only generating code for them once."),(0,i.kt)("h3",{id:"encapsulation"},"Encapsulation"),(0,i.kt)("p",null,"With a template, the implementation is part of the interface and types are only\nchecked when the function is called and the template is instantiated."),(0,i.kt)("p",null,"A generic function is type checked when it is defined, and type checking can't\nuse any information that is only known when the function is instantiated such as\nthe exact argument types. Furthermore, calls to a generic function may be type\nchecked using only its declaration, not its body. You should be able to call a\ngeneric function using only a forward declaration."),(0,i.kt)("h3",{id:"predictability"},"Predictability"),(0,i.kt)("p",null,"A general property of generics is they are more predictable than templates. They\nmake clear when a type satisfies the requirements of a function; they have a\ndocumented contract. Further, that contract is enforced by the compiler, not\nsensitive to implementation details in the function body. This eases evolution\nby reducing (but not eliminating) the impact of\n",(0,i.kt)("a",{parentName:"p",href:"https://www.hyrumslaw.com/"},"Hyrum's law"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Nice to have:"),' We also want well-defined boundaries between what is legal and\nnot. This is "will my code be accepted by the compiler" predictability. We would\nprefer to avoid algorithms in the compiler with the form "run for up to N steps\nand report an error if it isn\'t resolved by then." For example, C++ compilers\nwill typically have a template recursion limit. With generics, these problems\narise due to trying to reason whether something is legal in all possible\ninstantiations, rather than with specific, concrete types.'),(0,i.kt)("p",null,"Some of this is likely unavoidable or too costly to avoid, as most existing\ngenerics systems\n",(0,i.kt)("a",{parentName:"p",href:"https://3fx.ch/typing-is-hard.html"},"have undecidable aspects to their type system"),",\nincluding ",(0,i.kt)("a",{parentName:"p",href:"https://sdleffler.github.io/RustTypeSystemTuringComplete/"},"Rust")," and\n",(0,i.kt)("a",{parentName:"p",href:"https://forums.swift.org/t/swift-type-checking-is-undecidable/39024"},"Swift"),". We\nfully expect there to be metaprogramming facilities in Carbon that will be able\nto execute arbitrary Turing machines, with infinite loops and undecidable\nstopping criteria. We don't see this as a problem though, just like we don't\nworry about trying to make the compiler reliably prevent you from writing\nprograms that don't terminate."),(0,i.kt)("p",null,"We ",(0,i.kt)("em",{parentName:"p"},"would"),' like to distinguish "the executed steps are present in the program\'s\nsource" from "the compiler has to search for a proof that the code is legal." In\nthe former case, the compiler can surface a problem to the user by pointing to\nlines of code in a trace of execution. The user could employ traditional\ndebugging techniques to refine their understanding until they can determine a\nfix. What we want to avoid is the latter case, since it has bad properties:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Error messages end up in the form: "this was too complicated to figure out,\nI eventually gave up."'),(0,i.kt)("li",{parentName:"ul"},"Little in the way of actionable feedback on how to fix problems."),(0,i.kt)("li",{parentName:"ul"},"Not much the user can do to debug problems."),(0,i.kt)("li",{parentName:"ul"},"If the compiler is currently right at a limit for figuring something out, it\nis easy to imagine a change to a distant dependency can cause it to suddenly\nstop compiling.")),(0,i.kt)("p",null,"If we can't find acceptable restrictions to make problems efficiently decidable,\nthe next best solution is to require the proof to be in the source instead of\nderived by the compiler. If authoring the proof is too painful for the user, the\nwe should invest in putting the proof search into IDEs or other tooling."),(0,i.kt)("h3",{id:"dispatch-control"},"Dispatch control"),(0,i.kt)("p",null,"Enable simple user control of whether to use dynamic or static dispatch."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Implementation strategy:")," There are two strategies for generating code for\ngeneric functions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Static specialization strategy: Like template parameters, the values for\ngeneric parameters must be statically known at the callsite, or known to be\na generic parameter to the calling function. This can generate separate,\nspecialized versions of each combination of generic and template arguments,\nin order to optimize for those types or values."),(0,i.kt)("li",{parentName:"ul"},"Dynamic strategy: This is when the compiler generates a single version of\nthe function that uses runtime dispatch to get something semantically\nequivalent to separate instantiation, but likely with different size, build\ntime, and performance characteristics.")),(0,i.kt)("p",null,"By default, we expect the implementation strategy to be controlled by the\ncompiler, and not semantically visible to the user. For example, the compiler\nmight use the static strategy for release builds and the dynamic strategy for\ndevelopment. Or it might choose between them on a more granular level based on\ncode analysis, specific features used in the code, or profiling -- maybe some\nspecific specializations are needed for performance, but others would just be\ncode bloat."),(0,i.kt)("p",null,"We require that all generic functions can be compiled using the static\nspecialization strategy. For example, the values for generic parameters must be\nstatically known at the callsite. Other limitations are\n",(0,i.kt)("a",{parentName:"p",href:"#specialization-strategy"},"listed below"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Nice to have:")," It is desirable that the majority of functions with generic\nparameters also support the dynamic strategy. Specific features may prevent the\ncompiler from using the dynamic strategy, but they should ideally be relatively\nrare, and easy to identify. Language features should avoid making it observable\nwhether function code generated once or many times. For example, you should not\nbe able to take the address of a function with generic parameters, or determine\nif a function was instantiated more than once using function-local static\nvariables."),(0,i.kt)("p",null,"There are a few obstacles to supporting dynamic dispatch efficiently, which may\nlimit the extent it is used automatically by implementations. For example, the\nfollowing features would benefit substantially from guaranteed monomorphization:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Field packing in class layout. For example, packing a ",(0,i.kt)("inlineCode",{parentName:"li"},"Bool")," into the lower\nbits of a pointer, or packing bit-fields with generic widths."),(0,i.kt)("li",{parentName:"ul"},"Allocating local variables in stack storage. Without monomorphization, we\nwould need to perform dynamic memory allocation -- whether on the stack or\nthe heap -- for local variables whose sizes depend on generic parameters."),(0,i.kt)("li",{parentName:"ul"},"Passing parameters to functions. We cannot pass values of generic types in\nregisters.")),(0,i.kt)("p",null,"While it is possible to address these with dynamic dispatch, handling some of\nthem might have far-reaching and surprising performance implications. We don't\nwant to compromise our goal for predictable performance."),(0,i.kt)("p",null,"We will allow the user to explicitly opt-in to using the dynamic strategy in\nspecific cases. This could be just to control binary size in cases the user\nknows are not performance sensitive, or it could be to get the additional\ncapability of operating on values with dynamic types. We may need to restrict\nthis in various ways to maintain efficiency, like Rust does with object-safe\ntraits."),(0,i.kt)("p",null,"We also anticipate that the user may want to force the compiler to use the\nstatic strategy in specific cases. This might be to keep runtime performance\nacceptable even when running a development or debug build."),(0,i.kt)("h3",{id:"upgrade-path-from-templates"},"Upgrade path from templates"),(0,i.kt)("p",null,"We want there to be a natural, incremental upgrade path from templated code to\ngeneric code.\n",(0,i.kt)("a",{parentName:"p",href:"#relationship-to-templates"},"Assuming Carbon will support templates directly"),",\nthe first step of migrating C++ template code would be to first convert it to a\nCarbon template. The problem is then how to convert templates to generics within\nCarbon. This gives us these sub-goals:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Users should be able to convert a single template parameter to be generic at\na time. A hybrid function with both template and generic parameters has all\nthe limitations of a template function: it can't be completely definition\nchecked, it can't use the dynamic strategy, etc. Even so, there are still\nbenefits from enforcing the function's declared contract for those\nparameters that have been converted."),(0,i.kt)("li",{parentName:"ul"},"Converting from a template parameter to a generic parameter should be safe.\nIt should either work or fail to compile, never silently change semantics."),(0,i.kt)("li",{parentName:"ul"},"We should minimize the effort to convert functions and types from templated\nto generic. Ideally it should just require specifying the type constraints,\naffecting just the signature of the function, not its body."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Nice to have:")," It should be legal to call templated code from generic\ncode when it would have the same semantics as if called from non-generic\ncode, and an error otherwise. This is to allow more templated functions to\nbe converted to generics, instead of requiring them to be converted\nspecifically in bottom-up order."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Nice to have:")," Provide a way to migrate from a template to a generic\nwithout immediately updating all of the types used with the template. For\nexample, if the generic code requires types to implement a new interface,\none possible solution would use the original template code to provide an\nimplementation for that interface for any type that structurally has the\nmethods used by the original template.")),(0,i.kt)("p",null,"If Carbon does not end up having direct support for templates, the transition\nwill necessarily be less incremental."),(0,i.kt)("h3",{id:"path-from-regular-functions"},"Path from regular functions"),(0,i.kt)("p",null,"Replacing a regular, non-parameterized function with a generic function should\nnot affect existing callers of the function. There may be some differences, such\nas when taking the address of the function, but ordinary calls should not see\nany difference. In particular, the return type of a generic function should\nmatch, without any type erasure or additional named members."),(0,i.kt)("h3",{id:"coherence"},"Coherence"),(0,i.kt)("p",null,"We want the generics system to have the\n",(0,i.kt)("a",{parentName:"p",href:"/carbon-lang/design/generics/terminology#coherence"},(0,i.kt)("em",{parentName:"a"},"coherence")," property"),", so that the implementation of\nan interface for a type is well defined. Since a generic function only depends\non interface implementations, they will always behave consistently on a given\ntype, independent of context. For more on this, see\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Ixrec/rust-orphan-rules#what-is-coherence"},"this description of what coherence is and why Rust enforces it"),"."),(0,i.kt)("p",null,"Coherence greatly simplifies the language design, since it reduces the need for\ncomplicated rules to picking an implementation when there are many candidates.\nIt also has a number of benefits for users:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It removes a way packages can conflict with each other."),(0,i.kt)("li",{parentName:"ul"},"It makes the behavior of code more consistent and predictable."),(0,i.kt)("li",{parentName:"ul"},"It means there is no need to provide a disambiguation mechanism.\nDisambiguation is particularly problematic since the ambiguous call is often\nin generic code rather than code you control."),(0,i.kt)("li",{parentName:"ul"},"A consistent definition of a type is useful for instantiating a C++ or\nCarbon template on that type.")),(0,i.kt)("p",null,"The main downside of coherence is that there are some capabilities we would like\nfor interfaces that are in tension with having an orphan rule limiting where\nimplementations may be defined. For example, we would like to address\n",(0,i.kt)("a",{parentName:"p",href:"https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions#another-clojure-solution-using-protocols"},"the expression problem"),".\nWe can get some of the way there by allowing the implementation of an interface\nfor a type to be defined with either the interface or the type. But some use\ncases remain:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"They should be some way of selecting between multiple implementations of an\ninterface for a given type. For example, a ",(0,i.kt)("em",{parentName:"li"},"Song")," might support multiple\norderings, such as by title or by artist. These would be represented by\nhaving multiple implementations of a ",(0,i.kt)("em",{parentName:"li"},"Comparable")," interface."),(0,i.kt)("li",{parentName:"ul"},"In order to allow libraries to be composed, there must be some way of saying\na type implements an interface that is in another package that the authors\nof the type were unaware of. This is especially important since the library\na type is defined in may not be able to see the interface definition without\ncreating a dependency cycle or layering violation.")),(0,i.kt)("p",null,"We should have some mechanism for addressing these use cases. There are multiple\napproaches that could work:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Interface implementations could be external to types and are passed in to\ngeneric functions separately."),(0,i.kt)("li",{parentName:"ul"},"There could be some way to create multiple types that are compatible with a\ngiven value that you can switch between using casts to select different\ninterface implementations. This is the approach used by Rust\n(",(0,i.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types"},"1"),",\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/Ixrec/rust-orphan-rules#user-content-why-are-the-orphan-rules-controversial"},"2"),").")),(0,i.kt)("p",null,"Alternatives to coherence are discussed in ",(0,i.kt)("a",{parentName:"p",href:"/carbon-lang/design/generics/appendix-coherence"},"an appendix"),"."),(0,i.kt)("h3",{id:"no-novel-name-lookup"},"No novel name lookup"),(0,i.kt)("p",null,"We want to avoid adding rules for name lookup that are specific to generics.\nThis is in contrast to Rust which has different lookup rules inside its traits.\nInstead, we should structure generics in a way that reuses existing name lookup\nfacilities of the language."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Nice to have:")," One application of this that would be nice to have is if the\nnames of a type's members were all determined by a type's definition. So if ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),"\nhas type ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", then if you write ",(0,i.kt)("inlineCode",{parentName:"p"},"x.y")," you should be able to look up ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," in the\ndefinition of ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),". This might need to be somewhat indirect in some cases. For\nexample, if ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," inherits from ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),", the name ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," might come from ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," and not be\nmentioned in the definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," directly. We may have similar mechanisms\nwhere ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," gets methods that have default implementations in interfaces it\nimplements, as long as the names of those interfaces are explicitly mentioned in\nthe definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,i.kt)("h3",{id:"learn-from-others"},"Learn from others"),(0,i.kt)("p",null,"Many languages have implemented generics systems, and we should learn from those\nexperiences. We should copy what works and makes sense in the context of Carbon,\nand change decisions that led to undesirable compromises. We are taking the\nstrongest guidance from Rust and Swift, which have similar goals and significant\nexperience with the implementation and usability of generics. They both use\nnominal interfaces, were designed with generics from the start, and produce\nnative code. Contrast with Go which uses structural interfaces, or Java which\ntargets a virtual machine that predated its generics feature."),(0,i.kt)("p",null,"For example, Rust has found that supporting defaults for interface methods is a\nvaluable feature. It is useful for ",(0,i.kt)("a",{parentName:"p",href:"#interop-and-evolution"},"evolution"),",\nimplementation reuse, and for bridging the gap between the minimal functionality\na type wants to implement and the rich API that users want to consume\n(",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/iter/trait.Iterator.html"},"example"),")."),(0,i.kt)("p",null,"We still have the flexibility to make simplifications that Rust cannot because\nthey need to maintain compatibility. We could remove the concept of\n",(0,i.kt)("inlineCode",{parentName:"p"},"fundamental")," and explicit control over which methods may be specialized. These\nare complicated and\n",(0,i.kt)("a",{parentName:"p",href:"http://aturon.github.io/tech/2017/02/06/specialization-and-coherence/"},"impose coherence restrictions"),"."),(0,i.kt)("h3",{id:"interfaces-are-nominal"},"Interfaces are nominal"),(0,i.kt)("p",null,"Interfaces can either be ",(0,i.kt)("a",{parentName:"p",href:"/carbon-lang/design/generics/terminology#structural-interfaces"},"structural"),", as\nin Go, or ",(0,i.kt)("a",{parentName:"p",href:"/carbon-lang/design/generics/terminology#nominal-interfaces"},"nominal"),", as in Rust and Swift.\nStructural interfaces match any type that has the required methods, whereas\nnominal interfaces only match if there is an explicit declaration stating that\nthe interface is implemented for that specific type. Carbon will support nominal\ninterfaces, allowing them to designate ",(0,i.kt)("em",{parentName:"p"},"semantics")," beyond the basic structure of\nthe methods."),(0,i.kt)("p",null,"This means that interfaces implicitly specify the intended semantics and\ninvariants of and between those functions. Unlike the function signatures, this\ncontract is between the implementers and the consumers of interfaces and is not\nenforced by Carbon itself. For example, a ",(0,i.kt)("inlineCode",{parentName:"p"},"Draw")," method would mean different\nthings when it is part of a ",(0,i.kt)("inlineCode",{parentName:"p"},"GameResult")," interface versus an ",(0,i.kt)("inlineCode",{parentName:"p"},"Image2D"),"\ninterface, even if those methods happen to have the same signature."),(0,i.kt)("h3",{id:"interop-and-evolution"},"Interop and evolution"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals.md#software-and-language-evolution"},"Evolution is a high priority for Carbon"),",\nand so will need mechanisms to support evolution when using generics. New\nadditions to an interface might:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"need default implementations"),(0,i.kt)("li",{parentName:"ul"},'be marked "upcoming" to allow for a period of transition'),(0,i.kt)("li",{parentName:"ul"},'replace other APIs that need to be marked "deprecated"')),(0,i.kt)("p",null,"Experience with C++ concepts has shown that interfaces are\n",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=v_yzLe-wnfk"},"hard to evolve")," without these\nkinds of supporting language mechanisms. Otherwise changes to interfaces need to\nmade simultaneously with updates to types that implement the interface or\nfunctions that consume it."),(0,i.kt)("p",null,"Another way of supporting evolution is to allow one interface to be\nsubstitutable for another. For example, a feature that lets you use an\nimplementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Interface1")," for a type to automatically get an implementation\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"Interface2"),", as well as the other way around, would help transitioning\nbetween those two interfaces."),(0,i.kt)("p",null,"Evolution in particular means that the set of names in an interface can change,\nand so two interfaces that don't start with name conflicts can develop them."),(0,i.kt)("p",null,"To handle name conflicts, interfaces should be separate, isolated namespaces. We\nshould provide mechanisms to allow one type to implement two interfaces that\naccidentally use the same name for different things, and for functions to use\ninterfaces with name conflicts together on a single type. Contrast this with\nSwift, where a type can only supply one associated type of a given name even\nwhen implementing multiple protocols. Similarly a function in Swift with a given\nname and signature can only have a single implementation for a type."),(0,i.kt)("p",null,"Note this is possible since ",(0,i.kt)("a",{parentName:"p",href:"#interfaces-are-nominal"},"interfaces are nominal"),".\nThe place where types specify that they implement an interface is also the\nvehicle for unambiguously designating which function implementation goes with\nwhat interface."),(0,i.kt)("h3",{id:"bridge-for-c-customization-points"},"Bridge for C++ customization points"),(0,i.kt)("p",null,"There will need to be some bridge for C++ extension points that currently rely\non open overloading or\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Argument-dependent_name_lookup"},"ADL"),". For\nexample, we need some way for C++\n",(0,i.kt)("a",{parentName:"p",href:"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html"},"customization points"),"\nlike ",(0,i.kt)("inlineCode",{parentName:"p"},"swap")," to work on Carbon types. We might define ",(0,i.kt)("inlineCode",{parentName:"p"},"CPlusPlus.ADL.swap")," as a\nCarbon interface to be that bridge. Carbon types could implement that interface\nto work from C++, and Carbon functions could use that interface to invoke ",(0,i.kt)("inlineCode",{parentName:"p"},"swap"),"\non C++ types."),(0,i.kt)("p",null,"Similarly, we will want some way to implement Carbon interfaces for C++ types.\nFor example, we might have a template implementation of an ",(0,i.kt)("inlineCode",{parentName:"p"},"Addable")," interface\nfor any C++ type that implements ",(0,i.kt)("inlineCode",{parentName:"p"},"operator+"),"."),(0,i.kt)("h2",{id:"what-we-are-not-doing"},"What we are not doing"),(0,i.kt)("p",null,"What are we ",(0,i.kt)("strong",{parentName:"p"},"not")," doing with generics, particularly things that some other\nlanguages do?"),(0,i.kt)("h3",{id:"not-the-full-flexibility-of-templates"},"Not the full flexibility of templates"),(0,i.kt)("p",null,"Generics don't need to provide full flexibility of C++ templates:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The current assumption is that\n",(0,i.kt)("a",{parentName:"li",href:"#relationship-to-templates"},"Carbon templates")," will cover those cases that\ndon't fit inside generics, such as code that relies on compile-time duck\ntyping."),(0,i.kt)("li",{parentName:"ul"},"We won't allow a specialization of some generic interface for some\nparticular type to actually expose a ",(0,i.kt)("em",{parentName:"li"},"different")," interface, with different\nmethods or different types in method signatures. This would break modular\ntype checking."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Template_metaprogramming"},"Template metaprogramming"),"\nwill not be supported by Carbon generics. We expect to address those use\ncases with metaprogramming or templates in Carbon.")),(0,i.kt)("h3",{id:"template-use-cases-that-are-out-of-scope"},"Template use cases that are out of scope"),(0,i.kt)("p",null,"We will also not require Carbon generics to support\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Expression_templates"},"expression templates"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Variadic_function"},"variadics"),", or\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Variadic_template"},"variadic templates"),". Those are\nall out of scope. It would be fine for our generics system to support these\nfeatures, but they won't drive any accommodation in the generics design, at\nleast until we have some resolution about templates in Carbon."),(0,i.kt)("h3",{id:"generics-will-be-checked-when-defined"},"Generics will be checked when defined"),(0,i.kt)("p",null,"C++ compilers must defer full type checking of templates until they are\ninstantiated by the user. Carbon will not defer type checking of generic\ndefinitions."),(0,i.kt)("h3",{id:"specialization-strategy"},"Specialization strategy"),(0,i.kt)("p",null,"We want all generic Carbon code to support ",(0,i.kt)("a",{parentName:"p",href:"#dispatch-control"},"static dispatch"),".\nThis means we won't support unbounded type families. Unbounded type families are\nwhen recursion creates an infinite collection of types, such as in\n",(0,i.kt)("a",{parentName:"p",href:"https://forums.swift.org/t/ergonomics-generic-types-conforming-in-more-than-one-way/34589/71"},"this example from Swift"),"\nor:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},"fn Sort[T:! Comparable](list: List(T)) -> List(T) {\n  if (list.size() == 1) return list;\n  var chunks: List(List(T)) = FormChunks(list, sqrt(list.size()));\n  chunks = chunks.ApplyToEach(Sort);\n  chunks = Sort(chunks);\n  return MergeSortedListOfSortedLists(chunks);\n}\n")),(0,i.kt)("p",null,"This, given an implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable")," for any list with elements that\nare themselves ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable"),", would recursively call itself to produce a set of\ntypes without bound. That is, calling ",(0,i.kt)("inlineCode",{parentName:"p"},"Sort")," on a ",(0,i.kt)("inlineCode",{parentName:"p"},"List(Int)")," would internally\ncall ",(0,i.kt)("inlineCode",{parentName:"p"},"Sort")," on a ",(0,i.kt)("inlineCode",{parentName:"p"},"List(List(Int))")," and so on recursively without any static\nlimit."),(0,i.kt)("p",null,"We won't require all generic Carbon code to support dynamic dispatch, but we\nwould like it to be an implementation option for the compiler in the majority of\ncases."),(0,i.kt)("p",null,"Lastly, runtime specialization is out of scope as an implementation strategy.\nThat is, some language runtimes JIT a specialization when it is first needed,\nbut it is not a goal for Carbon to support such an implementation strategy."),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/24"},"#24: Generics goals")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/950"},"#950: Generic details 6: remove facets"))))}m.isMDXComponent=!0}}]);