"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8674],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(a),u=r,h=d["".concat(o,".").concat(u)]||d[u]||m[u]||i;return a?n.createElement(h,l(l({ref:t},c),{},{components:a})):n.createElement(h,l({ref:t},c))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var p=2;p<i;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},6877:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const i={},l="Templates",s={unversionedId:"templates",id:"templates",title:"Templates",description:"\x3c!--",source:"@site/../docs/design/templates.md",sourceDirName:".",slug:"/templates",permalink:"/carbon-lang/design/templates",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/../docs/design/templates.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Primitive types",permalink:"/carbon-lang/design/primitive_types"},next:{title:"Tuples",permalink:"/carbon-lang/design/tuples"}},o={},p=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"TODO",id:"todo",level:2},{value:"Overview",id:"overview",level:2},{value:"Types with template parameters",id:"types-with-template-parameters",level:3},{value:"Functions with template parameters",id:"functions-with-template-parameters",level:3},{value:"Overloading",id:"overloading",level:3},{value:"Constraining templates with interfaces",id:"constraining-templates-with-interfaces",level:3}],c={toc:p};function m(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"templates"},"Templates"),(0,r.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#todo"},"TODO")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#overview"},"Overview"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#types-with-template-parameters"},"Types with template parameters")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#functions-with-template-parameters"},"Functions with template parameters")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#overloading"},"Overloading")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#constraining-templates-with-interfaces"},"Constraining templates with interfaces"))))),(0,r.kt)("h2",{id:"todo"},"TODO"),(0,r.kt)("p",null,"This is a skeletal design, added to support ",(0,r.kt)("a",{parentName:"p",href:"/carbon-lang/design/"},"the overview"),". It should\nnot be treated as accepted by the core team; rather, it is a placeholder until\nwe have more time to examine this detail. Please feel welcome to rewrite and\nupdate as appropriate."),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Carbon templates follow the same fundamental paradigm as C++ templates: they are\ninstantiated, resulting in late type checking, duck typing, and lazy binding.\nThey both enable interoperability between Carbon and C++ and address some\n(hopefully limited) use cases where the type checking rigor imposed by generics\nisn't helpful."),(0,r.kt)("h3",{id:"types-with-template-parameters"},"Types with template parameters"),(0,r.kt)("p",null,"When parameterizing a user-defined type, the parameters can be marked as\ntemplate parameters. The resulting type-function will instantiate the\nparameterized definition with the provided arguments to produce a complete type\nwhen used. Note that only the parameters marked as having this template behavior\nare subject to full instantiation -- other parameters will be type checked and\nbound early to the extent possible. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class Stack(template T:! Type) {\n  var storage: Array(T);\n\n  fn Push[addr me: Self*](value: T);\n  fn Pop[addr me: Self*]() -> T;\n}\n")),(0,r.kt)("p",null,"This both defines a parameterized type (",(0,r.kt)("inlineCode",{parentName:"p"},"Stack"),") and uses one (",(0,r.kt)("inlineCode",{parentName:"p"},"Array"),"). Within\nthe definition of the type, the template type parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," can be used in all\nof the places a normal type would be used, and it will only by type checked on\ninstantiation."),(0,r.kt)("h3",{id:"functions-with-template-parameters"},"Functions with template parameters"),(0,r.kt)("p",null,"Both deduced and explicit function parameters in Carbon can be marked as\ntemplate parameters. When called, the arguments to these parameters trigger\ninstantiation of the function definition, fully type checking and resolving that\ndefinition after substituting in the provided (or computed if deduced)\narguments. The runtime call then passes the remaining arguments to the resulting\ncomplete definition."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fn Convert[template T:! Type](source: T, template U:! Type) -> U {\n  var converted: U = source;\n  return converted;\n}\n\nfn Foo(i: i32) -> f32 {\n  // Instantiates with the `T` deduced argument set to `i32` and the `U`\n  // explicit argument set to `f32`, then calls with the runtime value `i`.\n  return Convert(i, f32);\n}\n")),(0,r.kt)("p",null,"Here we deduce one type parameter and explicitly pass another. It is not\npossible to explicitly pass a deduced type parameter, instead the call site\nshould cast or convert the argument to control the deduction. The explicit type\nis passed after a runtime parameter. While this makes that type unavailable to\nthe declaration of ",(0,r.kt)("em",{parentName:"p"},"that")," runtime parameter, it still is a template parameter\nand available to use as a type even within the remaining parts of the function\ndeclaration."),(0,r.kt)("h3",{id:"overloading"},"Overloading"),(0,r.kt)("p",null,'An important feature of templates in C++ is the ability to customize how they\nend up specialized for specific types. Because template parameters (whether as\ntype parameters or function parameters) are pattern matched, we expect to\nleverage pattern matching techniques to provide "better match" definitions that\nare selected analogously to specializations in C++ templates. When expressed\nthrough pattern matching, this may enable things beyond just template parameter\nspecialization, but that is an area that we want to explore cautiously.'),(0,r.kt)("h3",{id:"constraining-templates-with-interfaces"},"Constraining templates with interfaces"),(0,r.kt)("p",null,"Because we consider only specific ",(0,r.kt)("em",{parentName:"p"},"parameters")," to be templated and they could be\nindividually migrated to a constrained interface using the\n",(0,r.kt)("a",{parentName:"p",href:"/carbon-lang/design/#generics"},"generics system"),", constraining templates themselves may be\nless critical. Instead, we expect parameterized types and functions may use a\nmixture of generic parameters and templated parameters based on where they are\nconstrained."),(0,r.kt)("p",null,"However, if there are still use cases, we would like to explore applying the\ninterface constraints of the generics system directly to template parameters\nrather than create a new constraint system."))}m.isMDXComponent=!0}}]);