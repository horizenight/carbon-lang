"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3423],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),u=i,h=m["".concat(o,".").concat(u)]||m[u]||d[u]||r;return n?a.createElement(h,l(l({ref:t},c),{},{components:n})):a.createElement(h,l({ref:t},c))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1844:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={},l="String literals",s={unversionedId:"lexical_conventions/string_literals",id:"lexical_conventions/string_literals",title:"String literals",description:"\x3c!--",source:"@site/../docs/design/lexical_conventions/string_literals.md",sourceDirName:"lexical_conventions",slug:"/lexical_conventions/string_literals",permalink:"/design/lexical_conventions/string_literals",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/../docs/design/lexical_conventions/string_literals.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Numeric literals",permalink:"/design/lexical_conventions/numeric_literals"},next:{title:"Whitespace",permalink:"/design/lexical_conventions/whitespace"}},o={},p=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Details",id:"details",level:2},{value:"Simple and block string literals",id:"simple-and-block-string-literals",level:3},{value:"Escape sequences",id:"escape-sequences",level:4},{value:"Raw string literals",id:"raw-string-literals",level:3},{value:"Encoding",id:"encoding",level:3},{value:"Alternatives considered",id:"alternatives-considered",level:2},{value:"References",id:"references",level:2}],c={toc:p};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"string-literals"},"String literals"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#overview"},"Overview")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#details"},"Details"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#simple-and-block-string-literals"},"Simple and block string literals"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#escape-sequences"},"Escape sequences")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#raw-string-literals"},"Raw string literals")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#encoding"},"Encoding")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#alternatives-considered"},"Alternatives considered")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#references"},"References"))),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Carbon supports both simple literals that are single-line using one double\nquotation mark (",(0,i.kt)("inlineCode",{parentName:"p"},'"'),") and block literals that are multi-line using three double\nquotation marks (",(0,i.kt)("inlineCode",{parentName:"p"},'"""'),"). A block string literal may have a file type indicator\nafter the first ",(0,i.kt)("inlineCode",{parentName:"p"},'"""'),"; this does not affect the string itself, but may assist\nother tooling. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'// Simple string literal:\nvar simple: String = "example";\n\n// Block string literal:\nvar block: String = """\n    The winds grow high; so do your stomachs, lords.\n    How irksome is this music to my heart!\n    When such strings jar, what hope of harmony?\n    I pray, my lords, let me compound this strife.\n        -- History of Henry VI, Part II, Act II, Scene 1, W. Shakespeare\n    """;\n\n// Block string literal with file type indicator:\nvar code_block: String = """cpp\n    #include <iostream>\n    int main() {\n        std::cout << "Hello world!";\n        return 0;\n    }\n    """\n')),(0,i.kt)("p",null,"The indentation of a block string literal's terminating line is removed from all\npreceding lines. As a consequence, in the above ",(0,i.kt)("inlineCode",{parentName:"p"},"code_block")," example, only\n",(0,i.kt)("inlineCode",{parentName:"p"},"std::cout")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," are indented in the resulting string, and by 4 spaces\neach."),(0,i.kt)("p",null,"Escape sequences introduced by a backslash (",(0,i.kt)("inlineCode",{parentName:"p"},"\\"),") and are used to express special\ncharacter or code unit sequences, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"\\n")," for a newline character. Raw\nstring literals are additionally delimited with one or more ",(0,i.kt)("inlineCode",{parentName:"p"},"#"),"; these require\nan equal number of hash symbols (",(0,i.kt)("inlineCode",{parentName:"p"},"#"),") after the ",(0,i.kt)("inlineCode",{parentName:"p"},"\\")," to indicate an escape\nsequence. Raw string literals are used to more easily write literal ",(0,i.kt)("inlineCode",{parentName:"p"},"\\"),"s in\nstrings. Both simple and block string literals have raw forms. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'// Raw simple string literal with newline escape sequence:\nvar newline: String = "line one\\nline two";\n\n// Raw simple string literal with literal `\\n`, not a newline:\nvar raw: String = #"line one\\nstill line one"#;\n\n// Raw simple string literal with newline escape sequence:\nvar raw_newline: String = #"line one\\#nline two"#;\n')),(0,i.kt)("h2",{id:"details"},"Details"),(0,i.kt)("h3",{id:"simple-and-block-string-literals"},"Simple and block string literals"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"simple string literal")," is formed of a sequence of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Characters other than ",(0,i.kt)("inlineCode",{parentName:"li"},"\\")," and ",(0,i.kt)("inlineCode",{parentName:"li"},'"'),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Only space characters (U+0020) are valid whitespace in a string literal."),(0,i.kt)("li",{parentName:"ul"},"Other ",(0,i.kt)("a",{parentName:"li",href:"/design/lexical_conventions/whitespace"},"horizontal whitespace"),", including tabs, are\ndisallowed but parse as part of the string for error recovery purposes."),(0,i.kt)("li",{parentName:"ul"},"Vertical whitespace will not parse as part of a simple string literal."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#escape-sequences"},"Escape sequences"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Each escape sequence is replaced with the corresponding character\nsequence or code unit sequence."),(0,i.kt)("li",{parentName:"ul"},"Similarly to invalid whitespace, invalid escape sequences such as ",(0,i.kt)("inlineCode",{parentName:"li"},"\\z"),"\nparse as part of the string.")))),(0,i.kt)("p",null,"This sequence is enclosed in ",(0,i.kt)("inlineCode",{parentName:"p"},'"'),"s. For example, this is a simple string literal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'var String: lucius = "The strings, my lord, are false.";\n')),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"block string literal")," starts with ",(0,i.kt)("inlineCode",{parentName:"p"},'"""'),", followed by an optional file type\nindicator, followed by a newline, and ends at the next instance of three double\nquotation marks whose first ",(0,i.kt)("inlineCode",{parentName:"p"},'"')," is not part of a ",(0,i.kt)("inlineCode",{parentName:"p"},'\\"')," escape sequence. The\nclosing ",(0,i.kt)("inlineCode",{parentName:"p"},'"""')," shall be the first non-whitespace characters on that line. The\nlines between the opening line and the closing line (exclusive) are ",(0,i.kt)("em",{parentName:"p"},"content\nlines"),". The content lines shall not contain ",(0,i.kt)("inlineCode",{parentName:"p"},"\\")," characters that do not form part\nof an escape sequence."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"indentation")," of a block string literal is the sequence of horizontal\nwhitespace preceding the closing ",(0,i.kt)("inlineCode",{parentName:"p"},'"""'),". Each non-empty content line shall begin\nwith the indentation of the string literal. The content of the literal is formed\nas follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The indentation of the closing line is removed from each non-empty content\nline."),(0,i.kt)("li",{parentName:"ul"},"All trailing whitespace on each line, including the line terminator, is\nreplaced with a single line feed (U+000A) character."),(0,i.kt)("li",{parentName:"ul"},"The resulting lines are concatenated."),(0,i.kt)("li",{parentName:"ul"},"Each ",(0,i.kt)("a",{parentName:"li",href:"#escape-sequences"},"escape sequence")," is replaced with the corresponding\ncharacter sequence or code unit sequence.")),(0,i.kt)("p",null,"A content line is considered empty if it contains only whitespace characters."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'var String: w = """\n  This is a string literal. Its first character is \'T\' and its last character is\n  a newline character. It contains another newline between \'is\' and \'a\'.\n  """;\n\n// This string literal is invalid because the """ after \'closing\' terminates\n// the literal, but is not at the start of the line.\nvar String: invalid = """\n  error: closing """ is not on its own line.\n  """;\n')),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"file type indicator")," is any sequence of non-whitespace characters other than\n",(0,i.kt)("inlineCode",{parentName:"p"},'"')," or ",(0,i.kt)("inlineCode",{parentName:"p"},"#"),". The file type indicator has no semantic meaning to the Carbon\ncompiler, but some file type indicators are understood by the language tooling\n(for example, syntax highlighter, code formatter) as indicating the structure of\nthe string literal's content."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'// This is a block string literal. Its first two characters are spaces, and its\n// last character is a line feed. It has a file type of \'c++\'.\nvar String: starts_with_whitespace = """c++\n    int x = 1; // This line starts with two spaces.\n    int y = 2; // This line starts with two spaces.\n  """;\n')),(0,i.kt)("p",null,"The file type indicator might contain semantic information beyond the file type\nitself, such as instructions to the code formatter to disable formatting for the\ncode block."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," There is no concrete set of recognized file type indicators.\nIt would be useful to informally specify a set of well-known indicators, so that\ntools have a common understanding of what those indicators mean, perhaps in a\nbest practices guide."),(0,i.kt)("h4",{id:"escape-sequences"},"Escape sequences"),(0,i.kt)("p",null,"Within a string literal, the following escape sequences are recognized:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Escape"),(0,i.kt)("th",{parentName:"tr",align:null},"Meaning"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\t")),(0,i.kt)("td",{parentName:"tr",align:null},"U+0009 CHARACTER TABULATION")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\n")),(0,i.kt)("td",{parentName:"tr",align:null},"U+000A LINE FEED")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\r")),(0,i.kt)("td",{parentName:"tr",align:null},"U+000D CARRIAGE RETURN")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'\\"')),(0,i.kt)("td",{parentName:"tr",align:null},"U+0022 QUOTATION MARK (",(0,i.kt)("inlineCode",{parentName:"td"},'"'),")")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\'")),(0,i.kt)("td",{parentName:"tr",align:null},"U+0027 APOSTROPHE (",(0,i.kt)("inlineCode",{parentName:"td"},"'"),")")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\\\")),(0,i.kt)("td",{parentName:"tr",align:null},"U+005C REVERSE SOLIDUS (",(0,i.kt)("inlineCode",{parentName:"td"},"\\"),")")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\0")),(0,i.kt)("td",{parentName:"tr",align:null},"Code unit with value 0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\0D")),(0,i.kt)("td",{parentName:"tr",align:null},"Invalid, reserved for evolution")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\xHH")),(0,i.kt)("td",{parentName:"tr",align:null},"Code unit with value HH",(0,i.kt)("sub",null,"16"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\u{HHHH...}")),(0,i.kt)("td",{parentName:"tr",align:null},"Unicode code point U+HHHH...")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\<newline>")),(0,i.kt)("td",{parentName:"tr",align:null},"No string literal content produced (block literals only)")))),(0,i.kt)("p",null,"Hex characters (",(0,i.kt)("inlineCode",{parentName:"p"},"H"),") must be uppercase (",(0,i.kt)("inlineCode",{parentName:"p"},"\\xAA"),", not ",(0,i.kt)("inlineCode",{parentName:"p"},"\\xaa"),")."),(0,i.kt)("p",null,"This includes all C++ escape sequences except:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"\\?"),", which was historically used to escape trigraphs in string literals,\nand no longer serves any purpose."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"\\ooo")," octal escapes, which are removed because Carbon does not support\noctal literals; ",(0,i.kt)("inlineCode",{parentName:"li"},"\\0")," is retained as a special case, which is expected to be\nimportant for C interoperability."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"\\uABCD"),", which is replaced by ",(0,i.kt)("inlineCode",{parentName:"li"},"\\u{ABCD}"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"\\U0010FFFF"),", which is replaced by ",(0,i.kt)("inlineCode",{parentName:"li"},"\\u{10FFFF}"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"\\a")," (bell), ",(0,i.kt)("inlineCode",{parentName:"li"},"\\b")," (backspace), ",(0,i.kt)("inlineCode",{parentName:"li"},"\\v")," (vertical tab), and ",(0,i.kt)("inlineCode",{parentName:"li"},"\\f")," (form feed).\n",(0,i.kt)("inlineCode",{parentName:"li"},"\\a")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"\\b")," are obsolescent, and ",(0,i.kt)("inlineCode",{parentName:"li"},"\\f")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"\\v")," are largely obsolete. These\ncharacters can be expressed with ",(0,i.kt)("inlineCode",{parentName:"li"},"\\x07"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"\\x08"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"\\x0B"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"\\x0C"),"\nrespectively if needed.")),(0,i.kt)("p",null,"Note that this is the same set of escape sequences supported by\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID295"},"Swift"),"\nand ",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/tokens.html"},"Rust"),", except that, unlike\nin Swift, support for ",(0,i.kt)("inlineCode",{parentName:"p"},"\\xHH")," is provided."),(0,i.kt)("p",null,"While octal escape sequences are expected to remain not permitted (even though\n",(0,i.kt)("inlineCode",{parentName:"p"},"\\0D")," is reserved), the decision to not support ",(0,i.kt)("inlineCode",{parentName:"p"},"\\1"),"..",(0,i.kt)("inlineCode",{parentName:"p"},"\\7")," or more generally\n",(0,i.kt)("inlineCode",{parentName:"p"},"\\DDDD")," is ",(0,i.kt)("em",{parentName:"p"},"experimental"),"."),(0,i.kt)("p",null,"In the above table, ",(0,i.kt)("inlineCode",{parentName:"p"},"H")," represents an arbitrary hexadecimal character, ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"-",(0,i.kt)("inlineCode",{parentName:"p"},"9"),"\nor ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),"-",(0,i.kt)("inlineCode",{parentName:"p"},"F")," (case-sensitive). Unlike in C++, but like in Python, ",(0,i.kt)("inlineCode",{parentName:"p"},"\\x")," expects\nexactly two hexadecimal digits. As in JavaScript, Rust, and Swift, Unicode code\npoints can be expressed by number using ",(0,i.kt)("inlineCode",{parentName:"p"},"\\u{10FFFF}")," notation, which accepts any\nnumber of hexadecimal characters. Any numeric code point in the ranges\n0",(0,i.kt)("sub",null,"16"),"-D7FF",(0,i.kt)("sub",null,"16")," or E000",(0,i.kt)("sub",null,"16"),"-10FFFF",(0,i.kt)("sub",null,"16")," can be\nexpressed this way."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Open question:")," Some programming languages (notably Python) support a\n",(0,i.kt)("inlineCode",{parentName:"p"},"\\N{unicode character name}")," syntax. We could add such an escape sequence.\nFuture proposals considering adding such support should pay attention to work\ndone by C++'s Unicode study group in this area."),(0,i.kt)("p",null,"The escape sequence ",(0,i.kt)("inlineCode",{parentName:"p"},"\\0")," shall not be followed by a decimal digit. In cases\nwhere a null byte should be followed by a decimal digit, ",(0,i.kt)("inlineCode",{parentName:"p"},"\\x00")," can be used\ninstead: ",(0,i.kt)("inlineCode",{parentName:"p"},'"foo\\x00123"'),". The intent is to preserve the possibility of permitting\ndecimal escape sequences in the future."),(0,i.kt)("p",null,"A backslash followed by a line feed character is an escape sequence that\nproduces no string contents. This escape sequence is ",(0,i.kt)("em",{parentName:"p"},"experimental"),", and can\nonly appear in block string literals. This escape sequence is processed after\ntrailing whitespace is replaced by a line feed character, so a ",(0,i.kt)("inlineCode",{parentName:"p"},"\\")," followed by\nhorizontal whitespace followed by a line terminator removes the whitespace up to\nand including the line terminator. Unlike in Rust, but like in Swift, leading\nwhitespace on the line after an escaped newline is not removed, other than\nwhitespace that matches the indentation of the terminating ",(0,i.kt)("inlineCode",{parentName:"p"},'"""'),"."),(0,i.kt)("p",null,"A character sequence starting with a backslash that doesn't match any known\nescape sequence is invalid. Whitespace characters other than space and, for\nblock string literals, new line optionally preceded by carriage return are\ndisallowed. All other characters (including non-printable characters) are\npreserved verbatim. Because all Carbon source files are required to be valid\nsequences of Unicode characters, code unit sequences that are not valid UTF-8\ncan only be produced by ",(0,i.kt)("inlineCode",{parentName:"p"},"\\x")," escape sequences."),(0,i.kt)("p",null,"The decision to disallow raw tab characters in string literals is\n",(0,i.kt)("em",{parentName:"p"},"experimental"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'var String: fret = "I would \'twere something that would fret the string,\\n" +\n                   "The master-cord on\'s \\u{2764}\\u{FE0F}!";\n\n// This string contains two characters (prior to encoding in UTF-8):\n// U+1F3F9 (BOW AND ARROW) followed by U+0032 (DIGIT TWO)\nvar String: password = "\\u{1F3F9}2";\n\n// This string contains no newline characters.\nvar String: type_mismatch = """\n  Shall I compare thee to a summer\'s day? Thou art \\\n  more lovely and more temperate.\\\n  """;\n\nvar String: trailing_whitespace = """\n  This line ends in a space followed by a newline. \\n\\\n      This line starts with four spaces.\n  """;\n')),(0,i.kt)("h3",{id:"raw-string-literals"},"Raw string literals"),(0,i.kt)("p",null,"In order to allow strings whose contents include ",(0,i.kt)("inlineCode",{parentName:"p"},"\\"),"s and ",(0,i.kt)("inlineCode",{parentName:"p"},'"'),"s, the delimiters\nof string literals can be customized by prefixing the opening delimiter with ",(0,i.kt)("em",{parentName:"p"},"N"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"#")," characters. A closing delimiter for such a string is only recognized if it\nis followed by ",(0,i.kt)("em",{parentName:"p"},"N")," ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," characters, and similarly, escape sequences in such\nstring literals are recognized only if the ",(0,i.kt)("inlineCode",{parentName:"p"},"\\")," is also followed by ",(0,i.kt)("em",{parentName:"p"},"N")," ",(0,i.kt)("inlineCode",{parentName:"p"},"#"),"\ncharacters. A ",(0,i.kt)("inlineCode",{parentName:"p"},"\\"),", ",(0,i.kt)("inlineCode",{parentName:"p"},'"'),", or ",(0,i.kt)("inlineCode",{parentName:"p"},'"""')," not followed by ",(0,i.kt)("em",{parentName:"p"},"N")," ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," characters has no\nspecial meaning."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Opening delimiter"),(0,i.kt)("th",{parentName:"tr",align:null},"Escape sequence introducer"),(0,i.kt)("th",{parentName:"tr",align:null},"Closing delimiter"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"')," / ",(0,i.kt)("inlineCode",{parentName:"td"},'"""')),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\")," (for example, ",(0,i.kt)("inlineCode",{parentName:"td"},"\\n"),")"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"')," / ",(0,i.kt)("inlineCode",{parentName:"td"},'"""'))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'#"')," / ",(0,i.kt)("inlineCode",{parentName:"td"},'#"""')),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\#")," (for example, ",(0,i.kt)("inlineCode",{parentName:"td"},"\\#n"),")"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"#')," / ",(0,i.kt)("inlineCode",{parentName:"td"},'"""#'))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'##"')," / ",(0,i.kt)("inlineCode",{parentName:"td"},'##"""')),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\##")," (for example, ",(0,i.kt)("inlineCode",{parentName:"td"},"\\##n"),")"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"##')," / ",(0,i.kt)("inlineCode",{parentName:"td"},'"""##'))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'###"')," / ",(0,i.kt)("inlineCode",{parentName:"td"},'###"""')),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\###")," (for example, ",(0,i.kt)("inlineCode",{parentName:"td"},"\\###n"),")"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'"###')," / ",(0,i.kt)("inlineCode",{parentName:"td"},'"""###'))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"..."),(0,i.kt)("td",{parentName:"tr",align:null},"..."),(0,i.kt)("td",{parentName:"tr",align:null},"...")))),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'var String: x = #"""\n  This is the content of the string. The \'T\' is the first character\n  of the string.\n  """ <-- This is not the end of the string.\n  """#;\n  // But the preceding line does end the string.\n// OK, final character is \\\nvar String: y = #"Hello\\"#;\nvar String: z = ##"Raw strings #"nesting"#"##;\nvar String: w = #"Tab is expressed as \\t. Example: \'\\#t\'"#;\n')),(0,i.kt)("p",null,"Note that both a raw simple string literal and a raw block string literal can\nbegin with ",(0,i.kt)("inlineCode",{parentName:"p"},'#"""'),". These cases can be distinguished by the presence or absence\nof additional ",(0,i.kt)("inlineCode",{parentName:"p"},'"'),"s later in the same line:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In a raw simple string literal, there must be a ",(0,i.kt)("inlineCode",{parentName:"li"},'"')," and one or more ",(0,i.kt)("inlineCode",{parentName:"li"},"#"),"s\nlater in the same line terminating the string."),(0,i.kt)("li",{parentName:"ul"},"In a raw block string literal, the rest of the line is a file type\nindicator, which can contain neither ",(0,i.kt)("inlineCode",{parentName:"li"},'"')," nor ",(0,i.kt)("inlineCode",{parentName:"li"},"#"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-carbon"},'// This string is a single-line raw string literal.\n// The contents of this string start and end with exactly two "s.\nvar String: ambig1 = #"""This is a raw string literal starting with """#;\n\n// This string is a raw block string literal with file-type \'This\', whose\n// contents start with "is a ".\nvar String: ambig2 = #"""This\n  is a block string literal with file type \'This\', first character \'i\',\n  and last character \'X\': X\\#\n  """#;\n\n// This is a single-line raw string literal, equivalent to "\\"".\nvar String: ambig3 = #"""#;\n')),(0,i.kt)("h3",{id:"encoding"},"Encoding"),(0,i.kt)("p",null,"A string literal results in a sequence of 8-bit bytes. Like Carbon source files,\nstring literals are encoded in UTF-8. There is no guarantee that the string is\nvalid UTF-8, however, because arbitrary byte sequences can be inserted by way of\n",(0,i.kt)("inlineCode",{parentName:"p"},"\\xHH")," escape sequences."),(0,i.kt)("p",null,"This is ",(0,i.kt)("em",{parentName:"p"},"experimental"),", and should be revisited if we find sufficient motivation\nfor directly expressing string literals in other encodings. Similarly, as\nlibrary support for a string type evolves, we should consider including string\nliteral syntax (perhaps as the default) that guarantees the string content is a\nvalid UTF-8 encoding, so that valid UTF-8 can be distinguished from an arbitrary\nstring in the type system. In such string literals, we should consider rejecting\n",(0,i.kt)("inlineCode",{parentName:"p"},"\\xHH")," escapes in which HH is greater than 7F",(0,i.kt)("sub",null,"16"),", as in Rust."),(0,i.kt)("h2",{id:"alternatives-considered"},"Alternatives considered"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/proposals/p0199.md#block-string-literals"},"Block string literals"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/proposals/p0199.md#leading-whitespace-removal"},"Leading whitespace removal")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/proposals/p0199.md#terminating-newline"},"Terminating newline")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/proposals/p0199.md#escape-sequences-1"},"Escape sequences")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/proposals/p0199.md#raw-string-literals-1"},"Raw string literals"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/proposals/p0199.md#trailing-whitespace"},"Trailing whitespace")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/proposals/p0199.md#line-separators"},"Line separators")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/proposals/p0199.md#internal-whitespace"},"Internal whitespace"))),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Proposal\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/199"},"#199: String literals"))))}d.isMDXComponent=!0}}]);