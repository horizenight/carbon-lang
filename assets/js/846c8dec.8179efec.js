"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9975],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>b});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(t),b=i,m=d["".concat(s,".").concat(b)]||d[b]||u[b]||r;return t?a.createElement(m,l(l({ref:n},c),{},{components:t})):a.createElement(m,l({ref:n},c))}));function b(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},2925:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(7462),i=(t(7294),t(3905));const r={},l="Principle: All APIs are library APIs",o={unversionedId:"principles/library_apis_only",id:"principles/library_apis_only",title:"Principle: All APIs are library APIs",description:"\x3c!--",source:"@site/../docs/project/principles/library_apis_only.md",sourceDirName:"principles",slug:"/principles/library_apis_only",permalink:"/project/principles/library_apis_only",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/../docs/project/principles/library_apis_only.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Principle: Information accumulation",permalink:"/project/principles/information_accumulation"},next:{title:"Principle: Low context-sensitivity",permalink:"/project/principles/low_context_sensitivity"}},s={},p=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Background",id:"background",level:2},{value:"Principle",id:"principle",level:2},{value:"Applications of this principle",id:"applications-of-this-principle",level:2},{value:"Exceptions",id:"exceptions",level:2},{value:"Alternatives considered",id:"alternatives-considered",level:2}],c={toc:p};function u(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"principle-all-apis-are-library-apis"},"Principle: All APIs are library APIs"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#background"},"Background")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#principle"},"Principle")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#applications-of-this-principle"},"Applications of this principle")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#exceptions"},"Exceptions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#alternatives-considered"},"Alternatives considered"))),(0,i.kt)("h2",{id:"background"},"Background"),(0,i.kt)("p",null,"Every major modern programming language comes with a standard library, which\nconsists of APIs that are not part of the core language, but instead are written\nin the language (although their implementations may not be). However, different\nlanguages draw the boundary between language and library in different places.\nFor example, Go's ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," type is built into the core language, whereas the C++\nequivalent, ",(0,i.kt)("inlineCode",{parentName:"p"},"std::unordered_map"),', is part of the standard library. In Swift,\neven fundamental types like integers and pointers are part of the standard\nlibrary; there are no truly "built in" types.'),(0,i.kt)("p",null,"These decisions can have important consequences for the design of the language.\nFor example, many important features of C++, such as move semantics, variadics,\nand coroutines, were motivated largely by their anticipated uses in a small set\nof standard library types. In a language with a different design philosophy,\nthose types could have been built into the core language. This would probably\nhave substantially simplified the language, and made those types available\nfaster. However, that would have come at the cost of less flexibility for users\noutside the common case."),(0,i.kt)("h2",{id:"principle"},"Principle"),(0,i.kt)("p",null,"In Carbon, every public function is declared in some Carbon ",(0,i.kt)("inlineCode",{parentName:"p"},"api")," file, and\nevery public ",(0,i.kt)("inlineCode",{parentName:"p"},"interface"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),", and first-class type is defined in some Carbon\n",(0,i.kt)("inlineCode",{parentName:"p"},"api")," file. In some cases, the bodies of public functions will not be defined as\nCarbon code, or will be defined as hybrid Carbon code using intrinsics that\naren't available to ordinary Carbon code. However, we will try to minimize those\nsituations."),(0,i.kt)("p",null,'Thus, even "built-in" APIs can be used like user-defined APIs, by importing the\nappropriate library and using qualified names from that library, relying on the\nordinary semantic rules for Carbon APIs.'),(0,i.kt)("h2",{id:"applications-of-this-principle"},"Applications of this principle"),(0,i.kt)("p",null,'We expect Carbon to have a special "prelude" library that is implicitly imported\nby all Carbon source files, and there might be a special name lookup rule to\nallow the names in the prelude to be used unqualified. However, in accordance\nwith this principle, they will remain available to ordinary qualified name\nlookup as well.'),(0,i.kt)("p",null,"According to the resolutions of\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/543"},"#543")," and\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/543"},"#750"),", Carbon will\nhave a substantial number of type keywords, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"i32"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"f64"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"bool"),".\nHowever, these keywords will all be aliases for ordinary type names, such as\n",(0,i.kt)("inlineCode",{parentName:"p"},"Carbon.Int(32)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Carbon.Float(64)"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Carbon.Bool"),". Furthermore, all\narithmetic and logical operators will be overloadable, so that those types can\nbe defined as class types. The member function bodies for these types will be\nprobably not be implemented in Carbon, but this principle applies only to\nfunction declarations, not function definitions."),(0,i.kt)("p",null,"Similarly, a pointer type such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo*")," will be an alias for some library class\ntype, for example ",(0,i.kt)("inlineCode",{parentName:"p"},"Carbon.Ptr(Foo)"),". As a result, Carbon will support\noverloading pointer operations like ",(0,i.kt)("inlineCode",{parentName:"p"},"->")," and unary ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),"."),(0,i.kt)("p",null,"All Carbon operations that use function-style syntax, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"sizeof()")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"decltype()")," in C++, will be standard library functions. As above, in some cases\nwe may choose to alias those functions with keywords, and the function bodies\nmay not be defined in Carbon."),(0,i.kt)("h2",{id:"exceptions"},"Exceptions"),(0,i.kt)("p",null,"This principle applies to types only if they are ",(0,i.kt)("em",{parentName:"p"},"first-class"),", meaning that\nthey can be the types of run-time variables, function parameters, and return\nvalues. Carbon's type system will probably also include some types whose usage\nis more restricted, and this principle will not apply to them. Most importantly,\nfunction types might not be first-class types, in which case they need not be\nlibrary types."),(0,i.kt)("p",null,"The logic for translating a literal expression to a value of the appropriate\ntype is arguably part of that type's public API, but will not be part of that\ntype's class definition."),(0,i.kt)("p",null,"Tuple types will probably not fully conform to this principle, because doing so\nwould be circular: there is no way to name a tuple type that doesn't rely on\ntuple syntax, and no way to define a class body for a tuple type that doesn't\ncontain tuple patterns. However, we will strive to ensure that it is possible to\ndefine a parameterized class type within Carbon that supports all the same\noperations as built-in tuple types."),(0,i.kt)("h2",{id:"alternatives-considered"},"Alternatives considered"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/proposals/p1280.md#built-in-primitive-types"},"Built-in primitive types"))))}u.isMDXComponent=!0}}]);