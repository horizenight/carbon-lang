"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6975],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>h});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=s(t),h=i,f=c["".concat(p,".").concat(h)]||c[h]||d[h]||r;return t?a.createElement(f,l(l({ref:n},m),{},{components:t})):a.createElement(f,l({ref:n},m))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=c;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},9531:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var a=t(7462),i=(t(7294),t(3905));const r={},l="Generics: Details",o={unversionedId:"generics/details",id:"generics/details",title:"Generics: Details",description:"\x3c!--",source:"@site/../docs/design/generics/details.md",sourceDirName:"generics",slug:"/generics/details",permalink:"/design/generics/details",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/../docs/design/generics/details.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Carbon: alternatives to coherence",permalink:"/design/generics/appendix-coherence"},next:{title:"Generics: Goals",permalink:"/design/generics/goals"}},p={},s=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Interfaces",id:"interfaces",level:2},{value:"Implementing interfaces",id:"implementing-interfaces",level:2},{value:"Implementing multiple interfaces",id:"implementing-multiple-interfaces",level:3},{value:"External impl",id:"external-impl",level:3},{value:"Qualified member names and compound member access",id:"qualified-member-names-and-compound-member-access",level:3},{value:"Access",id:"access",level:3},{value:"Generics",id:"generics",level:2},{value:"Return type",id:"return-type",level:3},{value:"Implementation model",id:"implementation-model",level:3},{value:"Interfaces recap",id:"interfaces-recap",level:2},{value:"Type-of-types",id:"type-of-types",level:2},{value:"Named constraints",id:"named-constraints",level:2},{value:"Subtyping between type-of-types",id:"subtyping-between-type-of-types",level:3},{value:"Combining interfaces by anding type-of-types",id:"combining-interfaces-by-anding-type-of-types",level:2},{value:"Interface requiring other interfaces",id:"interface-requiring-other-interfaces",level:2},{value:"Interface extension",id:"interface-extension",level:3},{value:"<code>extends</code> and <code>impl</code> with named constraints",id:"extends-and-impl-with-named-constraints",level:4},{value:"Diamond dependency issue",id:"diamond-dependency-issue",level:4},{value:"Use case: overload resolution",id:"use-case-overload-resolution",level:3},{value:"Adapting types",id:"adapting-types",level:2},{value:"Adapter compatibility",id:"adapter-compatibility",level:3},{value:"Extending adapter",id:"extending-adapter",level:3},{value:"Use case: Using independent libraries together",id:"use-case-using-independent-libraries-together",level:3},{value:"Use case: Defining an impl for use by other types",id:"use-case-defining-an-impl-for-use-by-other-types",level:3},{value:"Use case: Private impl",id:"use-case-private-impl",level:3},{value:"Use case: Accessing external names",id:"use-case-accessing-external-names",level:3},{value:"Adapter with stricter invariants",id:"adapter-with-stricter-invariants",level:3},{value:"Associated constants",id:"associated-constants",level:2},{value:"Associated class functions",id:"associated-class-functions",level:3},{value:"Associated types",id:"associated-types",level:2},{value:"Implementation model",id:"implementation-model-1",level:3},{value:"Parameterized interfaces",id:"parameterized-interfaces",level:2},{value:"Impl lookup",id:"impl-lookup",level:3},{value:"Parameterized named constraints",id:"parameterized-named-constraints",level:3},{value:"Where constraints",id:"where-constraints",level:2},{value:"Constraint use cases",id:"constraint-use-cases",level:3},{value:"Set an associated constant to a specific value",id:"set-an-associated-constant-to-a-specific-value",level:4},{value:"Same type constraints",id:"same-type-constraints",level:4},{value:"Set an associated type to a specific value",id:"set-an-associated-type-to-a-specific-value",level:5},{value:"Equal generic types",id:"equal-generic-types",level:5},{value:"Satisfying both type-of-types",id:"satisfying-both-type-of-types",level:6},{value:"Type bound for associated type",id:"type-bound-for-associated-type",level:4},{value:"Type bounds on associated types in declarations",id:"type-bounds-on-associated-types-in-declarations",level:5},{value:"Type bounds on associated types in interfaces",id:"type-bounds-on-associated-types-in-interfaces",level:5},{value:"Combining constraints",id:"combining-constraints",level:4},{value:"Recursive constraints",id:"recursive-constraints",level:4},{value:"Parameterized type implements interface",id:"parameterized-type-implements-interface",level:4},{value:"Another type implements parameterized interface",id:"another-type-implements-parameterized-interface",level:4},{value:"Implied constraints",id:"implied-constraints",level:3},{value:"Must be legal type argument constraints",id:"must-be-legal-type-argument-constraints",level:4},{value:"Referencing names in the interface being defined",id:"referencing-names-in-the-interface-being-defined",level:3},{value:"Manual type equality",id:"manual-type-equality",level:3},{value:"<code>observe</code> declarations",id:"observe-declarations",level:4},{value:"Other constraints as type-of-types",id:"other-constraints-as-type-of-types",level:2},{value:"Is a derived class",id:"is-a-derived-class",level:3},{value:"Type compatible with another type",id:"type-compatible-with-another-type",level:3},{value:"Same implementation restriction",id:"same-implementation-restriction",level:4},{value:"Example: Multiple implementations of the same interface",id:"example-multiple-implementations-of-the-same-interface",level:4},{value:"Example: Creating an impl out of other impls",id:"example-creating-an-impl-out-of-other-impls",level:4},{value:"Sized types and type-of-types",id:"sized-types-and-type-of-types",level:3},{value:"Implementation model",id:"implementation-model-2",level:4},{value:"<code>TypeId</code>",id:"typeid",level:3},{value:"Destructor constraints",id:"destructor-constraints",level:3},{value:"Generic <code>let</code>",id:"generic-let",level:2},{value:"Parameterized impls",id:"parameterized-impls",level:2},{value:"Impl for a parameterized type",id:"impl-for-a-parameterized-type",level:3},{value:"Conditional conformance",id:"conditional-conformance",level:3},{value:"Conditional methods",id:"conditional-methods",level:4},{value:"Blanket impls",id:"blanket-impls",level:3},{value:"Difference between blanket impls and named constraints",id:"difference-between-blanket-impls-and-named-constraints",level:4},{value:"Wildcard impls",id:"wildcard-impls",level:3},{value:"Combinations",id:"combinations",level:3},{value:"Lookup resolution and specialization",id:"lookup-resolution-and-specialization",level:3},{value:"Type structure of an impl declaration",id:"type-structure-of-an-impl-declaration",level:4},{value:"Orphan rule",id:"orphan-rule",level:4},{value:"Overlap rule",id:"overlap-rule",level:4},{value:"Prioritization rule",id:"prioritization-rule",level:4},{value:"Acyclic rule",id:"acyclic-rule",level:4},{value:"Termination rule",id:"termination-rule",level:4},{value:"<code>final</code> impls",id:"final-impls",level:3},{value:"Libraries that can contain <code>final</code> impls",id:"libraries-that-can-contain-final-impls",level:4},{value:"Comparison to Rust",id:"comparison-to-rust",level:3},{value:"Forward declarations and cyclic references",id:"forward-declarations-and-cyclic-references",level:2},{value:"Declaring interfaces and named constraints",id:"declaring-interfaces-and-named-constraints",level:3},{value:"Declaring implementations",id:"declaring-implementations",level:3},{value:"Matching and agreeing",id:"matching-and-agreeing",level:3},{value:"Declaration examples",id:"declaration-examples",level:3},{value:"Example of declaring interfaces with cyclic references",id:"example-of-declaring-interfaces-with-cyclic-references",level:3},{value:"Interfaces with parameters constrained by the same interface",id:"interfaces-with-parameters-constrained-by-the-same-interface",level:3},{value:"Interface members with definitions",id:"interface-members-with-definitions",level:2},{value:"Interface defaults",id:"interface-defaults",level:3},{value:"<code>final</code> members",id:"final-members",level:3},{value:"Interface requiring other interfaces revisited",id:"interface-requiring-other-interfaces-revisited",level:2},{value:"Requirements with <code>where</code> constraints",id:"requirements-with-where-constraints",level:3},{value:"Observing a type implements an interface",id:"observing-a-type-implements-an-interface",level:2},{value:"Observing interface requirements",id:"observing-interface-requirements",level:3},{value:"Observing blanket impls",id:"observing-blanket-impls",level:3},{value:"Operator overloading",id:"operator-overloading",level:2},{value:"Binary operators",id:"binary-operators",level:3},{value:"<code>like</code> operator for implicit conversions",id:"like-operator-for-implicit-conversions",level:3},{value:"Parameterized types",id:"parameterized-types",level:2},{value:"Specialization",id:"specialization",level:3},{value:"Future work",id:"future-work",level:2},{value:"Dynamic types",id:"dynamic-types",level:3},{value:"Runtime type parameters",id:"runtime-type-parameters",level:4},{value:"Runtime type fields",id:"runtime-type-fields",level:4},{value:"Abstract return types",id:"abstract-return-types",level:3},{value:"Evolution",id:"evolution",level:3},{value:"Testing",id:"testing",level:3},{value:"Impls with state",id:"impls-with-state",level:3},{value:"Generic associated types and higher-ranked types",id:"generic-associated-types-and-higher-ranked-types",level:3},{value:"Generic associated types",id:"generic-associated-types",level:4},{value:"Higher-ranked types",id:"higher-ranked-types",level:4},{value:"Field requirements",id:"field-requirements",level:3},{value:"Bridge for C++ customization points",id:"bridge-for-c-customization-points",level:3},{value:"Variadic arguments",id:"variadic-arguments",level:3},{value:"Range constraints on generic integers",id:"range-constraints-on-generic-integers",level:3},{value:"References",id:"references",level:2}],m={toc:s};function d(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"generics-details"},"Generics: Details"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#overview"},"Overview")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interfaces"},"Interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#implementing-interfaces"},"Implementing interfaces"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#implementing-multiple-interfaces"},"Implementing multiple interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#external-impl"},"External impl")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#qualified-member-names-and-compound-member-access"},"Qualified member names and compound member access")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#access"},"Access")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#generics"},"Generics"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#return-type"},"Return type")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#implementation-model"},"Implementation model")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interfaces-recap"},"Interfaces recap")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-of-types"},"Type-of-types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#named-constraints"},"Named constraints"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#subtyping-between-type-of-types"},"Subtyping between type-of-types")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#combining-interfaces-by-anding-type-of-types"},"Combining interfaces by anding type-of-types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interface-requiring-other-interfaces"},"Interface requiring other interfaces"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interface-extension"},"Interface extension"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#extends-and-impl-with-named-constraints"},(0,i.kt)("inlineCode",{parentName:"a"},"extends")," and ",(0,i.kt)("inlineCode",{parentName:"a"},"impl")," with named constraints")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#diamond-dependency-issue"},"Diamond dependency issue")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#use-case-overload-resolution"},"Use case: overload resolution")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#adapting-types"},"Adapting types"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#adapter-compatibility"},"Adapter compatibility")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#extending-adapter"},"Extending adapter")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#use-case-using-independent-libraries-together"},"Use case: Using independent libraries together")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#use-case-defining-an-impl-for-use-by-other-types"},"Use case: Defining an impl for use by other types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#use-case-private-impl"},"Use case: Private impl")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#use-case-accessing-external-names"},"Use case: Accessing external names")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#adapter-with-stricter-invariants"},"Adapter with stricter invariants")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#associated-constants"},"Associated constants"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#associated-class-functions"},"Associated class functions")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#associated-types"},"Associated types"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#implementation-model-1"},"Implementation model")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#parameterized-interfaces"},"Parameterized interfaces"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#impl-lookup"},"Impl lookup")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#parameterized-named-constraints"},"Parameterized named constraints")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#where-constraints"},"Where constraints"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#constraint-use-cases"},"Constraint use cases"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#set-an-associated-constant-to-a-specific-value"},"Set an associated constant to a specific value")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#same-type-constraints"},"Same type constraints"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#set-an-associated-type-to-a-specific-value"},"Set an associated type to a specific value")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#equal-generic-types"},"Equal generic types"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#satisfying-both-type-of-types"},"Satisfying both type-of-types")))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-bound-for-associated-type"},"Type bound for associated type"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-bounds-on-associated-types-in-declarations"},"Type bounds on associated types in declarations")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-bounds-on-associated-types-in-interfaces"},"Type bounds on associated types in interfaces")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#combining-constraints"},"Combining constraints")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#recursive-constraints"},"Recursive constraints")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#parameterized-type-implements-interface"},"Parameterized type implements interface")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#another-type-implements-parameterized-interface"},"Another type implements parameterized interface")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#implied-constraints"},"Implied constraints"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#must-be-legal-type-argument-constraints"},"Must be legal type argument constraints")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#referencing-names-in-the-interface-being-defined"},"Referencing names in the interface being defined")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#manual-type-equality"},"Manual type equality"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#observe-declarations"},(0,i.kt)("inlineCode",{parentName:"a"},"observe")," declarations")))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#other-constraints-as-type-of-types"},"Other constraints as type-of-types"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#is-a-derived-class"},"Is a derived class")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-compatible-with-another-type"},"Type compatible with another type"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#same-implementation-restriction"},"Same implementation restriction")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#example-multiple-implementations-of-the-same-interface"},"Example: Multiple implementations of the same interface")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#example-creating-an-impl-out-of-other-impls"},"Example: Creating an impl out of other impls")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#sized-types-and-type-of-types"},"Sized types and type-of-types"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#implementation-model-2"},"Implementation model")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#typeid"},(0,i.kt)("inlineCode",{parentName:"a"},"TypeId"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#destructor-constraints"},"Destructor constraints")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#generic-let"},"Generic ",(0,i.kt)("inlineCode",{parentName:"a"},"let"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#parameterized-impls"},"Parameterized impls"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#impl-for-a-parameterized-type"},"Impl for a parameterized type")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#conditional-conformance"},"Conditional conformance"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#conditional-methods"},"Conditional methods")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#blanket-impls"},"Blanket impls"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#difference-between-blanket-impls-and-named-constraints"},"Difference between blanket impls and named constraints")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#wildcard-impls"},"Wildcard impls")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#combinations"},"Combinations")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#lookup-resolution-and-specialization"},"Lookup resolution and specialization"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-structure-of-an-impl-declaration"},"Type structure of an impl declaration")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#orphan-rule"},"Orphan rule")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#overlap-rule"},"Overlap rule")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#prioritization-rule"},"Prioritization rule")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#acyclic-rule"},"Acyclic rule")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#termination-rule"},"Termination rule")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#final-impls"},(0,i.kt)("inlineCode",{parentName:"a"},"final")," impls"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#libraries-that-can-contain-final-impls"},"Libraries that can contain ",(0,i.kt)("inlineCode",{parentName:"a"},"final")," impls")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#comparison-to-rust"},"Comparison to Rust")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#forward-declarations-and-cyclic-references"},"Forward declarations and cyclic references"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#declaring-interfaces-and-named-constraints"},"Declaring interfaces and named constraints")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#declaring-implementations"},"Declaring implementations")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#matching-and-agreeing"},"Matching and agreeing")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#declaration-examples"},"Declaration examples")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#example-of-declaring-interfaces-with-cyclic-references"},"Example of declaring interfaces with cyclic references")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interfaces-with-parameters-constrained-by-the-same-interface"},"Interfaces with parameters constrained by the same interface")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interface-members-with-definitions"},"Interface members with definitions"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interface-defaults"},"Interface defaults")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#final-members"},(0,i.kt)("inlineCode",{parentName:"a"},"final")," members")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interface-requiring-other-interfaces-revisited"},"Interface requiring other interfaces revisited"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#requirements-with-where-constraints"},"Requirements with ",(0,i.kt)("inlineCode",{parentName:"a"},"where")," constraints")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#observing-a-type-implements-an-interface"},"Observing a type implements an interface"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#observing-interface-requirements"},"Observing interface requirements")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#observing-blanket-impls"},"Observing blanket impls")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#operator-overloading"},"Operator overloading"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#binary-operators"},"Binary operators")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#like-operator-for-implicit-conversions"},(0,i.kt)("inlineCode",{parentName:"a"},"like")," operator for implicit conversions")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#parameterized-types"},"Parameterized types"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#specialization"},"Specialization")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#future-work"},"Future work"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#dynamic-types"},"Dynamic types"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#runtime-type-parameters"},"Runtime type parameters")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#runtime-type-fields"},"Runtime type fields")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#abstract-return-types"},"Abstract return types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#evolution"},"Evolution")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#testing"},"Testing")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#impls-with-state"},"Impls with state")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#generic-associated-types-and-higher-ranked-types"},"Generic associated types and higher-ranked types"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#generic-associated-types"},"Generic associated types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#higher-ranked-types"},"Higher-ranked types")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#field-requirements"},"Field requirements")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#bridge-for-c-customization-points"},"Bridge for C++ customization points")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#variadic-arguments"},"Variadic arguments")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#range-constraints-on-generic-integers"},"Range constraints on generic integers")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#references"},"References"))),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"This document goes into the details of the design of generic type parameters."),(0,i.kt)("p",null,"Imagine we want to write a function parameterized by a type argument. Maybe our\nfunction is ",(0,i.kt)("inlineCode",{parentName:"p"},"PrintToStdout")," and let's say we want to operate on values that have\na type for which we have an implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertibleToString"),"\ninterface. The ",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertibleToString")," interface has a ",(0,i.kt)("inlineCode",{parentName:"p"},"ToString")," method returning\na string. To do this, we give the ",(0,i.kt)("inlineCode",{parentName:"p"},"PrintToStdout")," function two parameters: one\nis the value to print, let's call that ",(0,i.kt)("inlineCode",{parentName:"p"},"val"),", the other is the type of that\nvalue, let's call that ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),". The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"val")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", what is the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"?\nWell, since we want to let ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," be any type implementing the\n",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertibleToString"),' interface, we express that in the "interfaces are\ntype-of-types" model by saying the type of ',(0,i.kt)("inlineCode",{parentName:"p"},"T")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertibleToString"),"."),(0,i.kt)("p",null,"Since we can figure out ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," from the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"val"),", we don't need the caller to\npass in ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," explicitly, so it can be a\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#deduced-parameter"},"deduced parameter")," (also see\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/overview#deduced-parameters"},"deduced parameters")," in the Generics overview\ndoc). Basically, the user passes in a value for ",(0,i.kt)("inlineCode",{parentName:"p"},"val"),", and the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"val"),"\ndetermines ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," still gets passed into the function though, and it plays an\nimportant role -- it defines the implementation of the interface. We can think\nof the interface as defining a struct type whose members are function pointers,\nand an implementation of an interface as a value of that struct with actual\nfunction pointer values. So an implementation is a table of function pointers\n(one per function defined in the interface) that gets passed into a function as\nthe type argument. For more on this, see\n",(0,i.kt)("a",{parentName:"p",href:"#implementation-model"},"the implementation model section")," below."),(0,i.kt)("p",null,"In addition to function pointer members, interfaces can include any constants\nthat belong to a type. For example, the\n",(0,i.kt)("a",{parentName:"p",href:"#sized-types-and-type-of-types"},"type's size")," (represented by an integer\nconstant member of the type) could be a member of an interface and its\nimplementation. There are a few cases why we would include another interface\nimplementation as a member:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#associated-types"},"associated types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#parameterized-interfaces"},"type parameters")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interface-requiring-other-interfaces"},"interface requirements"))),(0,i.kt)("p",null,"The function expresses that the type argument is passed in\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#static-dispatch-witness-table"},"statically"),', basically generating\na separate function body for every different type passed in, by using the\n"generic argument" syntax ',(0,i.kt)("inlineCode",{parentName:"p"},":!"),", see ",(0,i.kt)("a",{parentName:"p",href:"#generics"},"the generics section")," below. The\ninterface contains enough information to\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#complete-definition-checking"},"type and definition check")," the\nfunction body -- you can only call functions defined in the interface in the\nfunction body. Contrast this with making the type a template argument, where you\ncould just use ",(0,i.kt)("inlineCode",{parentName:"p"},"Type")," instead of an interface and it will work as long as the\nfunction is only called with types that allow the definition of the function to\ncompile. The interface bound has other benefits:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"allows the compiler to deliver clearer error messages,"),(0,i.kt)("li",{parentName:"ul"},"documents expectations, and"),(0,i.kt)("li",{parentName:"ul"},"expresses that a type has certain semantics beyond what is captured in its\nmember function names and signatures.")),(0,i.kt)("p",null,"The last piece of the puzzle is calling the function. For a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Song"),"\nto be printed using the ",(0,i.kt)("inlineCode",{parentName:"p"},"PrintToStdout")," function, ",(0,i.kt)("inlineCode",{parentName:"p"},"Song")," needs to implement the\n",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertibleToString")," interface. Interface implementations will usually be\ndefined either with the type or with the interface. They may also be defined\nsomewhere else as long as Carbon can be guaranteed to see the definition when\nneeded. For more on this, see\n",(0,i.kt)("a",{parentName:"p",href:"#implementing-interfaces"},"the implementing interfaces section")," below."),(0,i.kt)("p",null,"Unless the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertibleToString")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Song")," is defined as\n",(0,i.kt)("inlineCode",{parentName:"p"},"external"),", every member of ",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertibleToString")," is also a member of ",(0,i.kt)("inlineCode",{parentName:"p"},"Song"),".\nThis includes members of ",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertibleToString")," that are not explicitly named in\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," definition but have defaults. Whether the implementation is defined\nas ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#internal-impl"},"internal")," or\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#external-impl"},"external"),", you may access the ",(0,i.kt)("inlineCode",{parentName:"p"},"ToString")," function\nfor a ",(0,i.kt)("inlineCode",{parentName:"p"},"Song")," value ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," by a writing function call\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#qualified-member-access-expression"},"using a qualified member access expression"),",\nlike ",(0,i.kt)("inlineCode",{parentName:"p"},"s.(ConvertibleToString.ToString)()"),"."),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"Song")," doesn't implement an interface or we would like to use a different\nimplementation of that interface, we can define another type that also has the\nsame data representation as ",(0,i.kt)("inlineCode",{parentName:"p"},"Song")," that has whatever different interface\nimplementations we want. However, Carbon won't implicitly convert to that other\ntype, the user will have to explicitly cast to that type in order to select\nthose alternate implementations. For more on this, see\n",(0,i.kt)("a",{parentName:"p",href:"#adapting-types"},"the adapting type section")," below."),(0,i.kt)("h2",{id:"interfaces"},"Interfaces"),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#interface"},"interface"),", defines an API that a given type can\nimplement. For example, an interface capturing a linear-algebra vector API might\nhave two methods:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'interface Vector {\n  // Here `Self` means "the type implementing this interface".\n  fn Add[me: Self](b: Self) -> Self;\n  fn Scale[me: Self](v: f64) -> Self;\n}\n')),(0,i.kt)("p",null,"The syntax here is to match\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/classes.md#methods"},"how the same members would be defined in a type"),".\nEach declaration in the interface defines an\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#associated-entity"},"associated entity"),". In this example, ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),"\nhas two associated methods, ",(0,i.kt)("inlineCode",{parentName:"p"},"Add")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Scale"),"."),(0,i.kt)("p",null,"An interface defines a type-of-type, that is a type whose values are types. The\nvalues of an interface are any types implementing the interface, and so provide\ndefinitions for all the functions (and other members) declared in the interface."),(0,i.kt)("h2",{id:"implementing-interfaces"},"Implementing interfaces"),(0,i.kt)("p",null,"Carbon interfaces are ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#nominal-interfaces"},'"nominal"'),", which\nmeans that types explicitly describe how they implement interfaces. An\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#impls-implementations-of-interfaces"},'"impl"')," defines how one\ninterface is implemented for a type. Every associated entity is given a\ndefinition. Different types satisfying ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," can have different definitions\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"Add")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Scale"),", so we say their definitions are ",(0,i.kt)("em",{parentName:"p"},"associated")," with what\ntype is implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," defines what is associated with the\ntype for that interface."),(0,i.kt)("p",null,"Impls may be defined inline inside the type definition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'class Point {\n  var x: f64;\n  var y: f64;\n  impl as Vector {\n    // In this scope, "Self" is an alias for "Point".\n    fn Add[me: Self](b: Self) -> Self {\n      return {.x = a.x + b.x, .y = a.y + b.y};\n    }\n    fn Scale[me: Self](v: f64) -> Self {\n      return {.x = a.x * v, .y = a.y * v};\n    }\n  }\n}\n')),(0,i.kt)("p",null,"Interfaces that are implemented inline contribute to the type's API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var p1: Point = {.x = 1.0, .y = 2.0};\nvar p2: Point = {.x = 2.0, .y = 4.0};\nAssert(p1.Scale(2.0) == p2);\nAssert(p1.Add(p1) == p2);\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," A type may implement any number of different interfaces, but may\nprovide at most one implementation of any single interface. This makes the act\nof selecting an implementation of an interface for a type unambiguous throughout\nthe whole program."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," Rust defines implementations lexically\noutside of the ",(0,i.kt)("inlineCode",{parentName:"p"},"class")," definition. This Carbon approach means that a type's API\nis described by declarations inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"class")," definition and doesn't change\nafterwards."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"References:")," This interface implementation syntax was accepted in\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/pull/553"},"proposal #553"),". In\nparticular, see\n",(0,i.kt)("a",{parentName:"p",href:"/proposals/p0553.md#interface-implementation-syntax"},"the alternatives considered"),"."),(0,i.kt)("h3",{id:"implementing-multiple-interfaces"},"Implementing multiple interfaces"),(0,i.kt)("p",null,"To implement more than one interface when defining a type, simply include an\n",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," block per interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Point {\n  var x: f64;\n  var y: f64;\n  impl as Vector {\n    fn Add[me: Self](b: Self) -> Self { ... }\n    fn Scale[me: Self](v: f64) -> Self { ... }\n  }\n  impl as Drawable {\n    fn Draw[me: Self]() { ... }\n  }\n}\n")),(0,i.kt)("p",null,"In this case, all the functions ",(0,i.kt)("inlineCode",{parentName:"p"},"Add"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Scale"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Draw")," end up a part of the\nAPI for ",(0,i.kt)("inlineCode",{parentName:"p"},"Point"),". This means you can't implement two interfaces that have a name\nin common (unless you use an ",(0,i.kt)("inlineCode",{parentName:"p"},"external impl")," for one or both, as described\nbelow)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class GameBoard {\n  impl as Drawable {\n    fn Draw[me: Self]() { ... }\n  }\n  impl as EndOfGame {\n    // \u274c Error: `GameBoard` has two methods named\n    // `Draw` with the same signature.\n    fn Draw[me: Self]() { ... }\n    fn Winner[me: Self](player: i32) { ... }\n  }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," Should we have some syntax for the case where you want both\nnames to be given the same implementation? It seems like that might be a common\ncase, but we won't really know if this is an important case until we get more\nexperience."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Player {\n  var name: String;\n  impl as Icon {\n    fn Name[me: Self]() -> String { return me.name; }\n    // ...\n  }\n  impl as GameUnit {\n    // Possible syntax options for defining\n    // `GameUnit.Name` as the same as `Icon.Name`:\n    alias Name = Icon.Name;\n    fn Name[me: Self]() -> String = Icon.Name;\n    // ...\n  }\n}\n")),(0,i.kt)("h3",{id:"external-impl"},"External impl"),(0,i.kt)("p",null,"Interfaces may also be implemented for a type\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#external-impl"},"externally"),", by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"external impl"),"\nconstruct. An external impl does not add the interface's methods to the type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Point2 {\n  var x: f64;\n  var y: f64;\n\n  external impl as Vector {\n    // In this scope, `Self` is an alias for `Point2`.\n    fn Add[me: Self](b: Self) -> Self {\n      return {.x = a.x + b.x, .y = a.y + b.y};\n    }\n    fn Scale[me: Self](v: f64) -> Self {\n      return {.x = a.x * v, .y = a.y * v};\n    }\n  }\n}\n\nvar a: Point2 = {.x = 1.0, .y = 2.0};\n// `a` does *not* have `Add` and `Scale` methods:\n// \u274c Error: a.Add(a.Scale(2.0));\n")),(0,i.kt)("p",null,"An external impl may be defined out-of-line, by including the name of the\nexisting type before ",(0,i.kt)("inlineCode",{parentName:"p"},"as"),", which is otherwise optional:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Point3 {\n  var x: f64;\n  var y: f64;\n}\n\nexternal impl Point3 as Vector {\n  // In this scope, `Self` is an alias for `Point3`.\n  fn Add[me: Self](b: Self) -> Self {\n    return {.x = a.x + b.x, .y = a.y + b.y};\n  }\n  fn Scale[me: Self](v: f64) -> Self {\n    return {.x = a.x * v, .y = a.y * v};\n  }\n}\n\nvar a: Point3 = {.x = 1.0, .y = 2.0};\n// `a` does *not* have `Add` and `Scale` methods:\n// \u274c Error: a.Add(a.Scale(2.0));\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"References:")," The external interface implementation syntax was decided in\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/pull/553"},"proposal #553"),". In\nparticular, see\n",(0,i.kt)("a",{parentName:"p",href:"/proposals/p0553.md#interface-implementation-syntax"},"the alternatives considered"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"external impl")," statement is allowed to be defined in a different library\nfrom ",(0,i.kt)("inlineCode",{parentName:"p"},"Point3"),", restricted by ",(0,i.kt)("a",{parentName:"p",href:"#impl-lookup"},"the coherence/orphan rules")," that\nensure that the implementation of an interface can't change based on imports. In\nparticular, the ",(0,i.kt)("inlineCode",{parentName:"p"},"external impl")," statement is allowed in the library defining the\ninterface (",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," in this case) in addition to the library that defines the\ntype (",(0,i.kt)("inlineCode",{parentName:"p"},"Point3")," here). This (at least partially) addresses\n",(0,i.kt)("a",{parentName:"p",href:"https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions"},"the expression problem"),"."),(0,i.kt)("p",null,"Carbon requires ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),"s defined in a different library to be ",(0,i.kt)("inlineCode",{parentName:"p"},"external")," so that\nthe API of ",(0,i.kt)("inlineCode",{parentName:"p"},"Point3")," doesn't change based on what is imported. It would be\nparticularly bad if two different libraries implemented interfaces with\nconflicting names that both affected the API of a single type. As a consequence\nof this restriction, you can find all the names of direct members (those\navailable by ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#simple-member-access"},"simple member access"),") of a\ntype in the definition of that type. The only thing that may be in another\nlibrary is an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," of an interface."),(0,i.kt)("p",null,"You might also use ",(0,i.kt)("inlineCode",{parentName:"p"},"external impl")," to implement an interface for a type to avoid\ncluttering the API of that type, for example to avoid a name collision. A syntax\nfor reusing method implementations allows us to do this selectively when needed.\nIn this case, the ",(0,i.kt)("inlineCode",{parentName:"p"},"external impl")," may be declared lexically inside the class\nscope."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Point4a {\n  var x: f64;\n  var y: f64;\n  fn Add[me: Self](b: Self) -> Self {\n    return {.x = a.x + b.x, .y = a.y + b.y};\n  }\n  external impl as Vector {\n    alias Add = Point4a.Add;  // Syntax TBD\n    fn Scale[me: Self](v: f64) -> Self {\n      return {.x = a.x * v, .y = a.y * v};\n    }\n  }\n}\n\n// OR:\n\nclass Point4b {\n  var x: f64;\n  var y: f64;\n  external impl as Vector {\n    fn Add[me: Self](b: Self) -> Self {\n      return {.x = a.x + b.x, .y = a.y + b.y};\n    }\n    fn Scale[me: Self](v: f64) -> Self {\n      return {.x = a.x * v, .y = a.y * v};\n    }\n  }\n  alias Add = Vector.Add;  // Syntax TBD\n}\n\n// OR:\n\nclass Point4c {\n  var x: f64;\n  var y: f64;\n  fn Add[me: Self](b: Self) -> Self {\n    return {.x = a.x + b.x, .y = a.y + b.y};\n  }\n}\n\nexternal impl Point4c as Vector {\n  alias Add = Point4c.Add;  // Syntax TBD\n  fn Scale[me: Self](v: f64) -> Self {\n    return {.x = a.x * v, .y = a.y * v};\n  }\n}\n")),(0,i.kt)("p",null,"Being defined lexically inside the class means that implementation is available\nto other members defined in the class. For example, it would allow implementing\nanother interface or method that requires this interface to be implemented."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," Do implementations need to be defined lexically inside the\nclass to get access to private members, or is it sufficient to be defined in the\nsame library as the class?"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Rejected alternative:"),' We could allow types to have different APIs in\ndifferent files based on explicit configuration in that file. For example, we\ncould support a declaration that a given interface or a given method of an\ninterface is "in scope" for a particular type in this file. With that\ndeclaration, the method could be called using\n',(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#simple-member-access"},"simple member access"),". This avoids most\nconcerns arising from name collisions between interfaces. It has a few downsides\nthough:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It increases variability between files, since the same type will have\ndifferent APIs depending on these declarations. This makes it harder to\ncopy-paste code between files."),(0,i.kt)("li",{parentName:"ul"},"It makes reading code harder, since you have to search the file for these\ndeclarations that affect name lookup.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," Both Rust and Swift support external\nimplementation.\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID277"},"Swift's syntax"),'\ndoes this as an "extension" of the original type. In Rust, all implementations\nare external as in\n',(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/rust-by-example/trait.html"},"this example"),". Unlike\nSwift and Rust, we don't allow a type's API to be modified outside its\ndefinition. So in Carbon a type's API is consistent no matter what is imported,\nunlike Swift and Rust."),(0,i.kt)("h3",{id:"qualified-member-names-and-compound-member-access"},"Qualified member names and compound member access"),(0,i.kt)("p",null,"Given a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Point3")," and an interface ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," implemented for that\ntype, you can access the methods from that interface using a\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#qualified-member-access-expression"},"qualified member access expression"),"\nwhether or not the implementation is done externally with an ",(0,i.kt)("inlineCode",{parentName:"p"},"external impl"),"\ndeclaration. The qualified member access expression writes the member's\n",(0,i.kt)("em",{parentName:"p"},"qualified name")," in the parentheses of the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/member_access.md"},"compound member access syntax"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var p1: Point3 = {.x = 1.0, .y = 2.0};\nvar p2: Point3 = {.x = 2.0, .y = 4.0};\nAssert(p1.(Vector.Scale)(2.0) == p2);\nAssert(p1.(Vector.Add)(p1) == p2);\n")),(0,i.kt)("p",null,"Note that the name in the parens is looked up in the containing scope, not in\nthe names of members of ",(0,i.kt)("inlineCode",{parentName:"p"},"Point3"),". So if there was another interface ",(0,i.kt)("inlineCode",{parentName:"p"},"Drawable"),"\nwith method ",(0,i.kt)("inlineCode",{parentName:"p"},"Draw")," defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Plot")," package also implemented for ",(0,i.kt)("inlineCode",{parentName:"p"},"Point3"),",\nas in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"package Plot;\nimport Points;\n\ninterface Drawable {\n  fn Draw[me: Self]();\n}\n\nexternal impl Points.Point3 as Drawable { ... }\n")),(0,i.kt)("p",null,"You could access ",(0,i.kt)("inlineCode",{parentName:"p"},"Draw")," with a qualified name:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"import Plot;\nimport Points;\n\nvar p: Points.Point3 = {.x = 1.0, .y = 2.0};\np.(Plot.Drawable.Draw)();\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," This is intended to be analogous to, in\nC++, adding ",(0,i.kt)("inlineCode",{parentName:"p"},"ClassName::")," in front of a member name to disambiguate, such as\n",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/357307/how-to-call-a-parent-class-function-from-derived-class-function"},"names defined in both a parent and child class"),"."),(0,i.kt)("h3",{id:"access"},"Access"),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," must be visible to all code that can see both the type and the\ninterface being implemented:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If either the type or interface is private to a single file, then since the\nonly way to define the ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," is to use that private name, the ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," must\nbe defined private to that file as well."),(0,i.kt)("li",{parentName:"ul"},"Otherwise, if the type or interface is private but declared in an API file,\nthen the ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," must be declared in the same file so the existence of that\n",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," is visible to all files in that library."),(0,i.kt)("li",{parentName:"ul"},"Otherwise, the ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," must be defined in the public API file of the library,\nso it is visible in all places that might use it.")),(0,i.kt)("p",null,"No access control modifiers are allowed on ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," declarations, an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," is\nalways visible to the intersection of the visibility of all names used in the\ndeclaration of the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),"."),(0,i.kt)("h2",{id:"generics"},"Generics"),(0,i.kt)("p",null,"Here is a function that can accept values of any type that has implemented the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn AddAndScaleGeneric[T:! Vector](a: T, b: T, s: f64) -> T {\n  return a.Add(b).Scale(s);\n}\nvar v: Point = AddAndScaleGeneric(a, w, 2.5);\n")),(0,i.kt)("p",null,"Here ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is a type whose type is ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},":!")," syntax means that ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is a\n",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"/design/generics/terminology#generic-versus-template-parameters"},"generic parameter")),". That\nmeans it must be known to the caller, but we will only use the information\npresent in the signature of the function to type check the body of\n",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric"),"'s definition. In this case, we know that any value of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"T")," implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," interface and so has an ",(0,i.kt)("inlineCode",{parentName:"p"},"Add")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"Scale")," method."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"References:")," The ",(0,i.kt)("inlineCode",{parentName:"p"},":!")," syntax was accepted in\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/pull/676"},"proposal #676"),"."),(0,i.kt)("p",null,"Names are looked up in the body of ",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric")," for values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"\nin ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),". This means that ",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric")," is interpreted as equivalent\nto adding a ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),"\n",(0,i.kt)("a",{parentName:"p",href:"#qualified-member-names-and-compound-member-access"},"qualification")," to replace\nall simple member accesses of ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn AddAndScaleGeneric[T:! Vector](a: T, b: T, s: Double) -> T {\n  return a.(Vector.Add)(b).(Vector.Scale)(s);\n}\n")),(0,i.kt)("p",null,"With these qualifications, the function can be type-checked for any ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"\nimplementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),". This type checking is equivalent to type checking the\nfunction with ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," set to an ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#archetype"},"archetype")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),".\nAn archetype is a placeholder type considered to satisfy its constraint, which\nis ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," in this case, and no more. It acts as the most general type\nsatisfying the interface. The effect of this is that an archetype of ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),"\nacts like a ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Subtyping"},"supertype")," of any ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"\nimplementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),"."),(0,i.kt)("p",null,"For name lookup purposes, an archetype is considered to have\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#internal-impl"},"implemented its constraint internally"),". The only\noddity is that the archetype may have different names for members than specific\ntypes ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," that implement interfaces from the constraint\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#external-impl"},"externally"),". This difference in names can also\noccur for supertypes in C++, for example members in a derived class can hide\nmembers in the base class with the same name, though it is not that common for\nit to come up in practice."),(0,i.kt)("p",null,"The behavior of calling ",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric")," with a value of a specific type\nlike ",(0,i.kt)("inlineCode",{parentName:"p"},"Point")," is to set ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Point")," after all the names have been qualified."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// AddAndScaleGeneric with T = Point\nfn AddAndScaleForPoint(a: Point, b: Point, s: Double) -> Point {\n  return a.(Vector.Add)(b).(Vector.Scale)(s);\n}\n")),(0,i.kt)("p",null,"This qualification gives a consistent interpretation to the body of the function\neven when the type supplied by the caller\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#external-impl"},"implements the interface externally"),", as ",(0,i.kt)("inlineCode",{parentName:"p"},"Point2"),"\ndoes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// AddAndScaleGeneric with T = Point2\nfn AddAndScaleForPoint2(a: Point2, b: Point2, s: Double) -> Point2 {\n  // \u2705 This works even though `a.Add(b).Scale(s)` wouldn't.\n  return a.(Vector.Add)(b).(Vector.Scale)(s);\n}\n")),(0,i.kt)("h3",{id:"return-type"},"Return type"),(0,i.kt)("p",null,"From the caller's perspective, the return type is the result of substituting the\ncaller's values for the generic parameters into the return type expression. So\n",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric")," called with ",(0,i.kt)("inlineCode",{parentName:"p"},"Point")," values returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"Point")," and called\nwith ",(0,i.kt)("inlineCode",{parentName:"p"},"Point2")," values returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"Point2"),". So looking up a member on the resulting\nvalue will look in ",(0,i.kt)("inlineCode",{parentName:"p"},"Point")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Point2")," rather than ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),"."),(0,i.kt)("p",null,"This is part of realizing\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/goals#path-from-regular-functions"},"the goal that generic functions can be used in place of regular functions without changing the return type that callers see"),".\nIn this example, ",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric")," can be substituted for\n",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleForPoint")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleForPoint2")," without affecting the return\ntypes. This requires the return value to be converted to the type that the\ncaller expects instead of the erased type used inside the generic function."),(0,i.kt)("p",null,"A generic caller of a generic function performs the same substitution process to\ndetermine the return type, but the result may be generic. In this example of\ncalling a generic from another generic,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn DoubleThreeTimes[U:! Vector](a: U) -> U {\n  return AddAndScaleGeneric(a, a, 2.0).Scale(2.0);\n}\n")),(0,i.kt)("p",null,"the return type of ",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric")," is found by substituting in the ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," from\n",(0,i.kt)("inlineCode",{parentName:"p"},"DoubleThreeTimes")," for the ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric")," in the return type\nexpression of ",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," is an archetype of ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),", and so\nimplements ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," internally and therefore has a ",(0,i.kt)("inlineCode",{parentName:"p"},"Scale")," method."),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," had a more specific type, the return value would have the additional\ncapabilities of ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),". For example, given a parameterized type ",(0,i.kt)("inlineCode",{parentName:"p"},"GeneralPoint"),"\nimplementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),", and a function that takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"GeneralPoint")," and calls\n",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric")," with it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class GeneralPoint(C:! Numeric) {\n  external impl as Vector { ... }\n  fn Get[me: Self](i: i32) -> C;\n}\n\nfn CallWithGeneralPoint[C:! Numeric](p: GeneralPoint(C)) -> C {\n  // `AddAndScaleGeneric` returns `T` and in these calls `T` is\n  // deduced to be `GeneralPoint(C)`.\n\n  // \u274c Illegal: AddAndScaleGeneric(p, p, 2.0).Scale(2.0);\n  //    `GeneralPoint(C)` implements `Vector` externally, and so\n  //    does not have a `Scale` method.\n\n  // \u2705 Allowed: `GeneralPoint(C)` has a `Get` method\n  AddAndScaleGeneric(p, p, 2.0).Get(0);\n\n  // \u2705 Allowed: `GeneralPoint(C)` implements `Vector`\n  //    externally, and so has a `Vector.Scale` method.\n  //    `Vector.Scale` returns `Self` which is `GeneralPoint(C)`\n  //    again, and so has a `Get` method.\n  return AddAndScaleGeneric(p, p, 2.0).(Vector.Scale)(2.0).Get(0);\n}\n")),(0,i.kt)("p",null,"The result of the call to ",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"CallWithGeneralPoint")," has\ntype ",(0,i.kt)("inlineCode",{parentName:"p"},"GeneralPoint(C)")," and so has a ",(0,i.kt)("inlineCode",{parentName:"p"},"Get")," method and a ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector.Scale")," method.\nBut, in contrast to how ",(0,i.kt)("inlineCode",{parentName:"p"},"DoubleThreeTimes")," works, since ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," is implemented\nexternally the return value in this case does not directly have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Scale"),"\nmethod."),(0,i.kt)("h3",{id:"implementation-model"},"Implementation model"),(0,i.kt)("p",null,"A possible model for generating code for a generic function is to use a\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#witness-tables"},"witness table")," to represent how a type\nimplements an interface:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#interfaces"},"Interfaces")," are types of witness tables."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#implementing-interfaces"},"Impls")," are witness table values."),(0,i.kt)("li",{parentName:"ul"},"The compiler rewrites functions with an implicit type argument\n(",(0,i.kt)("inlineCode",{parentName:"li"},"fn Foo[InterfaceName:! T](...)"),") to have an actual argument with type\ndetermined by the interface, and supplied at the callsite using a value\ndetermined by the impl.")),(0,i.kt)("p",null,"For the example above, ",(0,i.kt)("a",{parentName:"p",href:"#interfaces"},"the Vector interface")," could be thought of\ndefining a witness table type like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'class Vector {\n  // `Self` is the representation type, which is only\n  // known at compile time.\n  var Self:! Type;\n  // `fnty` is **placeholder** syntax for a "function type",\n  // so `Add` is a function that takes two `Self` parameters\n  // and returns a value of type `Self`.\n  var Add: fnty(a: Self, b: Self) -> Self;\n  var Scale: fnty(a: Self, v: f64) -> Self;\n}\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"#implementing-interfaces"},"impl of Vector for Point")," would be a value of\nthis type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var VectorForPoint: Vector  = {\n    .Self = Point,\n    // `lambda` is **placeholder** syntax for defining a\n    // function value.\n    .Add = lambda(a: Point, b: Point) -> Point {\n      return {.x = a.x + b.x, .y = a.y + b.y};\n    },\n    .Scale = lambda(a: Point, v: f64) -> Point {\n      return {.x = a.x * v, .y = a.y * v};\n    },\n};\n")),(0,i.kt)("p",null,"Finally we can define a generic function and call it, like\n",(0,i.kt)("a",{parentName:"p",href:"#generics"},(0,i.kt)("inlineCode",{parentName:"a"},"AddAndScaleGeneric"),' from the "Generics" section')," by making the\nwitness table an explicit argument to the function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn AddAndScaleGeneric\n    (t:! Vector, a: t.Self, b: t.Self, s: f64) -> t.Self {\n  return t.Scale(t.Add(a, b), s);\n}\n// Point implements Vector.\nvar v: Point = AddAndScaleGeneric(VectorForPoint, a, w, 2.5);\n")),(0,i.kt)("p",null,"The rule is that generic arguments (declared using ",(0,i.kt)("inlineCode",{parentName:"p"},":!"),") are passed at compile\ntime, so the actual value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," argument here can be used to generate the\ncode for ",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric"),". So ",(0,i.kt)("inlineCode",{parentName:"p"},"AddAndScaleGeneric")," is using a\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#static-dispatch-witness-table"},"static-dispatch witness table"),"."),(0,i.kt)("p",null,"Note that this implementation strategy only works for impls that the caller\nknows the callee needs."),(0,i.kt)("h2",{id:"interfaces-recap"},"Interfaces recap"),(0,i.kt)("p",null,"Interfaces have a name and a definition."),(0,i.kt)("p",null,"The definition of an interface consists of a set of declarations. Each\ndeclaration defines a requirement for any ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," that is in turn a capability\nthat consumers of that ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," can rely on. Typically those declarations also\nhave names, useful for both saying how the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," satisfies the requirement and\naccessing the capability."),(0,i.kt)("p",null,"Interfaces are ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#nominal-interfaces"},'"nominal"'),", which means their\nname is significant. So two interfaces with the same body definition but\ndifferent names are different, just like two classes with the same definition\nbut different names are considered different types. For example, lets say we\ndefine another interface, say ",(0,i.kt)("inlineCode",{parentName:"p"},"LegoFish"),", with the same ",(0,i.kt)("inlineCode",{parentName:"p"},"Add")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Scale")," method\nsignatures. Implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," would not imply an implementation of\n",(0,i.kt)("inlineCode",{parentName:"p"},"LegoFish"),", because the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," definition explicitly refers to the name\n",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),"."),(0,i.kt)("p",null,"An interface's name may be used in a few different contexts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"to define ",(0,i.kt)("a",{parentName:"li",href:"#implementing-interfaces"},"an ",(0,i.kt)("inlineCode",{parentName:"a"},"impl")," for a type"),","),(0,i.kt)("li",{parentName:"ul"},"as a namespace name in\n",(0,i.kt)("a",{parentName:"li",href:"#qualified-member-names-and-compound-member-access"},"a qualified name"),", and"),(0,i.kt)("li",{parentName:"ul"},"as a ",(0,i.kt)("a",{parentName:"li",href:"/design/generics/terminology#type-of-type"},"type-of-type")," for\n",(0,i.kt)("a",{parentName:"li",href:"#generics"},"a generic type parameter"),".")),(0,i.kt)("p",null,"While interfaces are examples of type-of-types, type-of-types are a more general\nconcept, for which interfaces are a building block."),(0,i.kt)("h2",{id:"type-of-types"},"Type-of-types"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#type-of-type"},"type-of-type")," consists of a set of requirements\nand a set of names. Requirements are typically a set of interfaces that a type\nmust satisfy, though other kinds of requirements are added below. The names are\naliases for qualified names in those interfaces."),(0,i.kt)("p",null,"An interface is one particularly simple example of a type-of-type. For example,\n",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," as a type-of-type has a set of requirements consisting of the single\ninterface ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),". Its set of names consists of ",(0,i.kt)("inlineCode",{parentName:"p"},"Add")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Scale")," which are\naliases for the corresponding qualified names inside ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," as a namespace."),(0,i.kt)("p",null,"The requirements determine which types are values of a given type-of-type. The\nset of names in a type-of-type determines the API of a generic type value and\ndefine the result of ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/member_access.md"},"member access"),"\ninto the type-of-type."),(0,i.kt)("p",null,"This general structure of type-of-types holds not just for interfaces, but\nothers described in the rest of this document."),(0,i.kt)("h2",{id:"named-constraints"},"Named constraints"),(0,i.kt)("p",null,"If the interfaces discussed above are the building blocks for type-of-types,\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#named-constraints"},"generic named constraints")," describe how they\nmay be composed together. Unlike interfaces which are nominal, the name of a\nnamed constraint is not a part of its value. Two different named constraints\nwith the same definition are equivalent even if they have different names. This\nis because types don't explicitly specify which named constraints they\nimplement, types automatically implement any named constraints they can satisfy."),(0,i.kt)("p",null,"A named constraint definition can contain interface requirements using ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),"\ndeclarations and names using ",(0,i.kt)("inlineCode",{parentName:"p"},"alias")," declarations. Note that this allows us to\ndeclare the aspects of a type-of-type directly."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"constraint VectorLegoFish {\n  // Interface implementation requirements\n  impl as Vector;\n  impl as LegoFish;\n  // Names\n  alias Scale = Vector.Scale;\n  alias VAdd = Vector.Add;\n  alias LFAdd = LegoFish.Add;\n}\n")),(0,i.kt)("p",null,"We don't expect developers to directly define many named constraints, but other\nconstructs we do expect them to use will be defined in terms of them. For\nexample, we can define the Carbon builtin ",(0,i.kt)("inlineCode",{parentName:"p"},"Type")," as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"constraint Type { }\n")),(0,i.kt)("p",null,"That is, ",(0,i.kt)("inlineCode",{parentName:"p"},"Type")," is the type-of-type with no requirements (so matches every\ntype), and defines no names."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'fn Identity[T:! Type](x: T) -> T {\n  // Can accept values of any type. But, since we know nothing about the\n  // type, we don\'t know about any operations on `x` inside this function.\n  return x;\n}\n\nvar i: i32 = Identity(3);\nvar s: String = Identity("string");\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Aside:")," We can define ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," as syntactic sugar for ",(0,i.kt)("inlineCode",{parentName:"p"},"(template _:! Type)"),".\nThis definition allows you to use ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," as the type for a local variable whose\ntype can be statically determined by the compiler. It also allows you to use\n",(0,i.kt)("inlineCode",{parentName:"p"},"auto"),' as the type of a function parameter, to mean "accepts a value of any\ntype, and this function will be instantiated separately for every different\ntype." This is consistent with the\n',(0,i.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/function_template#Abbreviated_function_template"},"use of ",(0,i.kt)("inlineCode",{parentName:"a"},"auto")," in the C++20 Abbreviated function template feature"),"."),(0,i.kt)("p",null,"In general, the declarations in ",(0,i.kt)("inlineCode",{parentName:"p"},"constraint")," definition match a subset of the\ndeclarations in an ",(0,i.kt)("inlineCode",{parentName:"p"},"interface"),". Named constraints used with generics, as opposed\nto templates, should only include required interfaces and aliases to named\nmembers of those interfaces."),(0,i.kt)("p",null,"To declare a named constraint that includes other declarations for use with\ntemplate parameters, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"template")," keyword before ",(0,i.kt)("inlineCode",{parentName:"p"},"constraint"),". Method,\nassociated type, and associated function requirements may only be declared\ninside a ",(0,i.kt)("inlineCode",{parentName:"p"},"template constraint"),". Note that a generic constraint ignores the names\nof members defined for a type, but a template constraint can depend on them."),(0,i.kt)("p",null,"There is an analogy between declarations used in a ",(0,i.kt)("inlineCode",{parentName:"p"},"constraint")," and in an\n",(0,i.kt)("inlineCode",{parentName:"p"},"interface")," definition. If an ",(0,i.kt)("inlineCode",{parentName:"p"},"interface")," ",(0,i.kt)("inlineCode",{parentName:"p"},"I")," has (non-",(0,i.kt)("inlineCode",{parentName:"p"},"alias"),") declarations\n",(0,i.kt)("inlineCode",{parentName:"p"},"X"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Y"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Z"),", like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface I {\n  X;\n  Y;\n  Z;\n}\n")),(0,i.kt)("p",null,"Then a type implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"I")," would have ",(0,i.kt)("inlineCode",{parentName:"p"},"impl as I")," with definitions for ",(0,i.kt)("inlineCode",{parentName:"p"},"X"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"Y"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Z"),", as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class ImplementsI {\n  // ...\n  impl as I {\n    X { ... }\n    Y { ... }\n    Z { ... }\n  }\n}\n")),(0,i.kt)("p",null,"But the corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"constraint")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"template constraint"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// or template constraint S {\nconstraint S {\n  X;\n  Y;\n  Z;\n}\n")),(0,i.kt)("p",null,"would match any type with definitions for ",(0,i.kt)("inlineCode",{parentName:"p"},"X"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Y"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Z")," directly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class ImplementsS {\n  // ...\n  X { ... }\n  Y { ... }\n  Z { ... }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"TODO:")," Move the ",(0,i.kt)("inlineCode",{parentName:"p"},"template constraint")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," content to the template\ndesign document, once it exists."),(0,i.kt)("h3",{id:"subtyping-between-type-of-types"},"Subtyping between type-of-types"),(0,i.kt)("p",null,"There is a subtyping relationship between type-of-types that allows calls of one\ngeneric function from another as long as it has a subset of the requirements."),(0,i.kt)("p",null,"Given a generic type variable ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," with type-of-type ",(0,i.kt)("inlineCode",{parentName:"p"},"I1"),", it satisfies a\ntype-of-type ",(0,i.kt)("inlineCode",{parentName:"p"},"I2")," as long as the requirements of ",(0,i.kt)("inlineCode",{parentName:"p"},"I1")," are a superset of the\nrequirements of ",(0,i.kt)("inlineCode",{parentName:"p"},"I2"),". This means a value ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," may be passed to\nfunctions requiring types to satisfy ",(0,i.kt)("inlineCode",{parentName:"p"},"I2"),", as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Printable { fn Print[me: Self](); }\ninterface Renderable { fn Draw[me: Self](); }\n\nconstraint PrintAndRender {\n  impl as Printable;\n  impl as Renderable;\n}\nconstraint JustPrint {\n  impl as Printable;\n}\n\nfn PrintIt[T2:! JustPrint](x2: T2) {\n  x2.(Printable.Print)();\n}\nfn PrintDrawPrint[T1:! PrintAndRender](x1: T1) {\n  // x1 implements `Printable` and `Renderable`.\n  x1.(Printable.Print)();\n  x1.(Renderable.Draw)();\n  // Can call `PrintIt` since `T1` satisfies `JustPrint` since\n  // it implements `Printable` (in addition to `Renderable`).\n  PrintIt(x1);\n}\n")),(0,i.kt)("h2",{id:"combining-interfaces-by-anding-type-of-types"},"Combining interfaces by anding type-of-types"),(0,i.kt)("p",null,"In order to support functions that require more than one interface to be\nimplemented, we provide a combination operator on type-of-types, written ",(0,i.kt)("inlineCode",{parentName:"p"},"&"),".\nThis operator gives the type-of-type with the union of all the requirements and\nthe union of the names minus any conflicts."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Printable {\n  fn Print[me: Self]();\n}\ninterface Renderable {\n  fn Center[me: Self]() -> (i32, i32);\n  fn Draw[me: Self]();\n}\n\n// `Printable & Renderable` is syntactic sugar for this type-of-type:\nconstraint {\n  impl as Printable;\n  impl as Renderable;\n  alias Print = Printable.Print;\n  alias Center = Renderable.Center;\n  alias Draw = Renderable.Draw;\n}\n\nfn PrintThenDraw[T:! Printable & Renderable](x: T) {\n  // Can use methods of `Printable` or `Renderable` on `x` here.\n  x.Print();  // Same as `x.(Printable.Print)();`.\n  x.Draw();  // Same as `x.(Renderable.Draw)();`.\n}\n\nclass Sprite {\n  // ...\n  impl as Printable {\n    fn Print[me: Self]() { ... }\n  }\n  impl as Renderable {\n    fn Center[me: Self]() -> (i32, i32) { ... }\n    fn Draw[me: Self]() { ... }\n  }\n}\n\nvar s: Sprite = ...;\nPrintThenDraw(s);\n")),(0,i.kt)("p",null,"Any conflicting names between the two types are replaced with a name that is an\nerror to use."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'interface Renderable {\n  fn Center[me: Self]() -> (i32, i32);\n  fn Draw[me: Self]();\n}\ninterface EndOfGame {\n  fn Draw[me: Self]();\n  fn Winner[me: Self](player: i32);\n}\n// `Renderable & EndOfGame` is syntactic sugar for this type-of-type:\nconstraint {\n  impl as Renderable;\n  impl as EndOfGame;\n  alias Center = Renderable.Center;\n  // Open question: `forbidden`, `invalid`, or something else?\n  forbidden Draw\n    message "Ambiguous, use either `(Renderable.Draw)` or `(EndOfGame.Draw)`.";\n  alias Winner = EndOfGame.Winner;\n}\n')),(0,i.kt)("p",null,"Conflicts can be resolved at the call site using a\n",(0,i.kt)("a",{parentName:"p",href:"#qualified-member-names-and-compound-member-access"},"qualified member access expression"),",\nor by defining a named constraint explicitly and renaming the methods:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"constraint RenderableAndEndOfGame {\n  impl as Renderable;\n  impl as EndOfGame;\n  alias Center = Renderable.Center;\n  alias RenderableDraw = Renderable.Draw;\n  alias TieGame = EndOfGame.Draw;\n  alias Winner = EndOfGame.Winner;\n}\n\nfn RenderTieGame[T:! RenderableAndEndOfGame](x: T) {\n  // Calls Renderable.Draw()\n  x.RenderableDraw();\n  // Calls EndOfGame.Draw()\n  x.TieGame();\n}\n")),(0,i.kt)("p",null,"Reserving the name when there is a conflict is part of resolving what happens\nwhen you combine more than two type-of-types. If ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is forbidden in ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),", it is\nforbidden in ",(0,i.kt)("inlineCode",{parentName:"p"},"A & B"),", whether or not ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," defines the name ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),". This makes ",(0,i.kt)("inlineCode",{parentName:"p"},"&"),"\nassociative and commutative, and so it is well defined on sets of interfaces, or\nother type-of-types, independent of order."),(0,i.kt)("p",null,"Note that we do ",(0,i.kt)("em",{parentName:"p"},"not")," consider two type-of-types using the same name to mean the\nsame thing to be a conflict. For example, combining a type-of-type with itself\ngives itself, ",(0,i.kt)("inlineCode",{parentName:"p"},"MyTypeOfType & MyTypeOfType == MyTypeOfType"),". Also, given two\n",(0,i.kt)("a",{parentName:"p",href:"#interface-extension"},"interface extensions")," of a common base interface, the sum\nshould not conflict on any names in the common base."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Rejected alternative:")," Instead of using ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," as the combining operator, we\nconsidered using ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/rfcs/0087-trait-bounds-with-plus.html"},"like Rust"),".\nSee ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/531"},"#531")," for the\ndiscussion."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Future work:")," We may want to define another operator on type-of-types for\nadding requirements to a type-of-type without affecting the names, and so avoid\nthe possibility of name conflicts. Note this means the operation is not\ncommutative. If we call this operator ",(0,i.kt)("inlineCode",{parentName:"p"},"[&]"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"A [&] B")," has the names of ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"B [&] A")," has the names of ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// `Printable [&] Renderable` is syntactic sugar for this type-of-type:\nconstraint {\n  impl as Printable;\n  impl as Renderable;\n  alias Print = Printable.Print;\n}\n\n// `Renderable [&] EndOfGame` is syntactic sugar for this type-of-type:\nconstraint {\n  impl as Renderable;\n  impl as EndOfGame;\n  alias Center = Renderable.Center;\n  alias Draw = Renderable.Draw;\n}\n")),(0,i.kt)("p",null,"Note that all three expressions ",(0,i.kt)("inlineCode",{parentName:"p"},"A & B"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"A [&] B"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"B [&] A")," have the same\nrequirements, and so you would be able to switch a function declaration between\nthem without affecting callers."),(0,i.kt)("p",null,"Nothing in this design depends on the ",(0,i.kt)("inlineCode",{parentName:"p"},"[&]")," operator, and having both ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"[&]")," might be confusing for users, so it makes sense to postpone implementing\n",(0,i.kt)("inlineCode",{parentName:"p"},"[&]")," until we have a demonstrated need. The ",(0,i.kt)("inlineCode",{parentName:"p"},"[&]")," operator seems most useful\nfor adding requirements for interfaces used for\n",(0,i.kt)("a",{parentName:"p",href:"#operator-overloading"},"operator overloading"),", where merely implementing the\ninterface is enough to be able to use the operator to access the functionality."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Alternatives considered:")," See\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.google.com/document/d/1u_i_s31OMI_apPur7WmVxcYq6MUXsG3oCiKwH893GRI/edit?usp=sharing&resourcekey=0-0lzSNebBMtUBi4lStL825g"},"Carbon: Access to interface methods"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," This ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," operation on interfaces works very\nsimilarly to Rust's ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," operation, with the main difference being how you\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/rust-by-example/trait/disambiguating.html"},"qualify names when there is a conflict"),"."),(0,i.kt)("h2",{id:"interface-requiring-other-interfaces"},"Interface requiring other interfaces"),(0,i.kt)("p",null,"Some interfaces will depend on other interfaces being implemented for the same\ntype. For example, in C++,\n",(0,i.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/named_req/Container#Other_requirements"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"Container")," concept"),"\nrequires all containers to also satisfy the requirements of\n",(0,i.kt)("inlineCode",{parentName:"p"},"DefaultConstructible"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"CopyConstructible"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"EqualityComparable"),", and\n",(0,i.kt)("inlineCode",{parentName:"p"},"Swappable"),". This is already a capability for\n",(0,i.kt)("a",{parentName:"p",href:"#type-of-types"},"type-of-types in general"),". For consistency we will use the same\nsemantics and syntax as we do for ",(0,i.kt)("a",{parentName:"p",href:"#named-constraints"},"named constraints"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Equatable { fn Equals[me: Self](rhs: Self) -> bool; }\n\ninterface Iterable {\n  fn Advance[addr me: Self*]() -> bool;\n  impl as Equatable;\n}\n\ndef DoAdvanceAndEquals[T:! Iterable](x: T) {\n  // `x` has type `T` that implements `Iterable`, and so has `Advance`.\n  x.Advance();\n  // `Iterable` requires an implementation of `Equatable`,\n  // so `T` also implements `Equatable`.\n  x.(Equatable.Equals)(x);\n}\n\nclass Iota {\n  impl as Iterable { fn Advance[me: Self]() { ... } }\n  impl as Equatable { fn Equals[me: Self](rhs: Self) -> bool { ... } }\n}\nvar x: Iota;\nDoAdvanceAndEquals(x);\n")),(0,i.kt)("p",null,"Like with named constraints, an interface implementation requirement doesn't by\nitself add any names to the interface, but again those can be added with ",(0,i.kt)("inlineCode",{parentName:"p"},"alias"),"\ndeclarations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Hashable {\n  fn Hash[me: Self]() -> u64;\n  impl as Equatable;\n  alias Equals = Equatable.Equals;\n}\n\ndef DoHashAndEquals[T:! Hashable](x: T) {\n  // Now both `Hash` and `Equals` are available directly:\n  x.Hash();\n  x.Equals(x);\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:"),"\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait"},'This feature is called "Supertraits" in Rust'),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," The design for this feature is continued in\n",(0,i.kt)("a",{parentName:"p",href:"#interface-requiring-other-interfaces-revisited"},"a later section"),"."),(0,i.kt)("h3",{id:"interface-extension"},"Interface extension"),(0,i.kt)("p",null,"When implementing an interface, we should allow implementing the aliased names\nas well. In the case of ",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable")," above, this includes all the members of\n",(0,i.kt)("inlineCode",{parentName:"p"},"Equatable"),", obviating the need to implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Equatable")," itself:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Song {\n  impl as Hashable {\n    fn Hash[me: Self]() -> u64 { ... }\n    fn Equals[me: Self](rhs: Self) -> bool { ... }\n  }\n}\nvar y: Song;\nDoHashAndEquals(y);\n")),(0,i.kt)("p",null,"This allows us to say that ",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable"),"\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#extending-an-interface"},'"extends"')," ",(0,i.kt)("inlineCode",{parentName:"p"},"Equatable"),", with some\nbenefits:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This allows ",(0,i.kt)("inlineCode",{parentName:"li"},"Equatable")," to be an implementation detail of ",(0,i.kt)("inlineCode",{parentName:"li"},"Hashable"),"."),(0,i.kt)("li",{parentName:"ul"},"This allows types implementing ",(0,i.kt)("inlineCode",{parentName:"li"},"Hashable")," to implement all of its API in one\nplace."),(0,i.kt)("li",{parentName:"ul"},"This reduces the boilerplate for types implementing ",(0,i.kt)("inlineCode",{parentName:"li"},"Hashable"),".")),(0,i.kt)("p",null,"We expect this concept to be common enough to warrant dedicated syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Equatable { fn Equals[me: Self](rhs: Self) -> bool; }\n\ninterface Hashable {\n  extends Equatable;\n  fn Hash[me: Self]() -> u64;\n}\n// is equivalent to the definition of Hashable from before:\n// interface Hashable {\n//   impl as Equatable;\n//   alias Equals = Equatable.Equals;\n//   fn Hash[me: Self]() -> u64;\n// }\n")),(0,i.kt)("p",null,"No names in ",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable")," are allowed to conflict with names in ",(0,i.kt)("inlineCode",{parentName:"p"},"Equatable")," (unless\nthose names are marked as ",(0,i.kt)("inlineCode",{parentName:"p"},"upcoming")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"deprecated")," as in\n",(0,i.kt)("a",{parentName:"p",href:"#evolution"},"evolution future work"),"). Hopefully this won't be a problem in\npractice, since interface extension is a very closely coupled relationship, but\nthis may be something we will have to revisit in the future."),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The C++\n",(0,i.kt)("a",{parentName:"li",href:"https://www.boost.org/doc/libs/1_74_0/libs/graph/doc/"},"Boost.Graph library"),(0,i.kt)("a",{parentName:"li",href:"https://www.boost.org/doc/libs/1_74_0/libs/graph/doc/graph_concepts.html#fig:graph-concepts"},"graph concepts"),"\nhas many refining relationships between concepts.\n",(0,i.kt)("a",{parentName:"li",href:"https://docs.google.com/document/d/1xk0GLtpBl2OOnf3F_6Z-A3DtTt-r7wdOZ5wPipYUSO0/edit?usp=sharing&resourcekey=0-mBSmwn6b6jwbLaQw2WG6OA"},"Carbon generics use case: graph library"),"\nshows how those concepts might be translated into Carbon interfaces."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("a",{parentName:"li",href:"https://en.cppreference.com/w/cpp/named_req"},"C++ concepts")," for\ncontainers, iterators, and concurrency include many requirement\nrelationships."),(0,i.kt)("li",{parentName:"ul"},"Swift protocols, such as\n",(0,i.kt)("a",{parentName:"li",href:"https://developer.apple.com/documentation/swift/collection"},"Collection"),".")),(0,i.kt)("p",null,"To write an interface extending multiple interfaces, use multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"extends"),"\ndeclarations. For example, the\n",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/swift/binaryinteger"},(0,i.kt)("inlineCode",{parentName:"a"},"BinaryInteger")," protocol in Swift"),"\ninherits from ",(0,i.kt)("inlineCode",{parentName:"p"},"CustomStringConvertible"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Numeric"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Stridable"),".\nThe ",(0,i.kt)("a",{parentName:"p",href:"https://swiftdoc.org/v5.1/protocol/setalgebra/"},(0,i.kt)("inlineCode",{parentName:"a"},"SetAlgebra")," protocol"),"\nextends ",(0,i.kt)("inlineCode",{parentName:"p"},"Equatable")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ExpressibleByArrayLiteral"),", which would be declared in\nCarbon:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface SetAlgebra {\n  extends Equatable;\n  extends ExpressibleByArrayLiteral;\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Alternative considered:")," The ",(0,i.kt)("inlineCode",{parentName:"p"},"extends")," declarations are in the body of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"interface")," definition instead of the header so we can use\n",(0,i.kt)("a",{parentName:"p",href:"#associated-types"},"associated types (defined below)")," also defined in the body\nin parameters or constraints of the interface being extended."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// A type can implement `ConvertibleTo` many times, using\n// different values of `T`.\ninterface ConvertibleTo(T:! Type) { ... }\n\n// A type can only implement `PreferredConversion` once.\ninterface PreferredConversion {\n  let AssociatedType:! Type;\n  extends ConvertibleTo(AssociatedType);\n}\n")),(0,i.kt)("h4",{id:"extends-and-impl-with-named-constraints"},(0,i.kt)("inlineCode",{parentName:"h4"},"extends")," and ",(0,i.kt)("inlineCode",{parentName:"h4"},"impl")," with named constraints"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"extends")," declaration makes sense with the same meaning inside a\n",(0,i.kt)("a",{parentName:"p",href:"#named-constraints"},(0,i.kt)("inlineCode",{parentName:"a"},"constraint"))," definition, and so is also supported."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Media {\n  fn Play[me: Self]();\n}\ninterface Job {\n  fn Run[me: Self]();\n}\n\nconstraint Combined {\n  extends Media;\n  extends Job;\n}\n")),(0,i.kt)("p",null,"This definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"Combined")," is equivalent to requiring both the ",(0,i.kt)("inlineCode",{parentName:"p"},"Media")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"Job")," interfaces being implemented, and aliases their methods."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Equivalent\nconstraint Combined {\n  impl as Media;\n  alias Play = Media.Play;\n  impl as Job;\n  alias Run = Job.Run;\n}\n")),(0,i.kt)("p",null,"Notice how ",(0,i.kt)("inlineCode",{parentName:"p"},"Combined")," has aliases for all the methods in the interfaces it\nrequires. That condition is sufficient to allow a type to ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," the named\nconstraint:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Song {\n  impl as Combined {\n    fn Play[me: Self]() { ... }\n    fn Run[me: Self]() { ... }\n  }\n}\n")),(0,i.kt)("p",null,"This is equivalent to implementing the required interfaces directly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Song {\n  impl as Media {\n    fn Play[me: Self]() { ... }\n  }\n  impl as Job {\n    fn Run[me: Self]() { ... }\n  }\n}\n")),(0,i.kt)("p",null,"This is just like when you get an implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Equatable")," by implementing\n",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable")," when ",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable")," extends ",(0,i.kt)("inlineCode",{parentName:"p"},"Equatable"),". This provides a tool useful for\n",(0,i.kt)("a",{parentName:"p",href:"#evolution"},"evolution"),"."),(0,i.kt)("p",null,"Conversely, an ",(0,i.kt)("inlineCode",{parentName:"p"},"interface")," can extend a ",(0,i.kt)("inlineCode",{parentName:"p"},"constraint"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface MovieCodec {\n  extends Combined;\n\n  fn Load[addr me: Self*](filename: String);\n}\n")),(0,i.kt)("p",null,"This gives ",(0,i.kt)("inlineCode",{parentName:"p"},"MovieCodec")," the same requirements and names as ",(0,i.kt)("inlineCode",{parentName:"p"},"Combined"),", and so is\nequivalent to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface MovieCodec {\n  impl as Media;\n  alias Play = Media.Play;\n  impl as Job;\n  alias Run = Job.Run;\n\n  fn Load[addr me: Self*](filename: String);\n}\n")),(0,i.kt)("h4",{id:"diamond-dependency-issue"},"Diamond dependency issue"),(0,i.kt)("p",null,"Consider this set of interfaces, simplified from\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.google.com/document/d/1xk0GLtpBl2OOnf3F_6Z-A3DtTt-r7wdOZ5wPipYUSO0/edit?resourcekey=0-mBSmwn6b6jwbLaQw2WG6OA#"},"this example generic graph library doc"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Graph {\n  fn Source[addr me: Self*](e: EdgeDescriptor) -> VertexDescriptor;\n  fn Target[addr me: Self*](e: EdgeDescriptor) -> VertexDescriptor;\n}\n\ninterface IncidenceGraph {\n  extends Graph;\n  fn OutEdges[addr me: Self*](u: VertexDescriptor)\n    -> (EdgeIterator, EdgeIterator);\n}\n\ninterface EdgeListGraph {\n  extends Graph;\n  fn Edges[addr me: Self*]() -> (EdgeIterator, EdgeIterator);\n}\n")),(0,i.kt)("p",null,"We need to specify what happens when a graph type implements both\n",(0,i.kt)("inlineCode",{parentName:"p"},"IncidenceGraph")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"EdgeListGraph"),", since both interfaces extend the ",(0,i.kt)("inlineCode",{parentName:"p"},"Graph"),"\ninterface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class MyEdgeListIncidenceGraph {\n  impl as IncidenceGraph { ... }\n  impl as EdgeListGraph { ... }\n}\n")),(0,i.kt)("p",null,"The rule is that we need one definition of each method of ",(0,i.kt)("inlineCode",{parentName:"p"},"Graph"),". Each method\nthough could be defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," block of ",(0,i.kt)("inlineCode",{parentName:"p"},"IncidenceGraph"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"EdgeListGraph"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"Graph"),". These would all be valid:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"IncidenceGraph")," implements all methods of ",(0,i.kt)("inlineCode",{parentName:"p"},"Graph"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"EdgeListGraph"),"\nimplements none of them."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"class MyEdgeListIncidenceGraph {\n  impl as IncidenceGraph {\n    fn Source[me: Self](e: EdgeDescriptor) -> VertexDescriptor { ... }\n    fn Target[me: Self](e: EdgeDescriptor) -> VertexDescriptor { ... }\n    fn OutEdges[addr me: Self*](u: VertexDescriptor)\n        -> (EdgeIterator, EdgeIterator) { ... }\n  }\n  impl as EdgeListGraph {\n    fn Edges[addr me: Self*]() -> (EdgeIterator, EdgeIterator) { ... }\n  }\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"IncidenceGraph")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"EdgeListGraph")," implement all methods of ",(0,i.kt)("inlineCode",{parentName:"p"},"Graph"),"\nbetween them, but with no overlap."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"class MyEdgeListIncidenceGraph {\n  impl as IncidenceGraph {\n    fn Source[me: Self](e: EdgeDescriptor) -> VertexDescriptor { ... }\n    fn OutEdges[addr me: Self*](u: VertexDescriptor)\n        -> (EdgeIterator, EdgeIterator) { ... }\n  }\n  impl as EdgeListGraph {\n    fn Target[me: Self](e: EdgeDescriptor) -> VertexDescriptor { ... }\n    fn Edges[addr me: Self*]() -> (EdgeIterator, EdgeIterator) { ... }\n  }\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Explicitly implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Graph"),"."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"class MyEdgeListIncidenceGraph {\n  impl as Graph {\n    fn Source[me: Self](e: EdgeDescriptor) -> VertexDescriptor { ... }\n    fn Target[me: Self](e: EdgeDescriptor) -> VertexDescriptor { ... }\n  }\n  impl as IncidenceGraph { ... }\n  impl as EdgeListGraph { ... }\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Graph")," externally."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"class MyEdgeListIncidenceGraph {\n  impl as IncidenceGraph { ... }\n  impl as EdgeListGraph { ... }\n}\nexternal impl MyEdgeListIncidenceGraph as Graph {\n  fn Source[me: Self](e: EdgeDescriptor) -> VertexDescriptor { ... }\n  fn Target[me: Self](e: EdgeDescriptor) -> VertexDescriptor { ... }\n}\n")))),(0,i.kt)("p",null,"This last point means that there are situations where we can only detect a\nmissing method definition by the end of the file. This doesn't delay other\naspects of semantic checking, which will just assume that these methods will\neventually be provided."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," We could require that the ",(0,i.kt)("inlineCode",{parentName:"p"},"external impl")," of the required\ninterface be declared lexically in the class scope in this case. That would\nallow earlier detection of missing definitions."),(0,i.kt)("h3",{id:"use-case-overload-resolution"},"Use case: overload resolution"),(0,i.kt)("p",null,"Implementing an extended interface is an example of a more specific match for\n",(0,i.kt)("a",{parentName:"p",href:"#lookup-resolution-and-specialization"},"lookup resolution"),". For example, this\ncould be used to provide different implementations of an algorithm depending on\nthe capabilities of the iterator being passed in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface ForwardIntIterator {\n  fn Advance[addr me: Self*]();\n  fn Get[me: Self]() -> i32;\n}\ninterface BidirectionalIntIterator {\n  extends ForwardIntIterator;\n  fn Back[addr me: Self*]();\n}\ninterface RandomAccessIntIterator {\n  extends BidirectionalIntIterator;\n  fn Skip[addr me: Self*](offset: i32);\n  fn Difference[me: Self](rhs: Self) -> i32;\n}\n\nfn SearchInSortedList[IterT:! ForwardIntIterator]\n    (begin: IterT, end: IterT, needle: i32) -> bool {\n  ... // does linear search\n}\n// Will prefer the following overload when it matches\n// since it is more specific.\nfn SearchInSortedList[IterT:! RandomAccessIntIterator]\n    (begin: IterT, end: IterT, needle: i32) -> bool {\n  ... // does binary search\n}\n")),(0,i.kt)("p",null,"This would be an example of the more general rule that an interface ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),"\nrequiring an implementation of interface ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," means ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," is more specific than\n",(0,i.kt)("inlineCode",{parentName:"p"},"B"),"."),(0,i.kt)("h2",{id:"adapting-types"},"Adapting types"),(0,i.kt)("p",null,"Since interfaces may only be implemented for a type once, and we limit where\nimplementations may be added to a type, there is a need to allow the user to\nswitch the type of a value to access different interface implementations. Carbon\ntherefore provides a way to create new types\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#compatible-types"},"compatible with")," existing types with different\nAPIs, in particular with different interface implementations, by\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#adapting-a-type"},"adapting")," them:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Printable {\n  fn Print[me: Self]();\n}\ninterface Comparable {\n  fn Less[me: Self](rhs: Self) -> bool;\n}\nclass Song {\n  impl as Printable { fn Print[me: Self]() { ... } }\n}\nadapter SongByTitle for Song {\n  impl as Comparable {\n    fn Less[me: Self](rhs: Self) -> bool { ... }\n  }\n}\nadapter FormattedSong for Song {\n  impl as Printable { fn Print[me: Self]() { ... } }\n}\nadapter FormattedSongByTitle for Song {\n  impl as Printable = FormattedSong;\n  impl as Comparable = SongByTitle;\n}\n")),(0,i.kt)("p",null,"This allows developers to provide implementations of new interfaces (as in\n",(0,i.kt)("inlineCode",{parentName:"p"},"SongByTitle"),"), provide different implementations of the same interface (as in\n",(0,i.kt)("inlineCode",{parentName:"p"},"FormattedSong"),"), or mix and match implementations from other compatible types\n(as in ",(0,i.kt)("inlineCode",{parentName:"p"},"FormattedSongByTitle"),"). The rules are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You can add any declaration that you could add to a class except for\ndeclarations that would change the representation of the type. This means\nyou can add methods, functions, interface implementations, and aliases, but\nnot fields, base classes, or virtual functions."),(0,i.kt)("li",{parentName:"ul"},"The adapted type is compatible with the original type, and that relationship\nis an equivalence class, so all of ",(0,i.kt)("inlineCode",{parentName:"li"},"Song"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"SongByTitle"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"FormattedSong"),",\nand ",(0,i.kt)("inlineCode",{parentName:"li"},"FormattedSongByTitle")," end up compatible with each other."),(0,i.kt)("li",{parentName:"ul"},"Since adapted types are compatible with the original type, you may\nexplicitly cast between them, but there is no implicit conversion between\nthese types.")),(0,i.kt)("p",null,"Inside an adapter, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," type matches the adapter. Members of the original\ntype may be accessed either by a cast:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"adapter SongByTitle for Song {\n  impl as Comparable {\n    fn Less[me: Self](rhs: Self) -> bool {\n      return (me as Song).Title() < (rhs as Song).Title();\n    }\n  }\n}\n")),(0,i.kt)("p",null,"or using a qualified member access expression:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"adapter SongByTitle for Song {\n  impl as Comparable {\n    fn Less[me: Self](rhs: Self) -> bool {\n      return me.(Song.Title)() < rhs.(Song.Title)();\n    }\n  }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:"),' This matches the Rust idiom called\n"newtype", which is used to implement traits on types while avoiding coherence\nproblems, see\n',(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types"},"here"),"\nand\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Ixrec/rust-orphan-rules#user-content-why-are-the-orphan-rules-controversial"},"here"),".\nRust's mechanism doesn't directly support reusing implementations, though some\nof that is provided by macros defined in libraries. Haskell has a\n",(0,i.kt)("a",{parentName:"p",href:"https://wiki.haskell.org/Newtype"},(0,i.kt)("inlineCode",{parentName:"a"},"newtype")," feature")," as well. Haskell's feature\ndoesn't directly support reusing implementations either, but the most popular\ncompiler provides it as\n",(0,i.kt)("a",{parentName:"p",href:"https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/newtype_deriving.html"},"an extension"),"."),(0,i.kt)("h3",{id:"adapter-compatibility"},"Adapter compatibility"),(0,i.kt)("p",null,"Consider a type with a generic type parameter, like a hash map:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Hashable { ... }\nclass HashMap(KeyT:! Hashable, ValueT:! Type) {\n  fn Find[me:Self](key: KeyT) -> Optional(ValueT);\n  // ...\n}\n")),(0,i.kt)("p",null,"A user of this type will provide specific values for the key and value types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'class Song {\n  impl as Hashable { ... }\n  // ...\n}\n\nvar play_count: HashMap(Song, i32) = ...;\nvar thriller_count: Optional(i32) =\n    play_count.Find(Song("Thriller"));\n')),(0,i.kt)("p",null,"Since the ",(0,i.kt)("inlineCode",{parentName:"p"},"Find")," function is generic, it can only use the capabilities that\n",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap")," requires of ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyT")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ValueT"),". This allows us to evaluate when we\ncan convert between two different arguments to a parameterized type. Consider\ntwo adapters of ",(0,i.kt)("inlineCode",{parentName:"p"},"Song")," that implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"adapter PlayableSong for Song {\n  impl as Hashable = Song;\n  impl as Media { ... }\n}\nadapter SongHashedByTitle for Song {\n  impl as Hashable { ... }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Song")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PlayableSong")," have the same implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable")," in addition\nto using the same data representation. This means that it is safe to convert\nbetween ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap(Song, i32)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap(PlayableSong, i32)"),", because the\nimplementation of all the methods will use the same implementation of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable")," interface. Carbon permits this conversion with an explicit cast."),(0,i.kt)("p",null,"On the other hand, ",(0,i.kt)("inlineCode",{parentName:"p"},"SongHashedByTitle")," has a different implementation of\n",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable")," than ",(0,i.kt)("inlineCode",{parentName:"p"},"Song"),". So even though ",(0,i.kt)("inlineCode",{parentName:"p"},"Song")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"SongHashedByTitle")," are\ncompatible types, ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap(Song, i32)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap(SongHashedByTitle, i32)")," are\nincompatible. This is important because we know that in practice the invariants\nof a ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap")," implementation rely on the hashing function staying the same."),(0,i.kt)("h3",{id:"extending-adapter"},"Extending adapter"),(0,i.kt)("p",null,"Frequently we expect that the adapter type will want to preserve most or all of\nthe API of the original type. The two most common cases expected are adding and\nreplacing an interface implementation. Users would indicate that an adapter\nstarts from the original type's existing API by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"extends")," keyword\ninstead of ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Song {\n  impl as Hashable { ... }\n  impl as Printable { ... }\n}\n\nadapter SongByArtist extends Song {\n  // Add an implementation of a new interface\n  impl as Comparable { ... }\n\n  // Replace an existing implementation of an interface\n  // with an alternative.\n  impl as Hashable { ... }\n}\n")),(0,i.kt)("p",null,"The resulting type ",(0,i.kt)("inlineCode",{parentName:"p"},"SongByArtist")," would:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"implement ",(0,i.kt)("inlineCode",{parentName:"li"},"Comparable"),", unlike ",(0,i.kt)("inlineCode",{parentName:"li"},"Song"),","),(0,i.kt)("li",{parentName:"ul"},"implement ",(0,i.kt)("inlineCode",{parentName:"li"},"Hashable"),", but differently than ",(0,i.kt)("inlineCode",{parentName:"li"},"Song"),", and"),(0,i.kt)("li",{parentName:"ul"},"implement ",(0,i.kt)("inlineCode",{parentName:"li"},"Printable"),", inherited from ",(0,i.kt)("inlineCode",{parentName:"li"},"Song"),".")),(0,i.kt)("p",null,"Unlike the similar ",(0,i.kt)("inlineCode",{parentName:"p"},"class B extends A")," notation, ",(0,i.kt)("inlineCode",{parentName:"p"},"adapter B extends A")," is\npermitted even if ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," is a final class. Also, there is no implicit conversion\nfrom ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),", matching ",(0,i.kt)("inlineCode",{parentName:"p"},"adapter"),"...",(0,i.kt)("inlineCode",{parentName:"p"},"for")," but unlike class extension."),(0,i.kt)("p",null,"To avoid or resolve name conflicts between interfaces, an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," may be declared\n",(0,i.kt)("a",{parentName:"p",href:"#external-impl"},(0,i.kt)("inlineCode",{parentName:"a"},"external")),". The names in that interface may then be pulled in\nindividually or renamed using ",(0,i.kt)("inlineCode",{parentName:"p"},"alias")," declarations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"adapter SongRenderToPrintDriver extends Song {\n  // Add a new `Print()` member function.\n  fn Print[me: Self]() { ... }\n\n  // Avoid name conflict with new `Print` function by making\n  // the implementation of the `Printable` interface external.\n  external impl as Printable = Song;\n\n  // Make the `Print` function from `Printable` available\n  // under the name `PrintToScreen`.\n  alias PrintToScreen = Printable.Print;\n}\n")),(0,i.kt)("h3",{id:"use-case-using-independent-libraries-together"},"Use case: Using independent libraries together"),(0,i.kt)("p",null,"Imagine we have two packages that are developed independently. Package\n",(0,i.kt)("inlineCode",{parentName:"p"},"CompareLib")," defines an interface ",(0,i.kt)("inlineCode",{parentName:"p"},"CompareLib.Comparable")," and a generic\nalgorithm ",(0,i.kt)("inlineCode",{parentName:"p"},"CompareLib.Sort")," that operates on types that implement\n",(0,i.kt)("inlineCode",{parentName:"p"},"CompareLib.Comparable"),". Package ",(0,i.kt)("inlineCode",{parentName:"p"},"SongLib")," defines a type ",(0,i.kt)("inlineCode",{parentName:"p"},"SongLib.Song"),".\nNeither has a dependency on the other, so neither package defines an\nimplementation for ",(0,i.kt)("inlineCode",{parentName:"p"},"CompareLib.Comparable")," for type ",(0,i.kt)("inlineCode",{parentName:"p"},"SongLib.Song"),". A user that\nwants to pass a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"SongLib.Song")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"CompareLib.Sort")," has to define\nan adapter that provides an implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"CompareLib.Comparable")," for\n",(0,i.kt)("inlineCode",{parentName:"p"},"SongLib.Song"),". This adapter will probably use the\n",(0,i.kt)("a",{parentName:"p",href:"#extending-adapter"},(0,i.kt)("inlineCode",{parentName:"a"},"extends")," facility of adapters")," to preserve the\n",(0,i.kt)("inlineCode",{parentName:"p"},"SongLib.Song")," API."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"import CompareLib;\nimport SongLib;\n\nadapter Song extends SongLib.Song {\n  impl as CompareLib.Comparable { ... }\n}\n// Or, to keep the names from CompareLib.Comparable out of Song's API:\nadapter Song extends SongLib.Song { }\nexternal impl Song as CompareLib.Comparable { ... }\n// Or, equivalently:\nadapter Song extends SongLib.Song {\n  external impl as CompareLib.Comparable { ... }\n}\n")),(0,i.kt)("p",null,"The caller can either convert ",(0,i.kt)("inlineCode",{parentName:"p"},"SongLib.Song")," values to ",(0,i.kt)("inlineCode",{parentName:"p"},"Song")," when calling\n",(0,i.kt)("inlineCode",{parentName:"p"},"CompareLib.Sort")," or just start with ",(0,i.kt)("inlineCode",{parentName:"p"},"Song")," values in the first place."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var lib_song: SongLib.Song = ...;\nCompareLib.Sort((lib_song as Song,));\n\nvar song: Song = ...;\nCompareLib.Sort((song,));\n")),(0,i.kt)("h3",{id:"use-case-defining-an-impl-for-use-by-other-types"},"Use case: Defining an impl for use by other types"),(0,i.kt)("p",null,"Let's say we want to provide a possible implementation of an interface for use\nby types for which that implementation would be appropriate. We can do that by\ndefining an adapter implementing the interface that is parameterized on the type\nit is adapting. That impl may then be pulled in using the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl as ... = ...;"),"\nsyntax."),(0,i.kt)("p",null,"For example, given an interface ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable")," for deciding which value is\nsmaller:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Comparable {\n  fn Less[me: Self](rhs: Self) -> bool;\n}\n")),(0,i.kt)("p",null,"We might define an adapter that implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable")," for types that define\nanother interface ",(0,i.kt)("inlineCode",{parentName:"p"},"Difference"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Difference {\n  fn Sub[me:Self](rhs: Self) -> i32;\n}\nadapter ComparableFromDifference(T:! Difference) for T {\n  impl as Comparable {\n    fn Less[me: Self](rhs: Self) -> bool {\n      return (me as T).Sub(rhs) < 0;\n    }\n  }\n}\nclass IntWrapper {\n  var x: i32;\n  impl as Difference {\n    fn Sub[me: Self](rhs: Self) -> i32 {\n      return left.x - right.x;\n    }\n  }\n  impl as Comparable = ComparableFromDifferenceFn(IntWrapper);\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"TODO:")," If we support function types, we could potentially pass a function to\nuse to the adapter instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"adapter ComparableFromDifferenceFn\n    (T:! Type, Difference:! fnty(T, T)->i32) for T {\n  impl as Comparable {\n    fn Less[me: Self](rhs: Self) -> bool {\n      return Difference(me, rhs) < 0;\n    }\n  }\n}\nclass IntWrapper {\n  var x: i32;\n  fn Difference(left: Self, right: Self) {\n    return left.x - right.x;\n  }\n  impl as Comparable =\n      ComparableFromDifferenceFn(IntWrapper, Difference);\n}\n")),(0,i.kt)("h3",{id:"use-case-private-impl"},"Use case: Private impl"),(0,i.kt)("p",null,"Adapter types can be used when a library publicly exposes a type, but only wants\nto say that type implements an interface as a private detail internal to the\nimplementation of the type. In that case, instead of implementing the interface\nfor the public type, the library can create a private adapter for that type and\nimplement the interface on that instead. Any member of the class can cast its\n",(0,i.kt)("inlineCode",{parentName:"p"},"me")," parameter to the adapter type when it wants to make use of the private\nimpl."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Public, in API file\nclass Complex64 {\n  // ...\n  fn CloserToOrigin[me: Self](them: Self) -> bool;\n}\n\n// Private\n\nadapter ByReal extends Complex64 {\n  // Complex numbers are not generally comparable,\n  // but this comparison function is useful for some\n  // method implementations.\n  impl as Comparable {\n    fn Less[me: Self](that: Self) -> bool {\n      return me.Real() < that.Real();\n    }\n  }\n}\n\nfn Complex64.CloserToOrigin[me: Self](them: Self) -> bool {\n  var me_mag: ByReal = me * me.Conj() as ByReal;\n  var them_mag: ByReal = them * them.Conj() as ByReal;\n  return me_mag.Less(them_mag);\n}\n")),(0,i.kt)("h3",{id:"use-case-accessing-external-names"},"Use case: Accessing external names"),(0,i.kt)("p",null,"Consider a case where a function will call several functions from an interface\nthat is ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#external-impl"},"implemented externally")," for a type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface DrawingContext {\n  fn SetPen[me: Self](...);\n  fn SetFill[me: Self](...);\n  fn DrawRectangle[me: Self](...);\n  fn DrawLine[me: Self](...);\n  ...\n}\nexternal impl Window as DrawingContext { ... }\n")),(0,i.kt)("p",null,"An adapter can make that much more convenient by making a compatible type where\nthe interface is ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#internal-impl"},"implemented internally"),". This\navoids having to ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#qualified-member-access-expression"},"qualify"),"\neach call to methods in the interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"adapter DrawInWindow for Window {\n  impl as DrawingContext = Window;\n}\nfn Render(w: Window) {\n  let d: DrawInWindow = w as DrawInWindow;\n  d.SetPen(...);\n  d.SetFill(...);\n  d.DrawRectangle(...);\n  ...\n}\n")),(0,i.kt)("h3",{id:"adapter-with-stricter-invariants"},"Adapter with stricter invariants"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Future work:")," Rust also uses the newtype idiom to create types with\nadditional invariants or other information encoded in the type\n(",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/rust-by-example/generics/new_types.html"},"1"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction"},"2"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html"},"3"),").\nThis is used to record in the type system that some data has passed validation\nchecks, like ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidDate")," with the same data layout as ",(0,i.kt)("inlineCode",{parentName:"p"},"Date"),". Or to record the\nunits associated with a value, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Seconds")," versus ",(0,i.kt)("inlineCode",{parentName:"p"},"Milliseconds")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Feet"),"\nversus ",(0,i.kt)("inlineCode",{parentName:"p"},"Meters"),". We should have some way of restricting the casts between a type\nand an adapter to address this use case."),(0,i.kt)("h2",{id:"associated-constants"},"Associated constants"),(0,i.kt)("p",null,"In addition to associated methods, we allow other kinds of\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#associated-entity"},"associated entities"),". For consistency, we use\nthe same syntax to describe a constant in an interface as in a type without\nassigning a value. As constants, they are declared using the ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," introducer.\nFor example, a fixed-dimensional point type could have the dimension as an\nassociated constant."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface NSpacePoint {\n  let N:! i32;\n  // The following require: 0 <= i < N.\n  fn Get[addr me: Self*](i: i32) -> f64;\n  fn Set[addr me: Self*](i: i32, value: f64);\n  // Associated constants may be used in signatures:\n  fn SetAll[addr me: Self*](value: Array(f64, N));\n}\n")),(0,i.kt)("p",null,"An implementation of an interface specifies values for associated constants with\na ",(0,i.kt)("a",{parentName:"p",href:"#where-constraints"},(0,i.kt)("inlineCode",{parentName:"a"},"where")," clause"),". For example, implementations of\n",(0,i.kt)("inlineCode",{parentName:"p"},"NSpacePoint")," for different types might have different values for ",(0,i.kt)("inlineCode",{parentName:"p"},"N"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Point2D {\n  impl as NSpacePoint where .N = 2 {\n    fn Get[addr me: Self*](i: i32) -> f64 { ... }\n    fn Set[addr me: Self*](i: i32, value: f64) { ... }\n    fn SetAll[addr me: Self*](value: Array(f64, 2)) { ... }\n  }\n}\n\nclass Point3D {\n  impl as NSpacePoint where .N = 3 {\n    fn Get[addr me: Self*](i: i32) -> f64 { ... }\n    fn Set[addr me: Self*](i: i32, value: f64) { ... }\n    fn SetAll[addr me: Self*](value: Array(f64, 3)) { ... }\n  }\n}\n")),(0,i.kt)("p",null,"Multiple assignments to associated constants may be joined using the ",(0,i.kt)("inlineCode",{parentName:"p"},"and"),"\nkeyword. The list of assignments is subject to two restrictions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An implementation of an interface cannot specify a value for a\n",(0,i.kt)("a",{parentName:"li",href:"#final-members"},(0,i.kt)("inlineCode",{parentName:"a"},"final"))," associated constant."),(0,i.kt)("li",{parentName:"ul"},"If an associated constant doesn't have a\n",(0,i.kt)("a",{parentName:"li",href:"#interface-defaults"},"default value"),", every implementation must specify its\nvalue.")),(0,i.kt)("p",null,"These values may be accessed as members of the type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Assert(Point2D.N == 2);\nAssert(Point3D.N == 3);\n\nfn PrintPoint[PointT:! NSpacePoint](p: PointT) {\n  for (var i: i32 = 0; i < PointT.N; ++i) {\n    if (i > 0) { Print(", "); }\n    Print(p.Get(i));\n  }\n}\n\nfn ExtractPoint[PointT:! NSpacePoint](\n    p: PointT,\n    dest: Array(f64, PointT.N)*) {\n  for (var i: i32 = 0; i < PointT.N; ++i) {\n    (*dest)[i] = p.Get(i);\n  }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," This feature is also called\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/items/associated-items.html#associated-constants"},"associated constants in Rust"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Aside:")," In general, the use of ",(0,i.kt)("inlineCode",{parentName:"p"},":!")," here means these ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," declarations will\nonly have compile-time and not runtime storage associated with them."),(0,i.kt)("h3",{id:"associated-class-functions"},"Associated class functions"),(0,i.kt)("p",null,"To be consistent with normal\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/classes.md#class-functions"},"class function")," declaration syntax,\nassociated class functions are written using a ",(0,i.kt)("inlineCode",{parentName:"p"},"fn")," declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'interface DeserializeFromString {\n  fn Deserialize(serialized: String) -> Self;\n}\n\nclass MySerializableType {\n  var i: i32;\n\n  impl as DeserializeFromString {\n    fn Deserialize(serialized: String) -> Self {\n      return (.i = StringToInt(serialized));\n    }\n  }\n}\n\nvar x: MySerializableType = MySerializableType.Deserialize("3");\n\nfn Deserialize(T:! DeserializeFromString, serialized: String) -> T {\n  return T.Deserialize(serialized);\n}\nvar y: MySerializableType = Deserialize(MySerializableType, "4");\n')),(0,i.kt)("p",null,"This is instead of declaring an associated constant using ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," with a function\ntype."),(0,i.kt)("p",null,"Together associated methods and associated class functions are called\n",(0,i.kt)("em",{parentName:"p"},"associated functions"),", much like together methods and class functions are\ncalled ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/classes.md#member-functions"},"member functions"),"."),(0,i.kt)("h2",{id:"associated-types"},"Associated types"),(0,i.kt)("p",null,"Associated types are ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#associated-entity"},"associated entities"),"\nthat happen to be types. These are particularly interesting since they can be\nused in the signatures of associated methods or functions, to allow the\nsignatures of methods to vary from implementation to implementation. We already\nhave one example of this: the ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," type discussed\n",(0,i.kt)("a",{parentName:"p",href:"#interfaces"},'in the "Interfaces" section'),". For other cases, we can say that the\ninterface declares that each implementation will provide a type under a specific\nname. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface StackAssociatedType {\n  let ElementType:! Type;\n  fn Push[addr me: Self*](value: ElementType);\n  fn Pop[addr me: Self*]() -> ElementType;\n  fn IsEmpty[addr me: Self*]() -> bool;\n}\n")),(0,i.kt)("p",null,"Here we have an interface called ",(0,i.kt)("inlineCode",{parentName:"p"},"StackAssociatedType")," which defines two\nmethods, ",(0,i.kt)("inlineCode",{parentName:"p"},"Push")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Pop"),". The signatures of those two methods declare them as\naccepting or returning values with the type ",(0,i.kt)("inlineCode",{parentName:"p"},"ElementType"),", which any implementer\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"StackAssociatedType")," must also define. For example, maybe ",(0,i.kt)("inlineCode",{parentName:"p"},"DynamicArray"),"\nimplements ",(0,i.kt)("inlineCode",{parentName:"p"},"StackAssociatedType"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class DynamicArray(T:! Type) {\n  class IteratorType { ... }\n  fn Begin[addr me: Self*]() -> IteratorType;\n  fn End[addr me: Self*]() -> IteratorType;\n  fn Insert[addr me: Self*](pos: IteratorType, value: T);\n  fn Remove[addr me: Self*](pos: IteratorType);\n\n  // Set the associated type `ElementType` to `T`.\n  impl as StackAssociatedType where .ElementType = T {\n    fn Push[addr me: Self*](value: ElementType) {\n      me->Insert(me->End(), value);\n    }\n    fn Pop[addr me: Self*]() -> ElementType {\n      var pos: IteratorType = me->End();\n      Assert(pos != me->Begin());\n      --pos;\n      returned var ret: ElementType = *pos;\n      me->Remove(pos);\n      return var;\n    }\n    fn IsEmpty[addr me: Self*]() -> bool {\n      return me->Begin() == me->End();\n    }\n  }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Alternatives considered:")," See\n",(0,i.kt)("a",{parentName:"p",href:"/proposals/p0731.md#syntax-for-associated-constants"},"other syntax options considered in #731 for specifying associated types"),".\nIn particular, it was deemed that\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID190"},"Swift's approach of inferring the associated type from method signatures in the impl"),"\nwas unneeded complexity."),(0,i.kt)("p",null,"The definition of the ",(0,i.kt)("inlineCode",{parentName:"p"},"StackAssociatedType")," is sufficient for writing a generic\nfunction that operates on anything implementing that interface, for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn PeekAtTopOfStack[StackType:! StackAssociatedType](s: StackType*)\n    -> StackType.ElementType {\n  var top: StackType.ElementType = s->Pop();\n  s->Push(top);\n  return top;\n}\n")),(0,i.kt)("p",null,"Inside the generic function ",(0,i.kt)("inlineCode",{parentName:"p"},"PeekAtTopOfStack"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"ElementType")," associated\ntype member of ",(0,i.kt)("inlineCode",{parentName:"p"},"StackType")," is erased. This means ",(0,i.kt)("inlineCode",{parentName:"p"},"StackType.ElementType")," has the\nAPI dictated by the declaration of ",(0,i.kt)("inlineCode",{parentName:"p"},"ElementType")," in the interface\n",(0,i.kt)("inlineCode",{parentName:"p"},"StackAssociatedType"),"."),(0,i.kt)("p",null,"Outside the generic, associated types have the concrete type values determined\nby impl lookup, rather than the erased version of that type used inside a\ngeneric."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var my_array: DynamicArray(i32) = (1, 2, 3);\n// PeekAtTopOfStack's `StackType` is set to `DynamicArray(i32)`\n// with `StackType.ElementType` set to `i32`.\nAssert(PeekAtTopOfStack(my_array) == 3);\n")),(0,i.kt)("p",null,"This is another part of achieving\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/goals#path-from-regular-functions"},"the goal that generic functions can be used in place of regular functions without changing the return type that callers see"),"\ndiscussed in the ",(0,i.kt)("a",{parentName:"p",href:"#return-type"},"return type section"),"."),(0,i.kt)("p",null,"Associated types can also be implemented using a\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/classes.md#member-type"},"member type"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Container {\n  let IteratorType:! Iterator;\n  ...\n}\n\nclass DynamicArray(T:! Type) {\n  ...\n  impl as Container {\n    class IteratorType {\n      impl Iterator { ... }\n    }\n    ...\n  }\n}\n")),(0,i.kt)("p",null,"For context, see\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#interface-type-parameters-and-associated-types"},'"Interface type parameters and associated types" in the generics terminology document'),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," Both\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types"},"Rust"),"\nand ",(0,i.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID189"},"Swift"),"\nsupport associated types."),(0,i.kt)("h3",{id:"implementation-model-1"},"Implementation model"),(0,i.kt)("p",null,"The associated type can be modeled by a witness table field in the interface's\nwitness table."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Iterator {\n  fn Advance[addr me: Self*]();\n}\n\ninterface Container {\n  let IteratorType:! Iterator;\n  fn Begin[addr me: Self*]() -> IteratorType;\n}\n")),(0,i.kt)("p",null,"is represented by:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Iterator(Self:! Type) {\n  var Advance: fnty(this: Self*);\n  ...\n}\nclass Container(Self:! Type) {\n  // Representation type for the iterator.\n  let IteratorType:! Type;\n  // Witness that IteratorType implements Iterator.\n  var iterator_impl: Iterator(IteratorType)*;\n\n  // Method\n  var Begin: fnty (this: Self*) -> IteratorType;\n  ...\n}\n")),(0,i.kt)("h2",{id:"parameterized-interfaces"},"Parameterized interfaces"),(0,i.kt)("p",null,"Associated types don't change the fact that a type can only implement an\ninterface at most once."),(0,i.kt)("p",null,"If instead you want a family of related interfaces, one per possible value of a\ntype parameter, multiple of which could be implemented for a single type, you\nwould use\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#interface-type-parameters-and-associated-types"},"parameterized interfaces"),".\nTo write a parameterized version of the stack interface, instead of using\nassociated types, write a parameter list after the name of the interface instead\nof the associated type declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface StackParameterized(ElementType:! Type) {\n  fn Push[addr me: Self*](value: ElementType);\n  fn Pop[addr me: Self*]() -> ElementType;\n  fn IsEmpty[addr me: Self*]() -> bool;\n}\n")),(0,i.kt)("p",null,"Then ",(0,i.kt)("inlineCode",{parentName:"p"},"StackParameterized(Fruit)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"StackParameterized(Veggie)")," would be\nconsidered different interfaces, with distinct implementations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Produce {\n  var fruit: DynamicArray(Fruit);\n  var veggie: DynamicArray(Veggie);\n  impl as StackParameterized(Fruit) {\n    fn Push[addr me: Self*](value: Fruit) {\n      me->fruit.Push(value);\n    }\n    fn Pop[addr me: Self*]() -> Fruit {\n      return me->fruit.Pop();\n    }\n    fn IsEmpty[addr me: Self*]() -> bool {\n      return me->fruit.IsEmpty();\n    }\n  }\n  impl as StackParameterized(Veggie) {\n    fn Push[addr me: Self*](value: Veggie) {\n      me->veggie.Push(value);\n    }\n    fn Pop[addr me: Self*]() -> Veggie {\n      return me->veggie.Pop();\n    }\n    fn IsEmpty[addr me: Self*]() -> bool {\n      return me->veggie.IsEmpty();\n    }\n  }\n}\n")),(0,i.kt)("p",null,"Unlike associated types in interfaces and parameters to types, interface\nparameters can't be deduced. For example, if we were to rewrite\n",(0,i.kt)("a",{parentName:"p",href:"#associated-types"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"PeekAtTopOfStack"),' example in the "associated types" section'),"\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"StackParameterized(T)")," it would generate a compile error:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// \u274c Error: can't deduce interface parameter `T`.\nfn BrokenPeekAtTopOfStackParameterized\n    [T:! Type, StackType:! StackParameterized(T)]\n    (s: StackType*) -> T { ... }\n")),(0,i.kt)("p",null,"This error is because the compiler can not determine if ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," should be ",(0,i.kt)("inlineCode",{parentName:"p"},"Fruit")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"Veggie")," when passing in argument of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Produce*"),". The function's signature\nwould have to be changed so that the value for ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," could be determined from the\nexplicit parameters."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn PeekAtTopOfStackParameterized\n    [T:! Type, StackType:! StackParameterized(T)]\n    (s: StackType*, _:! singleton_type_of(T)) -> T { ... }\n\nvar produce: Produce = ...;\nvar top_fruit: Fruit =\n    PeekAtTopOfStackParameterized(&produce, Fruit);\nvar top_veggie: Veggie =\n    PeekAtTopOfStackParameterized(&produce, Veggie);\n")),(0,i.kt)("p",null,"The pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"_:! singleton_type_of(T)")," is a placeholder syntax for an expression\nthat will only match ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", until issue\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/578"},"#578: Value patterns as function parameters"),"\nis resolved. Using that pattern in the explicit parameter list allows us to make\n",(0,i.kt)("inlineCode",{parentName:"p"},"T")," available earlier in the declaration so it can be passed as the argument to\nthe parameterized interface ",(0,i.kt)("inlineCode",{parentName:"p"},"StackParameterized"),"."),(0,i.kt)("p",null,"This approach is useful for the ",(0,i.kt)("inlineCode",{parentName:"p"},"ComparableTo(T)")," interface, where a type might\nbe comparable with multiple other types, and in fact interfaces for\n",(0,i.kt)("a",{parentName:"p",href:"#operator-overloading"},"operator overloads")," more generally. Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface EquatableWith(T:! Type) {\n  fn Equals[me: Self](rhs: T) -> bool;\n  ...\n}\nclass Complex {\n  var real: f64;\n  var imag: f64;\n  // Can implement this interface more than once\n  // as long as it has different arguments.\n  impl as EquatableWith(Complex) { ... }\n  impl as EquatableWith(f64) { ... }\n}\n")),(0,i.kt)("p",null,'All interface parameters must be marked as "generic", using the ',(0,i.kt)("inlineCode",{parentName:"p"},":!")," syntax.\nThis reflects these two properties of these parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"They must be resolved at compile-time, and so can't be passed regular\ndynamic values."),(0,i.kt)("li",{parentName:"ul"},"We allow either generic or template values to be passed in.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," Interface parameters aren't required to be types, but that is the vast\nmajority of cases. As an example, if we had an interface that allowed a type to\ndefine how the tuple-member-read operator would work, the index of the member\ncould be an interface parameter:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface ReadTupleMember(index:! u32) {\n  let T:! Type;\n  // Returns me[index]\n  fn Get[me: Self]() -> T;\n}\n")),(0,i.kt)("p",null,"This requires that the index be known at compile time, but allows different\nindices to be associated with different types."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Caveat:")," When implementing an interface twice for a type, the interface\nparameters are required to always be different. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Map(FromType:! Type, ToType:! Type) {\n  fn Map[addr me: Self*](needle: FromType) -> Optional(ToType);\n}\nclass Bijection(FromType:! Type, ToType:! Type) {\n  impl as Map(FromType, ToType) { ... }\n  impl as Map(ToType, FromType) { ... }\n}\n// \u274c Error: Bijection has two impls of interface Map(String, String)\nvar oops: Bijection(String, String) = ...;\n")),(0,i.kt)("p",null,"In this case, it would be better to have an ",(0,i.kt)("a",{parentName:"p",href:"#adapting-types"},"adapting type")," to\ncontain the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," for the reverse map lookup, instead of implementing the ",(0,i.kt)("inlineCode",{parentName:"p"},"Map"),"\ninterface twice:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Bijection(FromType:! Type, ToType:! Type) {\n  impl as Map(FromType, ToType) { ... }\n}\nadapter ReverseLookup(FromType:! Type, ToType:! Type)\n    for Bijection(FromType, ToType) {\n  impl as Map(ToType, FromType) { ... }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," Rust calls\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/items/traits.html#generic-traits"},'traits with type parameters "generic traits"'),"\nand\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#default-generic-type-parameters-and-operator-overloading"},"uses them for operator overloading"),"."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md#clearer-trait-matching"},'Rust uses the term "type parameters"'),'\nfor both interface type parameters and associated types. The difference is that\ninterface parameters are "inputs" since they ',(0,i.kt)("em",{parentName:"p"},"determine")," which ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),' to use,\nand associated types are "outputs" since they are determined ',(0,i.kt)("em",{parentName:"p"},"by")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),",\nbut play no role in selecting the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),"."),(0,i.kt)("h3",{id:"impl-lookup"},"Impl lookup"),(0,i.kt)("p",null,"Let's say you have some interface ",(0,i.kt)("inlineCode",{parentName:"p"},"I(T, U(V))")," being implemented for some type\n",(0,i.kt)("inlineCode",{parentName:"p"},"A(B(C(D), E))"),". To satisfy the ",(0,i.kt)("a",{parentName:"p",href:"#orphan-rule"},"orphan rule for coherence"),", that\n",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," must be defined in some library that must be imported in any code that\nlooks up whether that interface is implemented for that type. This requires that\n",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," is defined in the same library that defines the interface or one of the\nnames needed by the type. That is, the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," must be defined with one of ",(0,i.kt)("inlineCode",{parentName:"p"},"I"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"V"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"C"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"D"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"E"),". We further require anything looking\nup this ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," to import the ",(0,i.kt)("em",{parentName:"p"},"definitions")," of all of those names. Seeing a\nforward declaration of these names is insufficient, since you can presumably see\nforward declarations without seeing an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," with the definition. This\naccomplishes a few goals:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The compiler can check that there is only one definition of any ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," that\nis actually used, avoiding\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/One_Definition_Rule"},"One Definition Rule (ODR)"),"\nproblems."),(0,i.kt)("li",{parentName:"ul"},"Every attempt to use an ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," will see the exact same ",(0,i.kt)("inlineCode",{parentName:"li"},"impl"),", making the\ninterpretation and semantics of code consistent no matter its context, in\naccordance with the\n",(0,i.kt)("a",{parentName:"li",href:"/docs/project/principles/low_context_sensitivity.md"},"low context-sensitivity principle"),"."),(0,i.kt)("li",{parentName:"ul"},"Allowing the ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," to be defined with either the interface or the type\naddresses the\n",(0,i.kt)("a",{parentName:"li",href:"https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions"},"expression problem"),".")),(0,i.kt)("p",null,"Note that ",(0,i.kt)("a",{parentName:"p",href:"#lookup-resolution-and-specialization"},"the rules for specialization"),"\ndo allow there to be more than one ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," to be defined for a type, by\nunambiguously picking one as most specific."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"References:")," Implementation coherence is\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#coherence"},"defined in terminology"),", and is\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/goals#coherence"},"a goal for Carbon"),". More detail can be found in\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/appendix-coherence"},"this appendix with the rationale and alternatives considered"),"."),(0,i.kt)("h3",{id:"parameterized-named-constraints"},"Parameterized named constraints"),(0,i.kt)("p",null,"We should also allow the ",(0,i.kt)("a",{parentName:"p",href:"#named-constraints"},"named constraint")," construct to\nsupport parameters. Parameters would work the same way as for interfaces."),(0,i.kt)("h2",{id:"where-constraints"},"Where constraints"),(0,i.kt)("p",null,"So far, we have restricted a generic type parameter by saying it has to\nimplement an interface or a set of interfaces. There are a variety of other\nconstraints we would like to be able to express, such as applying restrictions\nto its associated types and associated constants. This is done using the ",(0,i.kt)("inlineCode",{parentName:"p"},"where"),"\noperator that adds constraints to a type-of-type."),(0,i.kt)("p",null,"The where operator can be applied to a type-of-type in a declaration context:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Constraints on function parameters:\nfn F[V:! D where ...](v: V) { ... }\n\n// Constraints on a class parameter:\nclass S(T:! B where ...) {\n  // Constraints on a method:\n  fn G[me: Self, V:! D where ...](v: V);\n}\n\n// Constraints on an interface parameter:\ninterface A(T:! B where ...) {\n  // Constraints on an associated type:\n  let U:! C where ...;\n  // Constraints on an associated method:\n  fn G[me: Self, V:! D where ...](v: V);\n}\n")),(0,i.kt)("p",null,"We also allow you to name constraints using a ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," operator in a ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"constraint")," definition. The expressions that can follow the ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," keyword are\ndescribed in the ",(0,i.kt)("a",{parentName:"p",href:"#constraint-use-cases"},'"constraint use cases"')," section, but\ngenerally look like boolean expressions that should evaluate to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,i.kt)("p",null,"The result of applying a ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," operator to a type-of-type is another\ntype-of-type. Note that this expands the kinds of requirements that\ntype-of-types can have from just interface requirements to also include the\nvarious kinds of constraints discussed later in this section. In addition, it\ncan introduce relationships between different type variables, such as that a\nmember of one is equal to the member of another."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," Both Swift and Rust use ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," clauses on\ndeclarations instead of in the expression syntax. These happen after the type\nthat is being constrained has been given a name and use that name to express the\nconstraint."),(0,i.kt)("p",null,"Rust also supports\n",(0,i.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/rfcs/0195-associated-items.html#constraining-associated-types"},"directly passing in the values for associated types"),"\nwhen using a trait as a constraint. This is helpful when specifying concrete\ntypes for all associated types in a trait in order to\n",(0,i.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/rfcs/0195-associated-items.html#trait-objects"},"make it object safe so it can be used to define a trait object type"),"."),(0,i.kt)("p",null,"Rust is adding trait aliases\n(",(0,i.kt)("a",{parentName:"p",href:"https://github.com/rust-lang/rfcs/blob/master/text/1733-trait-alias.md"},"RFC"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/rust-lang/rust/issues/41517"},"tracking issue"),") to support\nnaming some classes of constraints."),(0,i.kt)("h3",{id:"constraint-use-cases"},"Constraint use cases"),(0,i.kt)("h4",{id:"set-an-associated-constant-to-a-specific-value"},"Set an associated constant to a specific value"),(0,i.kt)("p",null,"We might need to write a function that only works with a specific value of an\n",(0,i.kt)("a",{parentName:"p",href:"#associated-constants"},"associated constant")," ",(0,i.kt)("inlineCode",{parentName:"p"},"N"),". In this case, the name of the\nassociated constant is written first, followed by an ",(0,i.kt)("inlineCode",{parentName:"p"},"="),", and then the value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'fn PrintPoint2D[PointT:! NSpacePoint where .N = 2](p: PointT) {\n  Print(p.Get(0), ", ", p.Get(1));\n}\n')),(0,i.kt)("p",null,"Similarly in an interface definition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Has2DPoint {\n  let PointT:! NSpacePoint where .N = 2;\n}\n")),(0,i.kt)("p",null,"To name such a constraint, you may use a ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," or a ",(0,i.kt)("inlineCode",{parentName:"p"},"constraint")," declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"let Point2DInterface:! auto = NSpacePoint where .N = 2;\nconstraint Point2DInterface {\n  extends NSpacePoint where .N = 2;\n}\n")),(0,i.kt)("p",null,"This syntax is also used to specify the values of\n",(0,i.kt)("a",{parentName:"p",href:"#associated-constants"},"associated constants")," when implementing an interface for\na type."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Concern:")," Using ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," for this use case is not consistent with other ",(0,i.kt)("inlineCode",{parentName:"p"},"where"),"\nclauses that write a boolean expression that evaluates to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," when the\nconstraint is satisfied."),(0,i.kt)("p",null,"A constraint to say that two associated constants should have the same value\nwithout specifying what specific value they should have must use ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," instead of\n",(0,i.kt)("inlineCode",{parentName:"p"},"="),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface PointCloud {\n  let Dim:! i32;\n  let PointT:! NSpacePoint where .N == Dim;\n}\n")),(0,i.kt)("h4",{id:"same-type-constraints"},"Same type constraints"),(0,i.kt)("h5",{id:"set-an-associated-type-to-a-specific-value"},"Set an associated type to a specific value"),(0,i.kt)("p",null,"Functions accepting a generic type might also want to constrain one of its\nassociated types to be a specific, concrete type. For example, we might want to\nhave a function only accept stacks containing integers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn SumIntStack[T:! Stack where .ElementType = i32](s: T*) -> i32 {\n  var sum: i32 = 0;\n  while (!s->IsEmpty()) {\n    // s->Pop() has type `T.ElementType` == i32:\n    sum += s->Pop();\n  }\n  return sum;\n}\n")),(0,i.kt)("p",null,"To name these sorts of constraints, we could use ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," declarations or\n",(0,i.kt)("inlineCode",{parentName:"p"},"constraint")," definitions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"let IntStack:! auto = Stack where .ElementType = i32;\nconstraint IntStack {\n  extends Stack where .ElementType = i32;\n}\n")),(0,i.kt)("p",null,"This syntax is also used to specify the values of\n",(0,i.kt)("a",{parentName:"p",href:"#associated-types"},"associated types")," when implementing an interface for a type."),(0,i.kt)("h5",{id:"equal-generic-types"},"Equal generic types"),(0,i.kt)("p",null,"Alternatively, two generic types could be constrained to be equal to each other,\nwithout specifying what that type is. This uses ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"="),". For\nexample, we could make the ",(0,i.kt)("inlineCode",{parentName:"p"},"ElementType")," of an ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterator")," interface equal to the\n",(0,i.kt)("inlineCode",{parentName:"p"},"ElementType")," of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Container")," interface as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Iterator {\n  let ElementType:! Type;\n  ...\n}\ninterface Container {\n  let ElementType:! Type;\n  let IteratorType:! Iterator where .ElementType == ElementType;\n  ...\n}\n")),(0,i.kt)("p",null,"Given an interface with two associated types"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface PairInterface {\n  let Left:! Type;\n  let Right:! Type;\n}\n")),(0,i.kt)("p",null,"we can constrain them to be equal in a function signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn F[MatchedPairType:! PairInterface where .Left == .Right]\n    (x: MatchedPairType*);\n")),(0,i.kt)("p",null,"or in an interface definition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface HasEqualPair {\n  let P:! PairInterface where .Left == .Right;\n}\n")),(0,i.kt)("p",null,"This kind of constraint can be named:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"let EqualPair:! auto =\n    PairInterface where .Left == .Right;\nconstraint EqualPair {\n  extends PairInterface where .Left == .Right;\n}\n")),(0,i.kt)("p",null,"Another example of same type constraints is when associated types of two\ndifferent interfaces are constrained to be equal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn Map[CT:! Container,\n       FT:! Function where .InputType == CT.ElementType]\n      (c: CT, f: FT) -> Vector(FT.OutputType);\n")),(0,i.kt)("h6",{id:"satisfying-both-type-of-types"},"Satisfying both type-of-types"),(0,i.kt)("p",null,"If the two types being constrained to be equal have been declared with different\ntype-of-types, then the actual type value they are set to will have to satisfy\nboth constraints. For example, if ",(0,i.kt)("inlineCode",{parentName:"p"},"SortedContainer.ElementType")," is declared to\nbe ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable"),", then in this declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn Contains\n    [SC:! SortedContainer,\n     CT:! Container where .ElementType == SC.ElementType]\n    (haystack: SC, needles: CT) -> bool;\n")),(0,i.kt)("p",null,"the ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," constraint means ",(0,i.kt)("inlineCode",{parentName:"p"},"CT.ElementType")," must satisfy ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable")," as well.\nHowever, inside the body of ",(0,i.kt)("inlineCode",{parentName:"p"},"Contains"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"CT.ElementType")," will only act like the\nimplementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable")," is ",(0,i.kt)("a",{parentName:"p",href:"#external-impl"},"external"),". That is, items\nfrom the ",(0,i.kt)("inlineCode",{parentName:"p"},"needles")," container won't directly have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Compare")," method member, but\ncan still be implicitly converted to ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable")," and can still call ",(0,i.kt)("inlineCode",{parentName:"p"},"Compare"),"\nusing the compound member access syntax, ",(0,i.kt)("inlineCode",{parentName:"p"},"needle.(Comparable.Compare)(elt)"),". The\nrule is that an ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," constraint between two type variables does not\nmodify the set of member names of either type. (If you write\n",(0,i.kt)("inlineCode",{parentName:"p"},"where .ElementType = String")," with a ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," and a concrete type, then\n",(0,i.kt)("inlineCode",{parentName:"p"},".ElementType")," is actually set to ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," including the complete ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," API.)"),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," constraints are symmetric, so the previous declaration of\n",(0,i.kt)("inlineCode",{parentName:"p"},"Contains")," is equivalent to an alternative declaration where ",(0,i.kt)("inlineCode",{parentName:"p"},"CT")," is declared\nfirst and the ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," clause is attached to ",(0,i.kt)("inlineCode",{parentName:"p"},"SortedContainer"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn Contains\n    [CT:! Container,\n     SC:! SortedContainer where .ElementType == CT.ElementType]\n    (haystack: SC, needles: CT) -> bool;\n")),(0,i.kt)("h4",{id:"type-bound-for-associated-type"},"Type bound for associated type"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," clause can express that a type must implement an interface. This is\nmore flexible than the usual approach of including that interface in the type\nsince it can be applied to associated type members as well."),(0,i.kt)("h5",{id:"type-bounds-on-associated-types-in-declarations"},"Type bounds on associated types in declarations"),(0,i.kt)("p",null,"In the following example, normally the ",(0,i.kt)("inlineCode",{parentName:"p"},"ElementType")," of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Container")," can be any\ntype. The ",(0,i.kt)("inlineCode",{parentName:"p"},"SortContainer")," function, however, takes a pointer to a type\nsatisfying ",(0,i.kt)("inlineCode",{parentName:"p"},"Container")," with the additional constraint that its ",(0,i.kt)("inlineCode",{parentName:"p"},"ElementType"),"\nmust satisfy the ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable")," interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Container {\n  let ElementType:! Type;\n  ...\n}\n\nfn SortContainer\n    [ContainerType:! Container where .ElementType is Comparable]\n    (container_to_sort: ContainerType*);\n")),(0,i.kt)("p",null,"In contrast to ",(0,i.kt)("a",{parentName:"p",href:"#same-type-constraints"},"a same type constraint"),", this does not\nsay what type ",(0,i.kt)("inlineCode",{parentName:"p"},"ElementType")," exactly is, just that it must satisfy some\ntype-of-type."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," How do you spell that? Provisionally we are writing ",(0,i.kt)("inlineCode",{parentName:"p"},"is"),",\nfollowing Swift, but maybe we should have another operator that more clearly\nreturns a boolean like ",(0,i.kt)("inlineCode",{parentName:"p"},"has_type"),"?"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"Container")," defines ",(0,i.kt)("inlineCode",{parentName:"p"},"ElementType")," as having type ",(0,i.kt)("inlineCode",{parentName:"p"},"Type"),", but\n",(0,i.kt)("inlineCode",{parentName:"p"},"ContainerType.ElementType")," has type ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable"),". This is because\n",(0,i.kt)("inlineCode",{parentName:"p"},"ContainerType")," has type ",(0,i.kt)("inlineCode",{parentName:"p"},"Container where .ElementType is Comparable"),", not\n",(0,i.kt)("inlineCode",{parentName:"p"},"Container"),". This means we need to be a bit careful when talking about the type\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"ContainerType")," when there is a ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," clause modifying it."),(0,i.kt)("h5",{id:"type-bounds-on-associated-types-in-interfaces"},"Type bounds on associated types in interfaces"),(0,i.kt)("p",null,"Given these definitions (omitting ",(0,i.kt)("inlineCode",{parentName:"p"},"ElementType")," for brevity):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface IteratorInterface { ... }\ninterface ContainerInterface {\n  let IteratorType:! IteratorInterface;\n  ...\n}\ninterface RandomAccessIterator {\n  extends IteratorInterface;\n  ...\n}\n")),(0,i.kt)("p",null,"We can then define a function that only accepts types that implement\n",(0,i.kt)("inlineCode",{parentName:"p"},"ContainerInterface")," where its ",(0,i.kt)("inlineCode",{parentName:"p"},"IteratorType")," associated type implements\n",(0,i.kt)("inlineCode",{parentName:"p"},"RandomAccessIterator"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn F[ContainerType:! ContainerInterface\n     where .IteratorType is RandomAccessIterator]\n    (c: ContainerType);\n")),(0,i.kt)("p",null,"We would like to be able to name this constraint, defining a\n",(0,i.kt)("inlineCode",{parentName:"p"},"RandomAccessContainer")," to be a type-of-type whose types satisfy\n",(0,i.kt)("inlineCode",{parentName:"p"},"ContainerInterface")," with an ",(0,i.kt)("inlineCode",{parentName:"p"},"IteratorType")," satisfying ",(0,i.kt)("inlineCode",{parentName:"p"},"RandomAccessIterator"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"let RandomAccessContainer:! auto =\n    ContainerInterface where .IteratorType is RandomAccessIterator;\n// or\nconstraint RandomAccessContainer {\n  extends ContainerInterface\n      where .IteratorType is RandomAccessIterator;\n}\n\n// With the above definition:\nfn F[ContainerType:! RandomAccessContainer](c: ContainerType);\n// is equivalent to:\nfn F[ContainerType:! ContainerInterface\n     where .IteratorType is RandomAccessIterator]\n    (c: ContainerType);\n")),(0,i.kt)("h4",{id:"combining-constraints"},"Combining constraints"),(0,i.kt)("p",null,"Constraints can be combined by separating constraint clauses with the ",(0,i.kt)("inlineCode",{parentName:"p"},"and"),"\nkeyword. This example expresses a constraint that two associated types are equal\nand satisfy an interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn EqualContainers\n    [CT1:! Container,\n     CT2:! Container where .ElementType is HasEquality\n                       and .ElementType == CT1.ElementType]\n    (c1: CT1*, c2: CT2*) -> bool;\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," Swift and Rust use commas ",(0,i.kt)("inlineCode",{parentName:"p"},",")," to separate\nconstraint clauses, but that only works because they place the ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," in a\ndifferent position in a declaration. In Carbon, the ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," is attached to a\ntype in a parameter list that is already using commas to separate parameters."),(0,i.kt)("h4",{id:"recursive-constraints"},"Recursive constraints"),(0,i.kt)("p",null,"We sometimes need to constrain a type to equal one of its associated types. In\nthis first example, we want to represent the function ",(0,i.kt)("inlineCode",{parentName:"p"},"Abs")," which will return\n",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," for some but not all types, so we use an associated type ",(0,i.kt)("inlineCode",{parentName:"p"},"MagnitudeType"),"\nto encode the return type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface HasAbs {\n  extends Numeric;\n  let MagnitudeType:! Numeric;\n  fn Abs[me: Self]() -> MagnitudeType;\n}\n")),(0,i.kt)("p",null,"For types representing subsets of the real numbers, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"f32"),", the\n",(0,i.kt)("inlineCode",{parentName:"p"},"MagnitudeType")," will match ",(0,i.kt)("inlineCode",{parentName:"p"},"Self"),", the type implementing an interface. For types\nrepresenting complex numbers, the types will be different. For example, the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Abs()")," applied to a ",(0,i.kt)("inlineCode",{parentName:"p"},"Complex64")," value would produce a ",(0,i.kt)("inlineCode",{parentName:"p"},"f32")," result. The goal is\nto write a constraint to restrict to the first case."),(0,i.kt)("p",null,"In a second example, when you take the slice of a type implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Container"),"\nyou get a type implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Container")," which may or may not be the same type as\nthe original container type. However, taking the slice of a slice always gives\nyou the same type, and some functions want to only operate on containers whose\nslice type is the same as the container type."),(0,i.kt)("p",null,"To solve this problem, we think of ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," as an actual associated type member of\nevery interface. We can then address it using ",(0,i.kt)("inlineCode",{parentName:"p"},".Self")," in a ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," clause, like\nany other associated type member."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn Relu[T:! HasAbs where .MagnitudeType == .Self](x: T) {\n  // T.MagnitudeType == T so the following is allowed:\n  return (x.Abs() + x) / 2;\n}\nfn UseContainer[T:! Container where .SliceType == .Self](c: T) -> bool {\n  // T.SliceType == T so `c` and `c.Slice(...)` can be compared:\n  return c == c.Slice(...);\n}\n")),(0,i.kt)("p",null,"Notice that in an interface definition, ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," refers to the type implementing\nthis interface while ",(0,i.kt)("inlineCode",{parentName:"p"},".Self")," refers to the associated type currently being\ndefined."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Container {\n  let ElementType:! Type;\n\n  let SliceType:! Container\n      where .ElementType == ElementType and\n            .SliceType == .Self;\n\n  fn GetSlice[addr me: Self*]\n      (start: IteratorType, end: IteratorType) -> SliceType;\n}\n")),(0,i.kt)("p",null,"These recursive constraints can be named:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"let RealAbs:! auto = HasAbs where .MagnitudeType == .Self;\nconstraint RealAbs {\n  extends HasAbs where .MagnitudeType == Self;\n}\nlet ContainerIsSlice:! auto =\n    Container where .SliceType == .Self;\nconstraint ContainerIsSlice {\n  extends Container where .SliceType == Self;\n}\n")),(0,i.kt)("p",null,"Note that using the ",(0,i.kt)("inlineCode",{parentName:"p"},"constraint")," approach we can name these constraints using\n",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},".Self"),", since they refer to the same type."),(0,i.kt)("h4",{id:"parameterized-type-implements-interface"},"Parameterized type implements interface"),(0,i.kt)("p",null,"There are times when a function will pass a generic type parameter of the\nfunction as an argument to a parameterized type, as in the previous case, and in\naddition the function needs the result to implement a specific interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Some parametized type.\nclass Vector(T:! Type) { ... }\n\n// Parameterized type implements interface only for some arguments.\nexternal impl Vector(String) as Printable { ... }\n\n// Constraint: `T` such that `Vector(T)` implements `Printable`\nfn PrintThree\n    [T:! Type where Vector(.Self) is Printable]\n    (a: T, b: T, c: T) {\n  var v: Vector(T) = (a, b, c);\n  Print(v);\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," This use case was part of the\n",(0,i.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/rfcs/0135-where.html#motivation"},"Rust rationale for adding support for ",(0,i.kt)("inlineCode",{parentName:"a"},"where")," clauses"),"."),(0,i.kt)("h4",{id:"another-type-implements-parameterized-interface"},"Another type implements parameterized interface"),(0,i.kt)("p",null,"In this case, we need some other type to implement an interface parameterized by\na generic type parameter. The syntax for this case follows the previous case,\nexcept now the ",(0,i.kt)("inlineCode",{parentName:"p"},".Self")," parameter is on the interface to the right of the ",(0,i.kt)("inlineCode",{parentName:"p"},"is"),".\nFor example, we might need a type parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," to support explicit conversion\nfrom an integer type like ",(0,i.kt)("inlineCode",{parentName:"p"},"i32"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface As(T:! Type) {\n  fn Convert[me: Self]() -> T;\n}\n\nfn Double[T:! Mul where i32 is As(.Self)](x: T) -> T {\n  return x * (2 as T);\n}\n")),(0,i.kt)("h3",{id:"implied-constraints"},"Implied constraints"),(0,i.kt)("p",null,"Imagine we have a generic function that accepts an arbitrary ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn LookUp[KeyType:! Type](hm: HashMap(KeyType, i32)*,\n                          k: KeyType) -> i32;\n\nfn PrintValueOrDefault[KeyType:! Printable,\n                       ValueT:! Printable & HasDefault]\n    (map: HashMap(KeyType, ValueT), key: KeyT);\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyType")," in these declarations does not visibly satisfy the requirements of\n",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap"),", which requires the type implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable")," and other interfaces:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class HashMap(\n    KeyType:! Hashable & EqualityComparable & Movable,\n    ...) { ... }\n")),(0,i.kt)("p",null,"In this case, ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyType")," gets ",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable")," and so on as ",(0,i.kt)("em",{parentName:"p"},"implied constraints"),".\nEffectively that means that these functions are automatically rewritten to add a\n",(0,i.kt)("inlineCode",{parentName:"p"},"where")," constraint on ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyType")," attached to the ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap")," type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn LookUp[KeyType:! Type]\n    (hm: HashMap(KeyType, i32)*\n        where KeyType is Hashable & EqualityComparable & Movable,\n     k: KeyType) -> i32;\n\nfn PrintValueOrDefault[KeyType:! Printable,\n                       ValueT:! Printable & HasDefault]\n    (map: HashMap(KeyType, ValueT)\n        where KeyType is Hashable & EqualityComparable & Movable,\n     key: KeyT);\n")),(0,i.kt)("p",null,"In this case, Carbon will accept the definition and infer the needed constraints\non the generic type parameter. This is both more concise for the author of the\ncode and follows the\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"},'"don\'t repeat yourself" principle'),".\nThis redundancy is undesirable since it means if the needed constraints for\n",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap")," are changed, then the code has to be updated in more locations.\nFurther it can add noise that obscures relevant information. In practice, any\nuser of these functions will have to pass in a valid ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap")," instance, and so\nwill have already satisfied these constraints."),(0,i.kt)("p",null,"This implied constraint is equivalent to the explicit constraint that each\nparameter and return type ",(0,i.kt)("a",{parentName:"p",href:"#must-be-legal-type-argument-constraints"},"is legal"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," These implied constraints affect the ",(0,i.kt)("em",{parentName:"p"},"requirements")," of a generic type\nparameter, but not its ",(0,i.kt)("em",{parentName:"p"},"member names"),". This way you can always look at the\ndeclaration to see how name resolution works, without having to look up the\ndefinitions of everything it is used as an argument to."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Limitation:")," To limit readability concerns and ambiguity, this feature is\nlimited to a single signature. Consider this interface declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface GraphNode {\n  let Edge:! Type;\n  fn EdgesFrom[me: Self]() -> HashSet(Edge);\n}\n")),(0,i.kt)("p",null,"One approach would be to say the use of ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet(Edge)")," in the signature of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"EdgesFrom")," function would imply that ",(0,i.kt)("inlineCode",{parentName:"p"},"Edge")," satisfies the requirements of an\nargument to ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet"),", such as being ",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable"),". Another approach would be to\nsay that the ",(0,i.kt)("inlineCode",{parentName:"p"},"EdgesFrom")," would only be conditionally available when ",(0,i.kt)("inlineCode",{parentName:"p"},"Edge")," does\nsatisfy the constraints on ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet")," arguments. Instead, Carbon will reject this\ndefinition, requiring the user to include all the constraints required for the\nother declarations in the interface in the declaration of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Edge")," associated\ntype. Similarly, a parameter to a class must be declared with all the\nconstraints needed to declare the members of the class that depend on that\nparameter."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," Both Swift\n(",(0,i.kt)("a",{parentName:"p",href:"https://www.swiftbysundell.com/tips/inferred-generic-type-constraints/"},"1"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apple/swift/blob/main/docs/Generics.rst#constraint-inference"},"2"),")\nand\n",(0,i.kt)("a",{parentName:"p",href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0b2d645bd205f24a7a6e2330d652c32e"},"Rust"),"\nsupport some form of this feature as part of their type inference (and\n",(0,i.kt)("a",{parentName:"p",href:"http://smallcultfollowing.com/babysteps//blog/2022/04/12/implied-bounds-and-perfect-derive/#expanded-implied-bounds"},"the Rust community is considering expanding support"),")."),(0,i.kt)("h4",{id:"must-be-legal-type-argument-constraints"},"Must be legal type argument constraints"),(0,i.kt)("p",null,"Now consider the case that the generic type parameter is going to be used as an\nargument to a parameterized type in a function body, not in the signature. If\nthe parameterized type was explicitly mentioned in the signature, the implied\nconstraint feature would ensure all of its requirements were met. The developer\ncan create a trivial\n",(0,i.kt)("a",{parentName:"p",href:"#parameterized-type-implements-interface"},"parameterized type implements interface"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"where")," constraint to just say the type is a legal with this argument, by saying\nthat the parameterized type implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Type"),", which all types do."),(0,i.kt)("p",null,"For example, a function that adds its parameters to a ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet")," to deduplicate\nthem, needs them to be ",(0,i.kt)("inlineCode",{parentName:"p"},"Hashable"),' and so on. To say "',(0,i.kt)("inlineCode",{parentName:"p"},"T")," is a type where\n",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet(T)"),' is legal," we can write:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn NumDistinct[T:! Type where HashSet(.Self) is Type]\n    (a: T, b: T, c: T) -> i32 {\n  var set: HashSet(T);\n  set.Add(a);\n  set.Add(b);\n  set.Add(c);\n  return set.Size();\n}\n")),(0,i.kt)("p",null,"This has the same advantages over repeating the constraints on ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet"),"\narguments in the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," as the general implied constraints above."),(0,i.kt)("h3",{id:"referencing-names-in-the-interface-being-defined"},"Referencing names in the interface being defined"),(0,i.kt)("p",null,"The constraint in a ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," clause is required to only reference earlier names\nfrom this scope, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Graph {\n  let E: Edge;\n  let V: Vert where .E == E and .Self == E.V;\n}\n")),(0,i.kt)("h3",{id:"manual-type-equality"},"Manual type equality"),(0,i.kt)("p",null,"Imagine we have some function with generic parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn F[T:! SomeInterface](x: T) {\n  x.G(x.H());\n}\n")),(0,i.kt)("p",null,"We want to know if the return type of method ",(0,i.kt)("inlineCode",{parentName:"p"},"T.H")," is the same as the parameter\ntype of ",(0,i.kt)("inlineCode",{parentName:"p"},"T.G")," in order to typecheck the function. However, determining whether\ntwo type expressions are transitively equal is in general undecidable, as\n",(0,i.kt)("a",{parentName:"p",href:"https://forums.swift.org/t/swift-type-checking-is-undecidable/39024"},"has been shown in Swift"),"."),(0,i.kt)("p",null,"Carbon's approach is to only allow implicit conversions between two type\nexpressions that are constrained to be equal in a single where clause. This\nmeans that if two type expressions are only transitively equal, the user will\nneed to include a sequence of casts or use an\n",(0,i.kt)("a",{parentName:"p",href:"#observe-declarations"},(0,i.kt)("inlineCode",{parentName:"a"},"observe")," declaration")," to convert between them."),(0,i.kt)("p",null,"Given this interface ",(0,i.kt)("inlineCode",{parentName:"p"},"Transitive")," that has associated types that are constrained\nto all be equal, with interfaces ",(0,i.kt)("inlineCode",{parentName:"p"},"P"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Q"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface P { fn InP[me:Self](); }\ninterface Q { fn InQ[me:Self](); }\ninterface R { fn InR[me:Self](); }\n\ninterface Transitive {\n  let A:! P;\n  let B:! Q where .Self == A;\n  let C:! R where .Self == B;\n\n  fn GetA[me: Self]() -> A;\n  fn TakesC[me:Self](c: C);\n}\n")),(0,i.kt)("p",null,"A cast to ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," is needed to call ",(0,i.kt)("inlineCode",{parentName:"p"},"TakesC")," with a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),", so each step\nonly relies on one equality:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn F[T:! Transitive](t: T) {\n  // \u2705 Allowed\n  t.TakesC(t.GetA() as T.B);\n\n  // \u2705 Allowed\n  let b: T.B = t.GetA();\n  t.TakesC(b);\n\n  // \u274c Not allowed: t.TakesC(t.GetA());\n}\n")),(0,i.kt)("p",null,"A value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),", such as the return value of ",(0,i.kt)("inlineCode",{parentName:"p"},"GetA()"),", has the API of ",(0,i.kt)("inlineCode",{parentName:"p"},"P"),".\nAny such value also implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Q"),", and since the compiler can see that by way\nof a single ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," equality, values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," are treated as if they\nimplement ",(0,i.kt)("inlineCode",{parentName:"p"},"Q")," ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#external-impl"},"externally"),". However, the compiler\nwill require a cast to ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," to see that the type implements ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn TakesPQR[U:! P & Q & R](u: U);\n\nfn G[T:! Transitive](t: T) {\n  var a: T.A = t.GetA();\n\n  // \u2705 Allowed: `T.A` implements `P`.\n  a.InP();\n\n  // \u2705 Allowed: `T.A` implements `Q` externally.\n  a.(Q.InQ)();\n\n  // \u274c Not allowed: a.InQ();\n\n  // \u2705 Allowed: values of type `T.A` may be cast\n  // to `T.B`, which implements `Q` internally.\n  (a as T.B).InQ();\n\n  // \u2705 Allowed: `T.B` implements `R` externally.\n  (a as T.B).(R.InR)();\n\n  // \u274c Not allowed: TakesPQR(a);\n\n  // \u2705 Allowed: `T.B` implements `P`, `Q`, and\n  // `R`, though the implementations of `P`\n  // and `R` are external.\n  TakesPQR(a as T.B);\n}\n")),(0,i.kt)("p",null,"The compiler may have several different ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," clauses to consider,\nparticularly when an interface has associated types that recursively satisfy the\nsame interface. For example, given this interface ",(0,i.kt)("inlineCode",{parentName:"p"},"Commute"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Commute {\n  let X:! Commute;\n  let Y:! Commute where .X == X.Y;\n\n  fn GetX[me: Self]() -> X;\n  fn GetY[me: Self]() -> Y;\n  fn TakesXXY[me:Self](xxy: X.X.Y);\n}\n")),(0,i.kt)("p",null,"and a function ",(0,i.kt)("inlineCode",{parentName:"p"},"H")," taking a value with some type implementing this interface,\nthen the following would be legal statements in ",(0,i.kt)("inlineCode",{parentName:"p"},"H"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn H[C: Commute](c: C) {\n  // \u2705 Legal: argument has type `C.X.X.Y`\n  c.TakesXXY(c.GetX().GetX().GetY());\n\n  // \u2705 Legal: argument has type `C.X.Y.X` which is equal\n  // to `C.X.X.Y` following only one `where` clause.\n  c.TakesXXY(c.GetX().GetY().GetX());\n\n  // \u2705 Legal: cast is legal since it matches a `where`\n  // clause, and produces an argument that has type\n  // `C.X.Y.X`.\n  c.TakesXXY(c.GetY().GetX().GetX() as C.X.Y.X);\n}\n")),(0,i.kt)("p",null,"That last call would not be legal without the cast, though."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," Other languages such as Swift and Rust\ninstead perform automatic type equality. In practice this means that their\ncompiler can reject some legal programs based on heuristics simply to avoid\nrunning for an unbounded length of time."),(0,i.kt)("p",null,"The benefits of the manual approach include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"fast compilation, since the compiler does not need to explore a potentially\nlarge set of combinations of equality restrictions, supporting\n",(0,i.kt)("a",{parentName:"li",href:"/docs/project/goals.md#fast-and-scalable-development"},"Carbon's goal of fast and scalable development"),";"),(0,i.kt)("li",{parentName:"ul"},"expressive and predictable semantics, since there are no limitations on how\ncomplex a set of constraints can be supported; and"),(0,i.kt)("li",{parentName:"ul"},"simplicity.")),(0,i.kt)("p",null,"The main downsides are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"manual work for the source code author to prove to the compiler that types\nare equal; and"),(0,i.kt)("li",{parentName:"ul"},"verbosity.")),(0,i.kt)("p",null,"We expect that rich error messages and IDE tooling will be able to suggest\nchanges to the source code when a single equality constraint is not sufficient\nto show two type expressions are equal, but a more extensive automated search\ncan find a sequence that prove they are equal."),(0,i.kt)("h4",{id:"observe-declarations"},(0,i.kt)("inlineCode",{parentName:"h4"},"observe")," declarations"),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"observe")," declaration lists a sequence of type expressions that are equal by\nsome same-type ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," constraints. These ",(0,i.kt)("inlineCode",{parentName:"p"},"observe")," declarations may be included\nin an ",(0,i.kt)("inlineCode",{parentName:"p"},"interface")," definition or a function body, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Commute {\n  let X:! Commute;\n  let Y:! Commute where .X == X.Y;\n  ...\n  observe X.X.Y == X.Y.X == Y.X.X;\n}\n\nfn H[C: Commute](c: C) {\n  observe C.X.Y.Y == C.Y.X.Y == C.Y.Y.X;\n  ...\n}\n")),(0,i.kt)("p",null,"Every type expression after the first must be equal to some earlier type\nexpression in the sequence by a single ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," equality constraint. In this\nexample,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Commute {\n  let X:! Commute;\n  let Y:! Commute where .X == X.Y;\n  ...\n  // \u2705 Legal:\n  observe X.X.Y.Y == X.Y.X.Y == Y.X.X.Y == X.Y.Y.X;\n}\n")),(0,i.kt)("p",null,"the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"X.Y.Y.X")," is one equality away from ",(0,i.kt)("inlineCode",{parentName:"p"},"X.Y.X.Y")," and so it is\nallowed. This is even though ",(0,i.kt)("inlineCode",{parentName:"p"},"X.Y.X.Y")," isn't the type expression immediately\nprior to ",(0,i.kt)("inlineCode",{parentName:"p"},"X.Y.Y.X"),"."),(0,i.kt)("p",null,"After an ",(0,i.kt)("inlineCode",{parentName:"p"},"observe")," declaration, all of the listed type expressions are\nconsidered equal to each other using a single ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," equality. In this example,\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"observe")," declaration in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Transitive")," interface definition provides the\nlink between associated types ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," that allows function ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," to type\ncheck."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface P { fn InP[me:Self](); }\ninterface Q { fn InQ[me:Self](); }\ninterface R { fn InR[me:Self](); }\n\ninterface Transitive {\n  let A:! P;\n  let B:! Q where .Self == A;\n  let C:! R where .Self == B;\n\n  fn GetA[me: Self]() -> A;\n  fn TakesC[me:Self](c: C);\n\n  // Without this `observe` declaration, the\n  // calls in `F` below would not be allowed.\n  observe A == B == C;\n}\n\nfn TakesPQR[U:! P & Q & R](u: U);\n\nfn F[T:! Transitive](t: T) {\n  var a: T.A = t.GetA();\n\n  // \u2705 Allowed: `T.A` == `T.C`\n  t.TakesC(a);\n  a.(R.InR());\n\n  // \u2705 Allowed: `T.A` implements `P`,\n  // `T.A` == `T.B` that implements `Q`, and\n  // `T.A` == `T.C` that implements `R`.\n  TakesPQR(a);\n}\n")),(0,i.kt)("p",null,"Since adding an ",(0,i.kt)("inlineCode",{parentName:"p"},"observe")," declaration only adds external implementations of\ninterfaces to generic types, they may be added without breaking existing code."),(0,i.kt)("h2",{id:"other-constraints-as-type-of-types"},"Other constraints as type-of-types"),(0,i.kt)("p",null,"There are some constraints that we will naturally represent as named\ntype-of-types. These can either be used directly to constrain a generic type\nparameter, or in a ",(0,i.kt)("inlineCode",{parentName:"p"},"where ... is ...")," clause to constrain an associated type."),(0,i.kt)("p",null,"The compiler determines which types implement these interfaces, developers can\nnot explicitly implement these interfaces for their own types."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," Are these names part of the prelude or in a standard library?"),(0,i.kt)("h3",{id:"is-a-derived-class"},"Is a derived class"),(0,i.kt)("p",null,"Given a type ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Extends(T)")," is a type-of-type whose values are types that are\nderived from ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),". That is, ",(0,i.kt)("inlineCode",{parentName:"p"},"Extends(T)")," is the set of all types ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," that are\nsubtypes of ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn F[T:! Extends(BaseType)](p: T*);\nfn UpCast[T:! Type](p: T*, U:! Type where T is Extends(.Self)) -> U*;\nfn DownCast[T:! Type](p: T*, U:! Extends(T)) -> U*;\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," Alternatively, we could define a new ",(0,i.kt)("inlineCode",{parentName:"p"},"extends")," operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn F[T:! Type where .Self extends BaseType](p: T*);\nfn UpCast[T:! Type](p: T*, U:! Type where T extends .Self) -> U*;\nfn DownCast[T:! Type](p: T*, U:! Type where .Self extends T) -> U*;\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison to other languages:")," In Swift, you can\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID282"},"add a required superclass to a type bound using ",(0,i.kt)("inlineCode",{parentName:"a"},"&")),"."),(0,i.kt)("h3",{id:"type-compatible-with-another-type"},"Type compatible with another type"),(0,i.kt)("p",null,"Given a type ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),", define the type-of-type ",(0,i.kt)("inlineCode",{parentName:"p"},"CompatibleWith(U)")," as follows:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"CompatibleWith(U)")," is a type whose values are types ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," such that ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),"\nare ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#compatible-types"},"compatible"),". That is values of types ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," can be cast back and forth without any change in representation (for\nexample ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is an ",(0,i.kt)("a",{parentName:"p",href:"#adapting-types"},"adapter")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),").")),(0,i.kt)("p",null,'To support this, we extend the requirements that type-of-types are allowed to\nhave to include a "data representation requirement" option.'),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"CompatibleWith")," determines an equivalence relationship between types.\nSpecifically, given two types ",(0,i.kt)("inlineCode",{parentName:"p"},"T1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"T2"),", they are equivalent if\n",(0,i.kt)("inlineCode",{parentName:"p"},"T1 is CompatibleWith(T2)"),". That is, if ",(0,i.kt)("inlineCode",{parentName:"p"},"T1")," has the type ",(0,i.kt)("inlineCode",{parentName:"p"},"CompatibleWith(T2)"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," Just like interface parameters, we require the user to supply ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),",\nthey may not be deduced. Specifically, this code would be illegal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn Illegal[U:! Type, T:! CompatibleWith(U)](x: T*) ...\n")),(0,i.kt)("p",null,"In general there would be multiple choices for ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," given a specific ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," here,\nand no good way of picking one. However, similar code is allowed if there is\nanother way of determining ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn Allowed[U:! Type, T:! CompatibleWith(U)](x: U*, y: T*) ...\n")),(0,i.kt)("h4",{id:"same-implementation-restriction"},"Same implementation restriction"),(0,i.kt)("p",null,"In some cases, we need to restrict to types that implement certain interfaces\nthe same way as the type ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"CompatibleWith(U, TT)")," are types satisfying\n",(0,i.kt)("inlineCode",{parentName:"p"},"CompatibleWith(U)")," that have the same implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"TT")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),".")),(0,i.kt)("p",null,"For example, if we have a type ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet(T)"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class HashSet(T:! Hashable) { ... }\n")),(0,i.kt)("p",null,"Then ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet(T)")," may be cast to ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet(U)")," if\n",(0,i.kt)("inlineCode",{parentName:"p"},"T is CompatibleWith(U, Hashable)"),". The one-parameter interpretation of\n",(0,i.kt)("inlineCode",{parentName:"p"},"CompatibleWith(U)")," is recovered by letting the default for the second ",(0,i.kt)("inlineCode",{parentName:"p"},"TT"),"\nparameter be ",(0,i.kt)("inlineCode",{parentName:"p"},"Type"),"."),(0,i.kt)("h4",{id:"example-multiple-implementations-of-the-same-interface"},"Example: Multiple implementations of the same interface"),(0,i.kt)("p",null,"This allows us to represent functions that accept multiple implementations of\nthe same interface for a type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"enum CompareResult { Less, Equal, Greater }\ninterface Comparable {\n  fn Compare[me: Self](rhs: Self) -> CompareResult;\n}\nfn CombinedLess[T:! Type](a: T, b: T,\n                          U:! CompatibleWith(T) & Comparable,\n                          V:! CompatibleWith(T) & Comparable) -> bool {\n  match ((a as U).Compare(b as U)) {\n    case CompareResult.Less => { return True; }\n    case CompareResult.Greater => { return False; }\n    case CompareResult.Equal => {\n      return (a as V).Compare(b as V) == CompareResult.Less;\n    }\n  }\n}\n")),(0,i.kt)("p",null,"Used as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Song { ... }\nadapter SongByArtist for Song { impl as Comparable { ... } }\nadapter SongByTitle for Song { impl as Comparable { ... } }\nvar s1: Song = ...;\nvar s2: Song = ...;\nassert(CombinedLess(s1, s2, SongByArtist, SongByTitle) == True);\n")),(0,i.kt)("p",null,"We might generalize this to a list of implementations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn CombinedCompare[T:! Type]\n    (a: T, b: T, CompareList:! List(CompatibleWith(T) & Comparable))\n    -> CompareResult {\n  for (let U:! auto in CompareList) {\n    var result: CompareResult = (a as U).Compare(b);\n    if (result != CompareResult.Equal) {\n      return result;\n    }\n  }\n  return CompareResult.Equal;\n}\n\nassert(CombinedCompare(Song(...), Song(...), (SongByArtist, SongByTitle)) ==\n       CompareResult.Less);\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," How are compile-time lists of types declared and iterated\nthrough? They will also be needed for\n",(0,i.kt)("a",{parentName:"p",href:"#variadic-arguments"},"variadic argument support"),"."),(0,i.kt)("h4",{id:"example-creating-an-impl-out-of-other-impls"},"Example: Creating an impl out of other impls"),(0,i.kt)("p",null,"And then to package this functionality as an implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable"),", we\ncombine ",(0,i.kt)("inlineCode",{parentName:"p"},"CompatibleWith")," with ",(0,i.kt)("a",{parentName:"p",href:"#adapting-types"},"type adaptation"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"adapter ThenCompare(\n      T:! Type,\n      CompareList:! List(CompatibleWith(T) & Comparable))\n    for T {\n  impl as Comparable {\n    fn Compare[me: Self](rhs: Self) -> CompareResult {\n      for (let U:! auto in CompareList) {\n        var result: CompareResult = (me as U).Compare(rhs as U);\n        if (result != CompareResult.Equal) {\n          return result;\n        }\n      }\n      return CompareResult.Equal;\n    }\n  }\n}\n\nlet SongByArtistThenTitle: auto =\n    ThenCompare(Song, (SongByArtist, SongByTitle));\nvar s1: Song = ...;\nvar s2: SongByArtistThenTitle =\n    Song(...) as SongByArtistThenTitle;\nassert((s1 as SongByArtistThenTitle).Compare(s2) ==\n       CompareResult.Less);\n")),(0,i.kt)("h3",{id:"sized-types-and-type-of-types"},"Sized types and type-of-types"),(0,i.kt)("p",null,"What is the size of a type?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It could be fully known and fixed at compile time -- this is true of\nprimitive types (",(0,i.kt)("inlineCode",{parentName:"li"},"i32"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"f64"),", and so on), most\n",(0,i.kt)("a",{parentName:"li",href:"/docs/design/classes.md"},"classes"),", and most other concrete types."),(0,i.kt)("li",{parentName:"ul"},"It could be known generically. This means that it will be known at codegen\ntime, but not at type-checking time."),(0,i.kt)("li",{parentName:"ul"},"It could be dynamic. For example, it could be a\n",(0,i.kt)("a",{parentName:"li",href:"#runtime-type-fields"},"dynamic type"),", a slice, variable-sized type (such as\n",(0,i.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/nomicon/exotic-sizes.html#dynamically-sized-types-dsts"},"found in Rust"),"),\nor you could dereference a pointer to a base class that could actually point\nto a ",(0,i.kt)("a",{parentName:"li",href:"/docs/design/classes.md#inheritance"},"derived class"),"."),(0,i.kt)("li",{parentName:"ul"},"It could be unknown which category the type is in. In practice this will be\nessentially equivalent to having dynamic size.")),(0,i.kt)("p",null,"A type is called ",(0,i.kt)("em",{parentName:"p"},"sized")," if it is in the first two categories, and ",(0,i.kt)("em",{parentName:"p"},"unsized"),'\notherwise. Note: something with size 0 is still considered "sized". The\ntype-of-type ',(0,i.kt)("inlineCode",{parentName:"p"},"Sized")," is defined as follows:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"Sized")," is a type whose values are types ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),' that are "sized" -- that is the\nsize of ',(0,i.kt)("inlineCode",{parentName:"p"},"T")," is known, though possibly only generically.")),(0,i.kt)("p",null,"Knowing a type is sized is a precondition to declaring variables of that type,\ntaking values of that type as parameters, returning values of that type, and\ndefining arrays of that type. Users will not typically need to express the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Sized")," constraint explicitly, though, since it will usually be a dependency of\nsome other constraint the type will need such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Movable")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Concrete"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:"),' The compiler will determine which types are "sized", this is not\nsomething types will implement explicitly like ordinary interfaces.'),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'// In the Carbon standard library\ninterface DefaultConstructible {\n  // Types must be sized to be default constructible.\n  impl as Sized;\n  fn Default() -> Self;\n}\n\n// Classes are "sized" by default.\nclass Name {\n  impl as DefaultConstructible {\n    fn Default() -> Self { ... }\n  }\n  ...\n}\n\nfn F[T:! Type](x: T*) {  // T is unsized.\n  // \u2705 Allowed: may access unsized values through a pointer.\n  var y: T* = x;\n  // \u274c Illegal: T is unsized.\n  var z: T;\n}\n\n// T is sized, but its size is only known generically.\nfn G[T: DefaultConstructible](x: T*) {\n  // \u2705 Allowed: T is default constructible, which means sized.\n  var y: T = T.Default();\n}\n\nvar z: Name = Name.Default();;\n// \u2705 Allowed: `Name` is sized and implements `DefaultConstructible`.\nG(&z);\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," Even if the size is fixed, it won't be known at the time of\ncompiling the generic function if we are using the dynamic strategy. Should we\nautomatically\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Object_type_(object-oriented_programming)#Boxing"},"box"),"\nlocal variables when using the dynamic strategy? Or should we only allow\n",(0,i.kt)("inlineCode",{parentName:"p"},"MaybeBox")," values to be instantiated locally? Or should this just be a case\nwhere the compiler won't necessarily use the dynamic strategy?"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," Should the ",(0,i.kt)("inlineCode",{parentName:"p"},"Sized")," type-of-type expose an associated constant\nwith the size? So you could say ",(0,i.kt)("inlineCode",{parentName:"p"},"T.ByteSize")," in the above example to get a\ngeneric int value with the size of ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),". Similarly you might say ",(0,i.kt)("inlineCode",{parentName:"p"},"T.ByteStride"),"\nto get the number of bytes used for each element of an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,i.kt)("h4",{id:"implementation-model-2"},"Implementation model"),(0,i.kt)("p",null,"This requires a special integer field be included in the witness table type to\nhold the size of the type. This field will only be known generically, so if its\nvalue is used for type checking, we need some way of evaluating those type tests\nsymbolically."),(0,i.kt)("h3",{id:"typeid"},(0,i.kt)("inlineCode",{parentName:"h3"},"TypeId")),(0,i.kt)("p",null,"There are some capabilities every type can provide. For example, every type\nshould be able to return its name or identify whether it is equal to another\ntype. It is rare, however, for code to need to access these capabilities, so we\nrelegate these capabilities to an interface called ",(0,i.kt)("inlineCode",{parentName:"p"},"TypeId")," that all types\nautomatically implement. This way generic code can indicate that it needs those\ncapabilities by including ",(0,i.kt)("inlineCode",{parentName:"p"},"TypeId")," in the list of requirements. In the case\nwhere no type capabilities are needed, for example the code is only manipulating\npointers to the type, you would write ",(0,i.kt)("inlineCode",{parentName:"p"},"T:! Type")," and get the efficiency of\n",(0,i.kt)("inlineCode",{parentName:"p"},"void*")," but without giving up type safety."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn SortByAddress[T:! Type](v: Vector(T*)*) { ... }\n")),(0,i.kt)("p",null,"In particular, the compiler should in general avoid monomorphizing to generate\nmultiple instantiations of the function in this case."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," Should ",(0,i.kt)("inlineCode",{parentName:"p"},"TypeId")," be\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#external-impl"},"implemented externally")," for types to avoid name\npollution (",(0,i.kt)("inlineCode",{parentName:"p"},".TypeName"),", ",(0,i.kt)("inlineCode",{parentName:"p"},".TypeHash"),", etc.) unless the function specifically\nrequests those capabilities?"),(0,i.kt)("h3",{id:"destructor-constraints"},"Destructor constraints"),(0,i.kt)("p",null,"There are four type-of-types related to\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/classes.md#destructors"},"the destructors of types"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Concrete")," types may be local or member variables."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Deletable")," types may be safely deallocated by pointer using the ",(0,i.kt)("inlineCode",{parentName:"li"},"Delete"),"\nmethod on the ",(0,i.kt)("inlineCode",{parentName:"li"},"Allocator")," used to allocate it."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Destructible")," types have a destructor and may be deallocated by pointer\nusing the ",(0,i.kt)("inlineCode",{parentName:"li"},"UnsafeDelete")," method on the correct ",(0,i.kt)("inlineCode",{parentName:"li"},"Allocator"),", but it may be\nunsafe. The concerning case is deleting a pointer to a derived class through\na pointer to its base class without a virtual destructor."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TrivialDestructor")," types have empty destructors. This type-of-type may be\nused with ",(0,i.kt)("a",{parentName:"li",href:"#lookup-resolution-and-specialization"},"specialization")," to unlock\nspecific optimizations.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," The names ",(0,i.kt)("inlineCode",{parentName:"p"},"Deletable")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Destructible")," are\n",(0,i.kt)("a",{parentName:"p",href:"/proposals/p1154.md#type-of-type-naming"},(0,i.kt)("strong",{parentName:"a"},"placeholders"))," since they do not\nconform to the decision on\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/1058"},'question-for-leads issue #1058: "How should interfaces for core functionality be named?"'),"."),(0,i.kt)("p",null,"The type-of-types ",(0,i.kt)("inlineCode",{parentName:"p"},"Concrete"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Deletable"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"TrivialDestructor")," all extend\n",(0,i.kt)("inlineCode",{parentName:"p"},"Destructible"),". Combinations of them may be formed using\n",(0,i.kt)("a",{parentName:"p",href:"#combining-interfaces-by-anding-type-of-types"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"&")," operator"),". For example,\na generic function that both instantiates and deletes values of a type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," would\nrequire ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Concrete & Deletable"),"."),(0,i.kt)("p",null,"Types are forbidden from explicitly implementing these type-of-types directly.\nInstead they use\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/classes.md#destructors"},(0,i.kt)("inlineCode",{parentName:"a"},"destructor")," declarations in their class definition"),"\nand the compiler uses them to determine which of these type-of-types are\nimplemented."),(0,i.kt)("h2",{id:"generic-let"},"Generic ",(0,i.kt)("inlineCode",{parentName:"h2"},"let")),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," statement inside a function body may be used to get the change in type\nbehavior of calling a generic function without having to introduce a function\ncall."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn F(...) {\n  ...\n  let T:! C = U;\n  X;\n  Y;\n  Z;\n}\n")),(0,i.kt)("p",null,"gets rewritten to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn F(...) {\n  ...\n  fn Closure(T:! C where .Self == U) {\n    X;\n    Y;\n    Z;\n  }\n  Closure(U);\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"where .Self == U")," modifier allows values to implicitly convert between type\n",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", the erased type, and type ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),", the concrete type. Note that implicit\nconversion is\n",(0,i.kt)("a",{parentName:"p",href:"#manual-type-equality"},"only performed across a single ",(0,i.kt)("inlineCode",{parentName:"a"},"where")," equality"),". This\ncan be used to switch to the API of ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," when it is external, as an alternative\nto ",(0,i.kt)("a",{parentName:"p",href:"#use-case-accessing-external-names"},"using an adapter"),", or to simplify\ninlining of a generic function while preserving semantics."),(0,i.kt)("h2",{id:"parameterized-impls"},"Parameterized impls"),(0,i.kt)("p",null,"There are cases where an impl definition should apply to more than a single type\nand interface combination. The solution is to parameterize the impl definition,\nso it applies to a family of types, interfaces, or both. This includes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Declare an impl for a parameterized type, which may be external or declared\nout-of-line."),(0,i.kt)("li",{parentName:"ul"},'"Conditional conformance" where a parameterized type implements some\ninterface if the parameter to the type satisfies some criteria, like\nimplementing the same interface.'),(0,i.kt)("li",{parentName:"ul"},'"Blanket" impls where an interface is implemented for all types that\nimplement another interface, or some other criteria beyond being a specific\ntype.'),(0,i.kt)("li",{parentName:"ul"},'"Wildcard" impls where a family of interfaces are implemented for single\ntype.')),(0,i.kt)("h3",{id:"impl-for-a-parameterized-type"},"Impl for a parameterized type"),(0,i.kt)("p",null,"Interfaces may be implemented for a parameterized type. This can be done\nlexically in the class' scope:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Vector(T:! Type) {\n  impl as Iterable where .ElementType = T {\n    ...\n  }\n}\n")),(0,i.kt)("p",null,"This is equivalent to naming the type between ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"as"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Vector(T:! Type) {\n  impl Vector(T) as Iterable where .ElementType = T {\n    ...\n  }\n}\n")),(0,i.kt)("p",null,"An impl may be declared ",(0,i.kt)("a",{parentName:"p",href:"#external-impl"},"external")," by adding an ",(0,i.kt)("inlineCode",{parentName:"p"},"external"),"\nkeyword before ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),". External impls may also be declared out-of-line, but all\nparameters must be declared in a ",(0,i.kt)("inlineCode",{parentName:"p"},"forall")," clause:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"external impl forall [T:! Type] Vector(T) as Iterable\n    where .ElementType = T {\n  ...\n}\n")),(0,i.kt)("p",null,"The parameter for the type can be used as an argument to the interface being\nimplemented:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class HashMap(Key:! Hashable, Value:! Type) {\n  impl as Has(Key) { ... }\n  impl as Contains(HashSet(Key)) { ... }\n}\n")),(0,i.kt)("p",null,"or externally out-of-line:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class HashMap(Key:! Hashable, Value:! Type) { ... }\nexternal impl forall [Key:! Hashable, Value:! Type]\n    HashMap(Key, Value) as Has(Key) { ... }\nexternal impl forall [Key:! Hashable, Value:! Type]\n    HashMap(Key, Value) as Contains(HashSet(Key)) { ... }\n")),(0,i.kt)("h3",{id:"conditional-conformance"},"Conditional conformance"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#conditional-conformance"},"Conditional conformance")," is expressing\nthat we have an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," of some interface for some type, but only if some\nadditional type restrictions are met. Examples where this would be useful\ninclude being able to say that a container type, like ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),", implements some\ninterface when its element type satisfies the same interface:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A container is printable if its elements are."),(0,i.kt)("li",{parentName:"ul"},"A container could be compared to another container with the same element\ntype using a\n",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Lexicographic_order"},"lexicographic comparison"),"\nif the element type is comparable."),(0,i.kt)("li",{parentName:"ul"},"A container is copyable if its elements are.")),(0,i.kt)("p",null,"To do this with an ",(0,i.kt)("a",{parentName:"p",href:"#external-impl"},(0,i.kt)("inlineCode",{parentName:"a"},"external impl")),", specify a more-specific\n",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," type to the left of the ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," in the declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'interface Printable {\n  fn Print[me: Self]();\n}\nclass Vector(T:! Type) { ... }\n\n// By saying "T:! Printable" instead of "T:! Type" here,\n// we constrain T to be Printable for this impl.\nexternal impl forall [T:! Printable] Vector(T) as Printable {\n  fn Print[me: Self]() {\n    for (let a: T in me) {\n      // Can call `Print` on `a` since the constraint\n      // on `T` ensures it implements `Printable`.\n      a.Print();\n    }\n  }\n}\n')),(0,i.kt)("p",null,"To define these ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),"s inline in a ",(0,i.kt)("inlineCode",{parentName:"p"},"class")," definition, include a ",(0,i.kt)("inlineCode",{parentName:"p"},"forall"),"\nclause with a more-specific type between the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," keywords."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Array(T:! Type, template N:! Int) {\n  impl forall [P:! Printable] Array(P, N) as Printable { ... }\n}\n")),(0,i.kt)("p",null,"It is legal to add the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"external")," before the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," keyword to switch to\nan external impl defined lexically within the class scope. Inside the scope,\nboth ",(0,i.kt)("inlineCode",{parentName:"p"},"P")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," refer to the same type, but ",(0,i.kt)("inlineCode",{parentName:"p"},"P")," has the type-of-type of\n",(0,i.kt)("inlineCode",{parentName:"p"},"Printable")," and so has a ",(0,i.kt)("inlineCode",{parentName:"p"},"Print")," member. The relationship between ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"P")," is\nas if there was a ",(0,i.kt)("inlineCode",{parentName:"p"},"where P == T")," clause."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"TODO:")," Need to resolve whether the ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," name can be reused, or if we require\nthat you need to use new names, like ",(0,i.kt)("inlineCode",{parentName:"p"},"P"),", when creating new type variables."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")," Consider a type with two parameters, like ",(0,i.kt)("inlineCode",{parentName:"p"},"Pair(T, U)"),". In this\nexample, the interface ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo(T)")," is only implemented when the two types are\nequal."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Foo(T:! Type) { ... }\nclass Pair(T:! Type, U:! Type) { ... }\nexternal impl forall [T:! Type] Pair(T, T) as Foo(T) { ... }\n")),(0,i.kt)("p",null,"You may also define the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," inline, in which case it can be internal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Pair(T:! Type, U:! Type) {\n  impl Pair(T, T) as Foo(T) { ... }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Clarification:")," Method lookup will look at all internal implementations,\nwhether or not the conditions on those implementations hold for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," type.\nIf the conditions don't hold, then the call will be rejected because ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," has\nthe wrong type, just like any other argument/parameter type mismatch. This means\ntypes may not implement two different interfaces internally if they share a\nmember name, even if their conditions are mutually exclusive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class X(T:! Type) {\n  impl X(i32) as Foo {\n    fn F[me: Self]();\n  }\n  impl X(i64) as Bar {\n    // \u274c Illegal: name conflict between `Foo.F` and `Bar.F`\n    fn F[me: Self](n: i64);\n  }\n}\n")),(0,i.kt)("p",null,"However, the same interface may be implemented multiple times as long as there\nis no overlap in the conditions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class X(T:! Type) {\n  impl X(i32) as Foo {\n    fn F[me: Self]();\n  }\n  impl X(i64) as Foo {\n    // \u2705 Allowed: `X(T).F` consistently means `X(T).(Foo.F)`\n    fn F[me: Self]();\n  }\n}\n")),(0,i.kt)("p",null,"This allows a type to express that it implements an interface for a list of\ntypes, possibly with different implementations."),(0,i.kt)("p",null,"In general, ",(0,i.kt)("inlineCode",{parentName:"p"},"X(T).F")," can only mean one thing, regardless of ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:"),"\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md"},"Swift supports conditional conformance"),",\nbut bans cases where there could be ambiguity from overlap.\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/rust-by-example/generics/where.html"},"Rust also supports conditional conformance"),"."),(0,i.kt)("h4",{id:"conditional-methods"},"Conditional methods"),(0,i.kt)("p",null,"A method could be defined conditionally for a type by using a more specific type\nin place of ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," in the method declaration. For example, this is how to define\na vector type that only has a ",(0,i.kt)("inlineCode",{parentName:"p"},"Sort")," method if its elements implement the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable")," interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Vector(T:! Type) {\n  // `Vector(T)` has a `Sort()` method if `T` is `Comparable`.\n  fn Sort[C:! Comparable, addr me: Vector(C)*]();\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," In\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods"},"Rust"),"\nthis feature is part of conditional conformance. Swift supports conditional\nmethods using\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID553"},"conditional extensions"),"\nor\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID628"},"contextual where clauses"),"."),(0,i.kt)("h3",{id:"blanket-impls"},"Blanket impls"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"blanket impl")," is an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," that could apply to more than one root type, so\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," will use a type variable for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," type. Here are some examples\nwhere blanket impls arise:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Any type implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Ordered")," should get an implementation of\n",(0,i.kt)("inlineCode",{parentName:"p"},"PartiallyOrdered"),"."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"external impl forall [T:! Ordered] T as PartiallyOrdered { ... }\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"T")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"CommonType(T)")," for all ",(0,i.kt)("inlineCode",{parentName:"p"},"T")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"external impl forall [T:! Type] T as CommonType(T)\n    where .Result = T { }\n")),(0,i.kt)("p",{parentName:"li"},"This means that every type is the common type with itself."))),(0,i.kt)("p",null,"Blanket impls must always be ",(0,i.kt)("a",{parentName:"p",href:"#external-impl"},"external")," and defined lexically\nout-of-line."),(0,i.kt)("h4",{id:"difference-between-blanket-impls-and-named-constraints"},"Difference between blanket impls and named constraints"),(0,i.kt)("p",null,'A blanket interface can be used to say "any type implementing ',(0,i.kt)("inlineCode",{parentName:"p"},"interface I")," also\nimplements ",(0,i.kt)("inlineCode",{parentName:"p"},"interface B"),'." Compare this with defining a ',(0,i.kt)("inlineCode",{parentName:"p"},"constraint C")," that\nrequires ",(0,i.kt)("inlineCode",{parentName:"p"},"I"),". In that case, ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," will also be implemented any time ",(0,i.kt)("inlineCode",{parentName:"p"},"I")," is. There\nare differences though:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"There can be other implementations of ",(0,i.kt)("inlineCode",{parentName:"li"},"interface B")," without a corresponding\nimplementation of ",(0,i.kt)("inlineCode",{parentName:"li"},"I"),", unless ",(0,i.kt)("inlineCode",{parentName:"li"},"B")," has a requirement on ",(0,i.kt)("inlineCode",{parentName:"li"},"I"),". However, the\ntypes implementing ",(0,i.kt)("inlineCode",{parentName:"li"},"C")," will be the same as the types implementing ",(0,i.kt)("inlineCode",{parentName:"li"},"I"),"."),(0,i.kt)("li",{parentName:"ul"},"More specialized implementations of ",(0,i.kt)("inlineCode",{parentName:"li"},"B")," can override the blanket\nimplementation.")),(0,i.kt)("h3",{id:"wildcard-impls"},"Wildcard impls"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"wildcard impl")," is an impl that defines a family of interfaces for a single\n",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," type. For example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"BigInt")," type might implement ",(0,i.kt)("inlineCode",{parentName:"p"},"AddTo(T)")," for all\n",(0,i.kt)("inlineCode",{parentName:"p"},"T")," that implement ",(0,i.kt)("inlineCode",{parentName:"p"},"ImplicitAs(i32)"),". The implementation would first convert ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," and then add the ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"BigInt")," value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class BigInt {\n  external impl forall [T:! ImplicitAs(i32)] as AddTo(T) { ... }\n}\n// Or out-of-line:\nexternal impl forall [T:! ImplicitAs(i32)] BigInt as AddTo(T) { ... }\n")),(0,i.kt)("p",null,"Wildcard impls must always be ",(0,i.kt)("a",{parentName:"p",href:"#external-impl"},"external"),", to avoid having the\nnames in the interface defined for the type multiple times."),(0,i.kt)("h3",{id:"combinations"},"Combinations"),(0,i.kt)("p",null,"The different kinds of parameters to impls may be combined. For example, if ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"\nimplements ",(0,i.kt)("inlineCode",{parentName:"p"},"As(U)"),", then this implements ",(0,i.kt)("inlineCode",{parentName:"p"},"As(Optional(U))")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional(T)"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"external impl forall [U:! Type, T:! As(U)]\n  Optional(T) as As(Optional(U)) { ... }\n")),(0,i.kt)("p",null,"This has a wildcard parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"U"),", and a condition on parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,i.kt)("h3",{id:"lookup-resolution-and-specialization"},"Lookup resolution and specialization"),(0,i.kt)("p",null,"As much as possible, we want rules for where an impl is allowed to be defined\nand for selecting which impl to use that achieve these three goals:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Implementations have coherence, as\n",(0,i.kt)("a",{parentName:"li",href:"/design/generics/terminology#coherence"},"defined in terminology"),". This is\n",(0,i.kt)("a",{parentName:"li",href:"/design/generics/goals#coherence"},"a goal for Carbon"),". More detail can be found in\n",(0,i.kt)("a",{parentName:"li",href:"/design/generics/appendix-coherence"},"this appendix with the rationale and alternatives considered"),"."),(0,i.kt)("li",{parentName:"ul"},"Libraries will work together as long as they pass their separate checks."),(0,i.kt)("li",{parentName:"ul"},"A generic function can assume that some impl will be successfully selected\nif it can see an impl that applies, even though another more specific impl\nmay be selected.")),(0,i.kt)("p",null,"For this to work, we need a rule that picks a single ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," in the case where\nthere are multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," definitions that match a particular type and interface\ncombination. This is called ",(0,i.kt)("em",{parentName:"p"},"specialization")," when the rule is that most specific\nimplementation is chosen, for some definition of specific."),(0,i.kt)("h4",{id:"type-structure-of-an-impl-declaration"},"Type structure of an impl declaration"),(0,i.kt)("p",null,"Given an impl declaration, find the type structure by deleting deduced\nparameters and replacing type parameters by a ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),". The type structure of this\ndeclaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"impl forall [T:! ..., U:! ...] Foo(T, i32) as Bar(String, U) { ... }\n")),(0,i.kt)("p",null,"is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"impl Foo(?, i32) as Bar(String, ?)\n")),(0,i.kt)("p",null,"To get a uniform representation across different ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," definitions, before type\nparameters are replaced the declarations are normalized as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"For impls declared lexically inline in a class definition, the type is added\nbetween the ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"as")," keywords if the type is left out."),(0,i.kt)("li",{parentName:"ul"},"Pointer types ",(0,i.kt)("inlineCode",{parentName:"li"},"T*")," are replaced with ",(0,i.kt)("inlineCode",{parentName:"li"},"Ptr(T)"),"."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"external")," keyword is removed, if present."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"forall")," clause introducing type parameters is removed, if present."),(0,i.kt)("li",{parentName:"ul"},"Any ",(0,i.kt)("inlineCode",{parentName:"li"},"where")," clauses that are setting associated constants or types are\nremoved.")),(0,i.kt)("p",null,"The type structure will always contain a single interface name, which is the\nname of the interface being implemented, and some number of type names. Type\nnames can be in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," type to the left of the ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," keyword, or as\nparameters to other types or the interface. These names must always be defined\neither in the current library or be publicly defined in some library this\nlibrary depends on."),(0,i.kt)("h4",{id:"orphan-rule"},"Orphan rule"),(0,i.kt)("p",null,"To achieve coherence, we need to ensure that any given impl can only be defined\nin a library that must be imported for it to apply. Specifically, given a\nspecific type and specific interface, impls that can match can only be in\nlibraries that must have been imported to name that type or interface. This is\nachieved with the ",(0,i.kt)("em",{parentName:"p"},"orphan rule"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Orphan rule:")," Some name from the type structure of an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," declaration must\nbe defined in the same library as the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),", that is some name must be ",(0,i.kt)("em",{parentName:"p"},"local"),"."),(0,i.kt)("p",null,"Only the implementing interface and types (self type and type parameters) in the\ntype structure are relevant here; an interface mentioned in a constraint is not\nsufficient since it\n",(0,i.kt)("a",{parentName:"p",href:"/proposals/p0920.md#orphan-rule-could-consider-interface-requirements-in-blanket-impls"},"need not be imported"),"."),(0,i.kt)("p",null,"Since Carbon in addition requires there be no cyclic library dependencies, we\nconclude that there is at most one library that can define impls with a\nparticular type structure."),(0,i.kt)("h4",{id:"overlap-rule"},"Overlap rule"),(0,i.kt)("p",null,"Given a specific concrete type, say ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo(bool, i32)"),", and an interface, say\n",(0,i.kt)("inlineCode",{parentName:"p"},"Bar(String, f32)"),', the overlap rule picks, among all the matching impls, which\ntype structure is considered "most specific" to use as the implementation of\nthat type for that interface.'),(0,i.kt)("p",null,"Given two different type structures of impls matching a query, for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"impl Foo(?, i32) as Bar(String, ?)\nimpl Foo(?, ?) as Bar(String, f32)\n")),(0,i.kt)("p",null,"We pick the type structure with a non-",(0,i.kt)("inlineCode",{parentName:"p"},"?")," at the first difference as most\nspecific. Here we see a difference between ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo(?, i32)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo(?, ?)"),", so we\nselect the one with ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo(?, i32)"),", ignoring the fact that it has another ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),"\nlater in its type structure"),(0,i.kt)("p",null,"This rule corresponds to a depth-first traversal of the type tree to identify\nthe first difference, and then picking the most specific choice at that\ndifference."),(0,i.kt)("h4",{id:"prioritization-rule"},"Prioritization rule"),(0,i.kt)("p",null,"Since at most one library can define impls with a given type structure, all\nimpls with a given type structure must be in the same library. Furthermore by\nthe ",(0,i.kt)("a",{parentName:"p",href:"#access"},"impl declaration access rules"),", they will be defined in the API\nfile for the library if they could match any query from outside the library. If\nthere is more than one impl with that type structure, they must be\n",(0,i.kt)("a",{parentName:"p",href:"#implementing-interfaces"},"defined")," or ",(0,i.kt)("a",{parentName:"p",href:"#declaring-implementations"},"declared"),"\ntogether in a prioritization block. Once a type structure is selected for a\nquery, the first impl in the prioritization block that matches is selected."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," How are prioritization blocks written? A block starts with a\nkeyword like ",(0,i.kt)("inlineCode",{parentName:"p"},"match_first")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"impl_priority")," and then a sequence of impl\ndeclarations inside matching curly braces ",(0,i.kt)("inlineCode",{parentName:"p"},"{")," ... ",(0,i.kt)("inlineCode",{parentName:"p"},"}"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"match_first {\n  // If T is Foo prioritized ahead of T is Bar\n  impl forall [T:! Foo] T as Bar { ... }\n  impl forall [T:! Baz] T as Bar { ... }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," How do we pick between two different prioritization blocks\nwhen they contain a mixture of type structures? There are three options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Prioritization blocks implicitly define all non-empty intersections of\ncontained impls, which are then selected by their type structure."),(0,i.kt)("li",{parentName:"ul"},"The compiler first picks the impl with the type pattern most favored for the\nquery, and then picks the definition of the highest priority matching impl\nin the same prioritization block."),(0,i.kt)("li",{parentName:"ul"},"All the impls in a prioritization block are required to have the same type\nstructure, at a cost in expressivity.")),(0,i.kt)("p",null,"To see the difference between the first two options, consider two libraries with\ntype structures as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Library B has ",(0,i.kt)("inlineCode",{parentName:"li"},"impl (A, ?, ?, D) as I")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"impl (?, B, ?, D) as I")," in the\nsame prioritization block."),(0,i.kt)("li",{parentName:"ul"},"Library C has ",(0,i.kt)("inlineCode",{parentName:"li"},"impl (A, ?, C, ?) as I"),".")),(0,i.kt)("p",null,"For the query ",(0,i.kt)("inlineCode",{parentName:"p"},"(A, B, C, D) as I"),", using the intersection rule, library B is\nconsidered to have the intersection impl with type structure\n",(0,i.kt)("inlineCode",{parentName:"p"},"impl (A, B, ?, D) as I")," which is the most specific. If we instead just\nconsidered the rules mentioned explicitly, then ",(0,i.kt)("inlineCode",{parentName:"p"},"impl (A, ?, C, ?) as I")," from\nlibrary C is the most specific. The advantage of the implicit intersection rule\nis that if library B is changed to add an impl with type structure\n",(0,i.kt)("inlineCode",{parentName:"p"},"impl (A, B, ?, D) as I"),", it won't shift which library is serving that query."),(0,i.kt)("h4",{id:"acyclic-rule"},"Acyclic rule"),(0,i.kt)("p",null,'A cycle is when a query, such as "does type ',(0,i.kt)("inlineCode",{parentName:"p"},"T")," implement interface ",(0,i.kt)("inlineCode",{parentName:"p"},"I"),'?",\nconsiders an impl that might match, and whether that impl matches is ultimately\ndependent on whether that query is true. These are cycles in the graph of (type,\ninterface) pairs where there is an edge from pair A to pair B if whether type A\nimplements interface A determines whether type B implements interface B.'),(0,i.kt)("p",null,"The test for whether something forms a cycle needs to be precise enough, and not\nerase too much information when considering this graph, that these impls are not\nconsidered to form cycles with themselves:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"impl forall [T:! Printable] Optional(T) as Printable;\nimpl forall [T:! Type, U:! ComparableTo(T)] U as ComparableTo(Optional(T));\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")," If ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"ComparableWith(U)"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," should implement\n",(0,i.kt)("inlineCode",{parentName:"p"},"ComparableWith(T)"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"external impl forall [U:! Type, T:! ComparableWith(U)]\n    U as ComparableWith(T);\n")),(0,i.kt)("p",null,"This is a cycle where which types implement ",(0,i.kt)("inlineCode",{parentName:"p"},"ComparableWith")," determines which\ntypes implement the same interface."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")," Cycles can create situations where there are multiple ways of\nselecting impls that are inconsistent with each other. Consider an interface\nwith two blanket ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," declarations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Y {}\nclass N {}\ninterface True {}\nimpl Y as True {}\ninterface Z(T:! Type) { let Cond:! Type; }\nmatch_first {\n  impl forall [T:! Type, U:! Z(T) where .Cond is True] T as Z(U)\n      where .Cond = N { }\n  impl forall [T:! Type, U:! Type] T as Z(U)\n      where .Cond = Y { }\n}\n")),(0,i.kt)("p",null,"What is ",(0,i.kt)("inlineCode",{parentName:"p"},"i8.(Z(i16).Cond)"),"? It depends on which of the two blanket impls are\nselected."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An implementation of ",(0,i.kt)("inlineCode",{parentName:"li"},"Z(i16)")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"i8")," could come from the first blanket\nimpl with ",(0,i.kt)("inlineCode",{parentName:"li"},"T == i8")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"U == i16")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"i16 is Z(i8)")," and\n",(0,i.kt)("inlineCode",{parentName:"li"},"i16.(Z(i8).Cond) == Y"),". This condition is satisfied if ",(0,i.kt)("inlineCode",{parentName:"li"},"i16")," implements\n",(0,i.kt)("inlineCode",{parentName:"li"},"Z(i8)")," using the second blanket impl. In this case,\n",(0,i.kt)("inlineCode",{parentName:"li"},"i8.(Z(i16).Cond) == N"),"."),(0,i.kt)("li",{parentName:"ul"},"Equally well ",(0,i.kt)("inlineCode",{parentName:"li"},"Z(i8)")," could be implemented for ",(0,i.kt)("inlineCode",{parentName:"li"},"i16")," using the first blanket\nimpl and ",(0,i.kt)("inlineCode",{parentName:"li"},"Z(i16)")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"i8")," using the second. In this case,\n",(0,i.kt)("inlineCode",{parentName:"li"},"i8.(Z(i16).Cond) == Y"),".")),(0,i.kt)("p",null,"There is no reason to to prefer one of these outcomes over the other."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")," Further, cycles can create contradictions in the type system:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class A {}\nclass B {}\nclass C {}\ninterface D(T:! Type) { let Cond:! Type; }\nmatch_first {\n  impl forall [T:! Type, U:! D(T) where .Cond = B] T as D(U)\n      where .Cond = C { }\n  impl forall [T:! Type, U:! D(T) where .Cond = A] T as D(U)\n      where .Cond = B { }\n  impl forall [T:! Type, U:! Type] T as D(U)\n      where .Cond = A { }\n}\n")),(0,i.kt)("p",null,"What is ",(0,i.kt)("inlineCode",{parentName:"p"},"i8.(D(i16).Cond)"),"? The answer is determined by which blanket impl is\nselected to implement ",(0,i.kt)("inlineCode",{parentName:"p"},"D(i16)")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"i8"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If the third blanket impl is selected, then ",(0,i.kt)("inlineCode",{parentName:"li"},"i8.(D(i16).Cond) == A"),". This\nimplies that ",(0,i.kt)("inlineCode",{parentName:"li"},"i16.(D(i8).Cond) == B")," using the second blanket impl. If that\nis true, though, then our first impl choice was incorrect, since the first\nblanket impl applies and is higher priority. So ",(0,i.kt)("inlineCode",{parentName:"li"},"i8.(D(i16).Cond) == C"),". But\nthat means that ",(0,i.kt)("inlineCode",{parentName:"li"},"i16 as D(i8)")," can't use the second blanket impl."),(0,i.kt)("li",{parentName:"ul"},"For the second blanket impl to be selected, so ",(0,i.kt)("inlineCode",{parentName:"li"},"i8.(D(i16).Cond) == B"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"i16.(D(i8).Cond)")," would have to be ",(0,i.kt)("inlineCode",{parentName:"li"},"A"),". This happens when ",(0,i.kt)("inlineCode",{parentName:"li"},"i16")," implements\n",(0,i.kt)("inlineCode",{parentName:"li"},"D(i8)")," using the third blanket impl. However, ",(0,i.kt)("inlineCode",{parentName:"li"},"i8.(D(i16).Cond) == B")," means\nthat there is a higher priority implementation of ",(0,i.kt)("inlineCode",{parentName:"li"},"D(i8).Cond")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"i16"),".")),(0,i.kt)("p",null,"In either case, we arrive at a contradiction."),(0,i.kt)("p",null,"The workaround for this problem is to either split an interface in the cycle in\ntwo, with a blanket implementation of one from the other, or move some of the\ncriteria into a ",(0,i.kt)("a",{parentName:"p",href:"#named-constraints"},"named constraint"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Concern:")," Cycles could be spread out across libraries with no dependencies\nbetween them. This means there can be problems created by a library that are\nonly detected by its users."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," Should Carbon reject cycles in the absence of a query? The\ntwo options here are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Combining impls gives you an immediate error if there exists queries using\nthose impls that have cycles."),(0,i.kt)("li",{parentName:"ul"},"Only when a query reveals a cyclic dependency is an error reported.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," In the second case, should we ignore cycles if they don't\naffect the result of the query? For example, the cycle might be among\nimplementations that are lower priority."),(0,i.kt)("h4",{id:"termination-rule"},"Termination rule"),(0,i.kt)("p",null,"It is possible to define a set of impls where there isn't a cycle, but the graph\nis infinite. Without some rule to prevent exhaustive exploration of the graph,\ndetermining whether a type implements an interface could run forever."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")," It could be that ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),", so ",(0,i.kt)("inlineCode",{parentName:"p"},"A is B")," if\n",(0,i.kt)("inlineCode",{parentName:"p"},"Optional(A) is B"),", if ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional(Optional(A)) is B"),", and so on. This could be\nthe result of a single impl:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"impl forall [A:! Type where Optional(.Self) is B] A as B { ... }\n")),(0,i.kt)("p",null,"This problem can also result from a chain of impls, as in ",(0,i.kt)("inlineCode",{parentName:"p"},"A is B")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"A* is C"),",\nif ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional(A) is B"),", and so on."),(0,i.kt)("p",null,"Rust solves this problem by imposing a recursion limit, much like C++ compilers\nuse to terminate template recursion. This goes against\n",(0,i.kt)("a",{parentName:"p",href:"/design/generics/goals#predictability"},"Carbon's goal of predictability in generics"),", but at\nthis time there are no known alternatives. Unfortunately, the approach Carbon\nuses to avoid undecidability for type equality,\n",(0,i.kt)("a",{parentName:"p",href:"#manual-type-equality"},"providing an explicit proof in the source"),", can't be\nused here. The code triggering the query asking whether some type implements an\ninterface will typically be generic code with know specific knowledge about the\ntypes involved, and won't be in a position to provide a manual proof that the\nimplementation should exist."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Open question:")," Is there some restriction on ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," declarations that would\nallow our desired use cases, but allow the compiler to detect non-terminating\ncases? Perhaps there is some sort of complexity measure Carbon can require\ndoesn't increase when recursing?"),(0,i.kt)("h3",{id:"final-impls"},(0,i.kt)("inlineCode",{parentName:"h3"},"final")," impls"),(0,i.kt)("p",null,"There are cases where knowing that a parameterized impl won't be specialized is\nparticularly valuable. This could let the compiler know the return type of a\ngeneric function call, such as using an operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Interface defining the behavior of the prefix-* operator\ninterface Deref {\n  let Result:! Type;\n  fn DoDeref[me: Self]() -> Result;\n}\n\n// Types implementing `Deref`\nclass Ptr(T:! Type) {\n  ...\n  external impl as Deref where .Result = T {\n    fn DoDeref[me: Self]() -> Result { ... }\n  }\n}\nclass Optional(T:! Type) {\n  ...\n  external impl as Deref where .Result = T {\n    fn DoDeref[me: Self]() -> Result { ... }\n  }\n}\n\nfn F[T:! Type](x: T) {\n  // uses Ptr(T) and Optional(T) in implementation\n}\n")),(0,i.kt)("p",null,"The concern is the possibility of specializing ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional(T) as Deref")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"Ptr(T) as Deref")," for a more specific ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," means that the compiler can't assume\nanything about the return type of ",(0,i.kt)("inlineCode",{parentName:"p"},"Deref.DoDeref")," calls. This means ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," would in\npractice have to add a constraint, which is both verbose and exposes what should\nbe implementation details:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn F[T:! Type where Optional(T).(Deref.Result) == .Self\n                and Ptr(T).(Deref.Result) == .Self](x: T) {\n  // uses Ptr(T) and Optional(T) in implementation\n}\n")),(0,i.kt)("p",null,"To mark an impl as not able to be specialized, prefix it with the keyword\n",(0,i.kt)("inlineCode",{parentName:"p"},"final"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Ptr(T:! Type) {\n  ...\n  // Note: added `final`\n  final external impl as Deref where .Result = T {\n    fn DoDeref[me: Self]() -> Result { ... }\n  }\n}\nclass Optional(T:! Type) {\n  ...\n  // Note: added `final`\n  final external impl as Deref where .Result = T {\n    fn DoDeref[me: Self]() -> Result { ... }\n  }\n}\n\n// \u274c Illegal: external impl Ptr(i32) as Deref { ... }\n// \u274c Illegal: external impl Optional(i32) as Deref { ... }\n")),(0,i.kt)("p",null,"This prevents any higher-priority impl that overlaps a final impl from being\ndefined. Further, if the Carbon compiler sees a matching final impl, it can\nassume it won't be specialized so it can use the assignments of the associated\ntypes in that impl definition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"fn F[T:! Type](x: T) {\n  var p: Ptr(T) = ...;\n  // *p has type `T`\n  var o: Optional(T) = ...;\n  // *o has type `T`\n}\n")),(0,i.kt)("h4",{id:"libraries-that-can-contain-final-impls"},"Libraries that can contain ",(0,i.kt)("inlineCode",{parentName:"h4"},"final")," impls"),(0,i.kt)("p",null,"To prevent the possibility of two unrelated libraries defining conflicting\nimpls, Carbon restricts which libraries may declare an impl as ",(0,i.kt)("inlineCode",{parentName:"p"},"final")," to only:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the library declaring the impl's interface and"),(0,i.kt)("li",{parentName:"ul"},"the library declaring the root of the ",(0,i.kt)("inlineCode",{parentName:"li"},"Self")," type.")),(0,i.kt)("p",null,"This means:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A blanket impl with type structure ",(0,i.kt)("inlineCode",{parentName:"li"},"impl ? as MyInterface(...)")," may only be\ndefined in the same library as ",(0,i.kt)("inlineCode",{parentName:"li"},"MyInterface"),"."),(0,i.kt)("li",{parentName:"ul"},"An impl with type structure ",(0,i.kt)("inlineCode",{parentName:"li"},"impl MyType(...) as MyInterface(...)")," may be\ndefined in the library with ",(0,i.kt)("inlineCode",{parentName:"li"},"MyType")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"MyInterface"),".")),(0,i.kt)("p",null,"These restrictions ensure that the Carbon compiler can locally check that no\nhigher-priority impl is defined superseding a ",(0,i.kt)("inlineCode",{parentName:"p"},"final")," impl."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An impl with type structure ",(0,i.kt)("inlineCode",{parentName:"li"},"impl MyType(...) as MyInterface(...)")," defined\nin the library with ",(0,i.kt)("inlineCode",{parentName:"li"},"MyType")," must import the library defining ",(0,i.kt)("inlineCode",{parentName:"li"},"MyInterface"),",\nand so will be able to see any final blanket impls."),(0,i.kt)("li",{parentName:"ul"},"A blanket impl with type structure\n",(0,i.kt)("inlineCode",{parentName:"li"},"impl ? as MyInterface(...ParameterType(...)...)")," may be defined in the\nlibrary with ",(0,i.kt)("inlineCode",{parentName:"li"},"ParameterType"),", but that library must import the library\ndefining ",(0,i.kt)("inlineCode",{parentName:"li"},"MyInterface"),", and so will be able to see any ",(0,i.kt)("inlineCode",{parentName:"li"},"final")," blanket impls\nthat might overlap. A final impl with type structure\n",(0,i.kt)("inlineCode",{parentName:"li"},"impl MyType(...) as MyInterface(...)")," would be given priority over any\noverlapping blanket impl defined in the ",(0,i.kt)("inlineCode",{parentName:"li"},"ParameterType")," library."),(0,i.kt)("li",{parentName:"ul"},"An impl with type structure\n",(0,i.kt)("inlineCode",{parentName:"li"},"impl MyType(...ParameterType(...)...) as MyInterface(...)")," may be defined\nin the library with ",(0,i.kt)("inlineCode",{parentName:"li"},"ParameterType"),", but that library must import the\nlibraries defining ",(0,i.kt)("inlineCode",{parentName:"li"},"MyType")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"MyInterface"),", and so will be able to see\nany ",(0,i.kt)("inlineCode",{parentName:"li"},"final")," impls that might overlap.")),(0,i.kt)("h3",{id:"comparison-to-rust"},"Comparison to Rust"),(0,i.kt)("p",null,"Rust has been designing a specialization feature, but it has not been completed.\nLuckily, Rust team members have done a lot of blogging during their design\nprocess, so Carbon can benefit from the work they have done. However, getting\nspecialization to work for Rust is complicated by the need to maintain\ncompatibility with existing Rust code. This motivates a number of Rust rules\nwhere Carbon can be simpler. As a result there are both similarities and\ndifferences between the Carbon and Rust plans:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A Rust impl defaults to not being able to be specialized, with a ",(0,i.kt)("inlineCode",{parentName:"li"},"default"),"\nkeyword used to opt-in to allowing specialization, reflecting the existing\ncode base developed without specialization. Carbon impls default to allowing\nspecialization, with restrictions on which may be declared ",(0,i.kt)("inlineCode",{parentName:"li"},"final"),"."),(0,i.kt)("li",{parentName:"ul"},"Since Rust impls are not specializable by default, generic functions can\nassume that if a matching blanket impl is found, the associated types from\nthat impl will be used. In Carbon, if a generic function requires an\nassociated type to have a particular value, the function commonly will need\nto state that using an explicit constraint."),(0,i.kt)("li",{parentName:"ul"},'Carbon will not have the "fundamental" attribute used by Rust on types or\ntraits, as described in\n',(0,i.kt)("a",{parentName:"li",href:"https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html"},'Rust RFC 1023: "Rebalancing Coherence"'),"."),(0,i.kt)("li",{parentName:"ul"},'Carbon will not use "covering" rules, as described in\n',(0,i.kt)("a",{parentName:"li",href:"https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html"},'Rust RFC 2451: "Re-Rebalancing Coherence"'),"\nand\n",(0,i.kt)("a",{parentName:"li",href:"http://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/#the-covered-rule"},"Little Orphan Impls: The covered rule"),"."),(0,i.kt)("li",{parentName:"ul"},"Like Rust, Carbon does use ordering, favoring the ",(0,i.kt)("inlineCode",{parentName:"li"},"Self")," type and then the\nparameters to the interface in left-to-right order, see\n",(0,i.kt)("a",{parentName:"li",href:"https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html"},'Rust RFC 1023: "Rebalancing Coherence"'),"\nand\n",(0,i.kt)("a",{parentName:"li",href:"http://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/#the-ordered-rule"},"Little Orphan Impls: The ordered rule"),",\nbut the specifics are different."),(0,i.kt)("li",{parentName:"ul"},"Carbon is not planning to support any inheritance of implementation between\nimpls. This is more important to Rust since Rust does not support class\ninheritance for implementation reuse. Rust has considered multiple\napproaches here, see\n",(0,i.kt)("a",{parentName:"li",href:"http://aturon.github.io/tech/2015/09/18/reuse/"},'Aaron Turon: "Specialize to Reuse"'),"\nand\n",(0,i.kt)("a",{parentName:"li",href:"http://smallcultfollowing.com/babysteps/blog/2016/10/24/supporting-blanket-impls-in-specialization/"},"Supporting blanket impls in specialization"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"http://smallcultfollowing.com/babysteps/blog/2016/10/24/supporting-blanket-impls-in-specialization/"},"Supporting blanket impls in specialization"),"\nproposes a specialization rule for Rust that considers type structure before\nother constraints, as in Carbon, though the details differ."),(0,i.kt)("li",{parentName:"ul"},"Rust has more orphan restrictions to avoid there being cases where it is\nambiguous which impl should be selected. Carbon instead has picked a total\nordering on type structures, picking one as higher priority even without one\nbeing more specific in the sense of only applying to a subset of types.")),(0,i.kt)("h2",{id:"forward-declarations-and-cyclic-references"},"Forward declarations and cyclic references"),(0,i.kt)("p",null,"Interfaces, named constraints, and their implementations may be forward declared\nand then later defined. This is needed to allow cyclic references, for example\nwhen declaring the edges and nodes of a graph. It is also a tool that may be\nused to make code more readable."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"#interfaces"},"interface"),", ",(0,i.kt)("a",{parentName:"p",href:"#named-constraints"},"named constraint"),", and\n",(0,i.kt)("a",{parentName:"p",href:"#implementing-interfaces"},"implementation")," sections describe the syntax for\ntheir ",(0,i.kt)("em",{parentName:"p"},"definition"),", which consists of a declaration followed by a body contained\nin curly braces ",(0,i.kt)("inlineCode",{parentName:"p"},"{")," ... ",(0,i.kt)("inlineCode",{parentName:"p"},"}"),". A ",(0,i.kt)("em",{parentName:"p"},"forward declaration")," is a declaration followed\nby a semicolon ",(0,i.kt)("inlineCode",{parentName:"p"},";"),". A forward declaration is a promise that the entity being\ndeclared will be defined later. Between the first declaration of an entity,\nwhich may be in a forward declaration or the first part of a definition, and the\nend of the definition the interface or implementation is called ",(0,i.kt)("em",{parentName:"p"},"incomplete"),".\nThere are additional restrictions on how the name of an incomplete entity may be\nused."),(0,i.kt)("h3",{id:"declaring-interfaces-and-named-constraints"},"Declaring interfaces and named constraints"),(0,i.kt)("p",null,"The declaration for an interface or named constraint consists of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"an optional access-control keyword like ",(0,i.kt)("inlineCode",{parentName:"li"},"private"),","),(0,i.kt)("li",{parentName:"ul"},"the keyword introducer ",(0,i.kt)("inlineCode",{parentName:"li"},"interface"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"constraint"),", or ",(0,i.kt)("inlineCode",{parentName:"li"},"template constraint"),","),(0,i.kt)("li",{parentName:"ul"},"the name of the interface or constraint, and"),(0,i.kt)("li",{parentName:"ul"},"the parameter list, if any.")),(0,i.kt)("p",null,"The name of an interface or constraint can not be used until its first\ndeclaration is complete. In particular, it is illegal to use the name of the\ninterface in its parameter list. There is a\n",(0,i.kt)("a",{parentName:"p",href:"#interfaces-with-parameters-constrained-by-the-same-interface"},"workaround")," for\nthe use cases when this would come up."),(0,i.kt)("p",null,"An expression forming a constraint, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"C & D"),", is incomplete if any of the\ninterfaces or constraints used in the expression are incomplete. A constraint\nexpression using a ",(0,i.kt)("a",{parentName:"p",href:"#where-constraints"},(0,i.kt)("inlineCode",{parentName:"a"},"where")," clause"),", like ",(0,i.kt)("inlineCode",{parentName:"p"},"C where ..."),", is\ninvalid if ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," is incomplete, since there is no way to look up member names of\n",(0,i.kt)("inlineCode",{parentName:"p"},"C")," that appear after ",(0,i.kt)("inlineCode",{parentName:"p"},"where"),"."),(0,i.kt)("p",null,"An interface or named constraint may be forward declared subject to these rules:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The definition must be in the same file as the declaration."),(0,i.kt)("li",{parentName:"ul"},"Only the first declaration may have an access-control keyword."),(0,i.kt)("li",{parentName:"ul"},"An incomplete interface or named constraint may be used as constraints in\ndeclarations of types, functions, interfaces, or named constraints. This\nincludes an ",(0,i.kt)("inlineCode",{parentName:"li"},"impl as")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"extends")," declaration inside an interface or named\nconstraint, but excludes specifying the values for associated constants\nbecause that would involve name lookup into the incomplete constraint."),(0,i.kt)("li",{parentName:"ul"},"An attempt to define the body of a generic function using an incomplete\ninterface or named constraint is illegal."),(0,i.kt)("li",{parentName:"ul"},"An attempt to call a generic function using an incomplete interface or named\nconstraint in its signature is illegal."),(0,i.kt)("li",{parentName:"ul"},"Any name lookup into an incomplete interface or named constraint is an\nerror. For example, it is illegal to attempt to access a member of an\ninterface using ",(0,i.kt)("inlineCode",{parentName:"li"},"MyInterface.MemberName")," or constrain a member using a\n",(0,i.kt)("inlineCode",{parentName:"li"},"where")," clause.")),(0,i.kt)("h3",{id:"declaring-implementations"},"Declaring implementations"),(0,i.kt)("p",null,"The declaration of an interface implementation consists of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"optional modifier keywords ",(0,i.kt)("inlineCode",{parentName:"li"},"final"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"external"),","),(0,i.kt)("li",{parentName:"ul"},"the keyword introducer ",(0,i.kt)("inlineCode",{parentName:"li"},"impl"),","),(0,i.kt)("li",{parentName:"ul"},"an optional deduced parameter list in square brackets ",(0,i.kt)("inlineCode",{parentName:"li"},"["),"...",(0,i.kt)("inlineCode",{parentName:"li"},"]"),","),(0,i.kt)("li",{parentName:"ul"},"a type, including an optional parameter pattern,"),(0,i.kt)("li",{parentName:"ul"},"the keyword ",(0,i.kt)("inlineCode",{parentName:"li"},"as"),", and"),(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("a",{parentName:"li",href:"#type-of-types"},"type-of-type"),", including an optional\n",(0,i.kt)("a",{parentName:"li",href:"#parameterized-interfaces"},"parameter pattern")," and\n",(0,i.kt)("a",{parentName:"li",href:"#where-constraints"},(0,i.kt)("inlineCode",{parentName:"a"},"where")," clause")," assigning\n",(0,i.kt)("a",{parentName:"li",href:"#associated-constants"},"associated constants")," and\n",(0,i.kt)("a",{parentName:"li",href:"#associated-types"},"associated types"),".")),(0,i.kt)("p",null,"An implementation of an interface for a type may be forward declared subject to\nthese rules:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The definition must be in the same library as the declaration. They must\neither be in the same file, or the declaration can be in the API file and\nthe definition in an impl file. ",(0,i.kt)("strong",{parentName:"li"},"Future work:")," Carbon may require the\ndefinition of ",(0,i.kt)("a",{parentName:"li",href:"#parameterized-impls"},"parameterized impls")," to be in the API\nfile, to support separate compilation."),(0,i.kt)("li",{parentName:"ul"},"If there is both a forward declaration and a definition, only the first\ndeclaration must specify the assignment of associated constants with a\n",(0,i.kt)("inlineCode",{parentName:"li"},"where")," clause. Later declarations may omit the ",(0,i.kt)("inlineCode",{parentName:"li"},"where")," clause by writing\n",(0,i.kt)("inlineCode",{parentName:"li"},"where _")," instead."),(0,i.kt)("li",{parentName:"ul"},"You may forward declare an implementation of a defined interface but not an\nincomplete interface. This allows the assignment of associated constants in\nthe ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," declaration to be verified. An impl forward declaration may be\nfor any declared type, whether it is incomplete or defined. Note that this\ndoes not apply to ",(0,i.kt)("inlineCode",{parentName:"li"},"impl as")," declarations in an interface or named constraint\ndefinition, as those are considered interface requirements not forward\ndeclarations."),(0,i.kt)("li",{parentName:"ul"},"Every internal implementation must be declared (or defined) inside the scope\nof the class definition. It may also be declared before the class definition\nor defined afterwards. Note that the class itself is incomplete in the scope\nof the class definition, but member function bodies defined inline are\nprocessed\n",(0,i.kt)("a",{parentName:"li",href:"/docs/project/principles/information_accumulation.md#exceptions"},"as if they appeared immediately after the end of the outermost enclosing class"),"."),(0,i.kt)("li",{parentName:"ul"},"For ",(0,i.kt)("a",{parentName:"li",href:"/design/generics/goals#coherence"},"coherence"),", we require that any impl that matches\nan ",(0,i.kt)("a",{parentName:"li",href:"#impl-lookup"},"impl lookup")," query in the same file, must be declared\nbefore the query. This can be done with a definition or a forward\ndeclaration.")),(0,i.kt)("h3",{id:"matching-and-agreeing"},"Matching and agreeing"),(0,i.kt)("p",null,"Carbon needs to determine if two declarations match in order to say which\ndefinition a forward declaration corresponds to and to verify that nothing is\ndefined twice. Declarations that match must also agree, meaning they are\nconsistent with each other."),(0,i.kt)("p",null,"Interface and named constraint declarations match if their names are the same\nafter name and alias resolution. To agree:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The introducer keyword or keywords much be the same."),(0,i.kt)("li",{parentName:"ul"},"The types and order of parameters in the parameter list, if any, must match.\nThe parameter names may be omitted, but if they are included in both\ndeclarations, they must match."),(0,i.kt)("li",{parentName:"ul"},"Types agree if they correspond to the same expression tree, after name and\nalias resolution and canonicalization of parentheses. Note that no other\nevaluation of type expressions is performed.")),(0,i.kt)("p",null,"Interface implementation declarations match if the type and interface\nexpressions match:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If the type part is omitted, it is rewritten to ",(0,i.kt)("inlineCode",{parentName:"li"},"Self")," in the context of the\ndeclaration."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Self")," is rewritten to its meaning in the scope it is used. In a class\nscope, this should match the type name and optional parameter expression\nafter ",(0,i.kt)("inlineCode",{parentName:"li"},"class"),". So in ",(0,i.kt)("inlineCode",{parentName:"li"},"class MyClass extends MyBase { ... }"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Self")," is\nrewritten to ",(0,i.kt)("inlineCode",{parentName:"li"},"MyClass"),". In ",(0,i.kt)("inlineCode",{parentName:"li"},"class Vector(T:! Movable) { ... }"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Self")," is\nrewritten to ",(0,i.kt)("inlineCode",{parentName:"li"},"Vector(T:! Movable)"),"."),(0,i.kt)("li",{parentName:"ul"},"Types match if they have the same name after name and alias resolution and\nthe same parameters, or are the same type parameter."),(0,i.kt)("li",{parentName:"ul"},"Interfaces match if they have the same name after name and alias resolution\nand the same parameters. Note that a named constraint that is equivalent to\nan interface, as in ",(0,i.kt)("inlineCode",{parentName:"li"},"constraint Equivalent { extends MyInterface; }"),", is not\nconsidered to match.")),(0,i.kt)("p",null,"For implementations to agree:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The presence of modifier keywords such as ",(0,i.kt)("inlineCode",{parentName:"li"},"external")," before ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," must\nmatch between a forward declaration and definition."),(0,i.kt)("li",{parentName:"ul"},"If either declaration includes a ",(0,i.kt)("inlineCode",{parentName:"li"},"where")," clause, they must both include one.\nIf neither uses ",(0,i.kt)("inlineCode",{parentName:"li"},"where _"),", they must match in that they produce the\nassociated constants with the same values considered separately.")),(0,i.kt)("h3",{id:"declaration-examples"},"Declaration examples"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Forward declaration of interfaces\ninterface Interface1;\ninterface Interface2;\ninterface Interface3;\ninterface Interface4;\ninterface Interface5;\ninterface Interface6;\n\n// Forward declaration of class type\nclass MyClass;\n\n// \u274c Illegal: Can't declare implementation of incomplete\n//             interface.\n// external impl MyClass as Interface1;\n\n// Definition of interfaces that were previously declared\ninterface Interface1 {\n  let T1:! Type;\n}\ninterface Interface2 {\n  let T2:! Type;\n}\ninterface Interface3 {\n  let T3:! Type;\n}\ninterface Interface4 {\n  let T4:! Type;\n}\n\n// Forward declaration of external implementations\nexternal impl MyClass as Interface1 where .T1 = i32;\nexternal impl MyClass as Interface2 where .T2 = bool;\n\n// Forward declaration of an internal implementation\nimpl MyClass as Interface3 where .T3 = f32;\nimpl MyClass as Interface4 where .T4 = String;\n\ninterface Interface5 {\n  let T5:! Type;\n}\ninterface Interface6 {\n  let T6:! Type;\n}\n\n// Definition of the previously declared class type\nclass MyClass {\n  // Definition of previously declared external impl.\n  // Note: no need to repeat assignments to associated\n  // constants.\n  external impl as Interface1 where _ { }\n\n  // Definition of previously declared internal impl.\n  // Note: allowed even though `MyClass` is incomplete.\n  // Note: allowed but not required to repeat `where`\n  // clause.\n  impl as Interface3 where .T3 = f32 { }\n\n  // Redeclaration of previously declared internal impl.\n  // Every internal implementation must be declared in\n  // the class definition.\n  impl as Interface4 where _;\n\n  // Forward declaration of external implementation.\n  external impl MyClass as Interface5 where .T5 = u64;\n\n  // Forward declaration of internal implementation.\n  impl MyClass as Interface6 where .T6 = u8;\n}\n\n// It would be legal to move the following definitions\n// from the API file to the implementation file for\n// this library.\n\n// Definition of previously declared external impls.\nexternal impl MyClass as Interface2 where _ { }\nexternal impl MyClass as Interface5 where _ { }\n\n// Definition of previously declared internal impls.\nimpl MyClass as Interface4 where _ { }\nimpl MyClass as Interface6 where _ { }\n")),(0,i.kt)("h3",{id:"example-of-declaring-interfaces-with-cyclic-references"},"Example of declaring interfaces with cyclic references"),(0,i.kt)("p",null,"In this example, ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," has an ",(0,i.kt)("inlineCode",{parentName:"p"},"EdgeType")," associated type that is constrained to\nimplement ",(0,i.kt)("inlineCode",{parentName:"p"},"Edge"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Edge")," has a ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeType")," associated type that is\nconstrained to implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Node"),". Furthermore, the ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeType")," of an ",(0,i.kt)("inlineCode",{parentName:"p"},"EdgeType")," is\nthe original type, and the other way around. This is accomplished by naming and\nthen forward declaring the constraints that can't be stated directly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Forward declare interfaces used in\n// parameter lists of constraints.\ninterface Edge;\ninterface Node;\n\n// Forward declare named constraints used in\n// interface definitions.\nprivate constraint EdgeFor(N:! Node);\nprivate constraint NodeFor(E:! Edge);\n\n// Define interfaces using named constraints.\ninterface Edge {\n  let NodeType:! NodeFor(Self);\n  fn Head[me: Self]() -> NodeType;\n}\ninterface Node {\n  let EdgeType:! EdgeFor(Self);\n  fn Edges[me: Self]() -> Vector(EdgeType);\n}\n\n// Now that the interfaces are defined, can\n// refer to members of the interface, so it is\n// now legal to define the named constraints.\nconstraint EdgeFor(N:! Node) {\n  extends Edge where .NodeType == N;\n}\nconstraint NodeFor(E:! Edge) {\n  extends Node where .EdgeType == E;\n}\n")),(0,i.kt)("h3",{id:"interfaces-with-parameters-constrained-by-the-same-interface"},"Interfaces with parameters constrained by the same interface"),(0,i.kt)("p",null,"To work around\n",(0,i.kt)("a",{parentName:"p",href:"#declaring-interfaces-and-named-constraints"},"the restriction about not being able to name an interface in its parameter list"),",\ninstead include that requirement in the body of the interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Want to require that `T` satisfies `CommonType(Self)`,\n// but that can't be done in the parameter list.\ninterface CommonType(T:! Type) {\n  let Result:! Type;\n  // Instead add the requirement inside the definition.\n  impl T as CommonType(Self);\n}\n")),(0,i.kt)("p",null,"Note however that ",(0,i.kt)("inlineCode",{parentName:"p"},"CommonType")," is still incomplete inside its definition, so no\nconstraints on members of ",(0,i.kt)("inlineCode",{parentName:"p"},"CommonType")," are allowed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface CommonType(T:! Type) {\n  let Result:! Type;\n  // \u274c Illegal: `CommonType` is incomplete\n  impl T as CommonType(Self) where .Result == Result;\n}\n")),(0,i.kt)("p",null,"Instead, a forward-declared named constraint can be used in place of the\nconstraint that can only be defined later. This is\n",(0,i.kt)("a",{parentName:"p",href:"#example-of-declaring-interfaces-with-cyclic-references"},"the same strategy used to work around cyclic references"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"private constraint CommonTypeResult(T:! Type, R:! Type);\n\ninterface CommonType(T:! Type) {\n  let Result:! Type;\n  // \u2705 Allowed: `CommonTypeResult` is incomplete, but\n  //             no members are accessed.\n  impl T as CommonTypeResult(Self, Result);\n}\n\nconstraint CommonTypeResult(T:! Type, R:! Type) {\n  extends CommonType(T) where .Result == R;\n}\n")),(0,i.kt)("h2",{id:"interface-members-with-definitions"},"Interface members with definitions"),(0,i.kt)("p",null,'Interfaces may provide definitions for members, such as a function body for an\nassociated function or method or a value for an associated constant. If these\ndefinitions may be overridden in implementations, they are called "defaults" and\nprefixed with the ',(0,i.kt)("inlineCode",{parentName:"p"},"default"),' keyword. Otherwise they are called "final members"\nand prefixed with the ',(0,i.kt)("inlineCode",{parentName:"p"},"final")," keyword."),(0,i.kt)("h3",{id:"interface-defaults"},"Interface defaults"),(0,i.kt)("p",null,"An interface may provide a default implementation of methods in terms of other\nmethods in the interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Vector {\n  fn Add[me: Self](b: Self) -> Self;\n  fn Scale[me: Self](v: f64) -> Self;\n  // Default definition of `Invert` calls `Scale`.\n  default fn Invert[me: Self]() -> Self {\n    return me.Scale(-1.0);\n  }\n}\n")),(0,i.kt)("p",null,"A default function or method may also be defined out of line, later in the same\nfile as the interface definition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Vector {\n  fn Add[me: Self](b: Self) -> Self;\n  fn Scale[me: Self](v: f64) -> Self;\n  default fn Invert[me: Self]() -> Self;\n}\n// `Vector` is considered complete at this point,\n// even though `Vector.Invert` is still incomplete.\nfn Vector.Invert[me: Self]() -> Self {\n  return me.Scale(-1.0);\n}\n")),(0,i.kt)("p",null,"An impl of that interface for a type may omit a definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"Invert")," to use\nthe default, or provide a definition to override the default."),(0,i.kt)("p",null,"Interface defaults are helpful for ",(0,i.kt)("a",{parentName:"p",href:"#evolution"},"evolution"),", as well as reducing\nboilerplate. Defaults address the gap between the minimum necessary for a type\nto provide the desired functionality of an interface and the breadth of API that\ndevelopers desire. As an example, in Rust the\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/iter/trait.Iterator.html"},"iterator trait"),' only\nhas one required method but dozens of "provided methods" with defaults.'),(0,i.kt)("p",null,"Defaults may also be provided for associated constants, such as associated\ntypes, and interface parameters, using the ",(0,i.kt)("inlineCode",{parentName:"p"},"= <default value>")," syntax."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Add(Right:! Type = Self) {\n  default let Result:! Type = Self;\n  fn DoAdd[me: Self](right: Right) -> Result;\n}\n\nimpl String as Add() {\n  // Right == Result == Self == String\n  fn DoAdd[me: Self](right: Self) -> Self;\n}\n")),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," is a legal default value for an associated type or type\nparameter. In this case the value of those names is not determined until ",(0,i.kt)("inlineCode",{parentName:"p"},"Self"),"\nis, so ",(0,i.kt)("inlineCode",{parentName:"p"},"Add()")," is equivalent to the constraint:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Equivalent to Add()\nconstraint AddDefault {\n  extends Add(Self);\n}\n")),(0,i.kt)("p",null,"Note also that the parenthesis are required after ",(0,i.kt)("inlineCode",{parentName:"p"},"Add"),", even when all\nparameters are left as their default values."),(0,i.kt)("p",null,"More generally, default expressions may reference other associated types or\n",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," as parameters to type constructors. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Iterator {\n  let Element:! Type;\n  default let Pointer:! Type = Element*;\n}\n")),(0,i.kt)("p",null,"Carbon does ",(0,i.kt)("strong",{parentName:"p"},"not")," support providing a default implementation of a required\ninterface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface TotalOrder {\n  fn TotalLess[me: Self](right: Self) -> bool;\n  // \u274c Illegal: May not provide definition\n  //             for required interface.\n  impl as PartialOrder {\n    fn PartialLess[me: Self](right: Self) -> bool {\n      return me.TotalLess(right);\n    }\n  }\n}\n")),(0,i.kt)("p",null,"The workaround for this restriction is to use a ",(0,i.kt)("a",{parentName:"p",href:"#blanket-impls"},"blanket impl"),"\ninstead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface TotalOrder {\n  fn TotalLess[me: Self](right: Self) -> bool;\n  impl as PartialOrder;\n}\n\nexternal impl forall [T:! TotalOrder] T as PartialOrder {\n  fn PartialLess[me: Self](right: Self) -> bool {\n    return me.TotalLess(right);\n  }\n}\n")),(0,i.kt)("p",null,"Note that by the ",(0,i.kt)("a",{parentName:"p",href:"#orphan-rule"},"orphan rule"),", this blanket impl must be defined\nin the same library as ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialOrder"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Comparison with other languages:")," Rust supports specifying defaults for\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch10-02-traits.html#default-implementations"},"methods"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#default-generic-type-parameters-and-operator-overloading"},"interface parameters"),",\nand\n",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/items/associated-items.html#associated-constants-examples"},"associated constants"),".\nRust has found them valuable."),(0,i.kt)("h3",{id:"final-members"},(0,i.kt)("inlineCode",{parentName:"h3"},"final")," members"),(0,i.kt)("p",null,"As an alternative to providing a definition of an interface member as a default,\nmembers marked with the ",(0,i.kt)("inlineCode",{parentName:"p"},"final")," keyword will not allow that definition to be\noverridden in impls."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface TotalOrder {\n  fn TotalLess[me: Self](right: Self) -> bool;\n  final fn TotalGreater[me: Self](right: Self) -> bool {\n    return right.TotalLess(me);\n  }\n}\n\nclass String {\n  impl as TotalOrder {\n    fn TotalLess[me: Self](right: Self) -> bool { ... }\n    // \u274c Illegal: May not provide definition of final\n    //             method `TotalGreater`.\n    fn TotalGreater[me: Self](right: Self) -> bool { ... }\n  }\n}\n\ninterface Add(T:! Type = Self) {\n  // `AddWith` *always* equals `T`\n  final let AddWith:! Type = T;\n  // Has a *default* of `Self`\n  let Result:! Type = Self;\n  fn DoAdd[me: Self](right: AddWith) -> Result;\n}\n")),(0,i.kt)("p",null,"Final members may also be defined out-of-line:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface TotalOrder {\n  fn TotalLess[me: Self](right: Self) -> bool;\n  final fn TotalGreater[me: Self](right: Self) -> bool;\n}\n// `TotalOrder` is considered complete at this point, even\n// though `TotalOrder.TotalGreater` is not yet defined.\nfn TotalOrder.TotalGreater[me: Self](right: Self) -> bool {\n return right.TotalLess(me);\n}\n")),(0,i.kt)("p",null,"There are a few reasons for this feature:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When overriding would be inappropriate."),(0,i.kt)("li",{parentName:"ul"},"Matching the functionality of non-virtual methods in base classes, so\ninterfaces can be a replacement for inheritance."),(0,i.kt)("li",{parentName:"ul"},"Potentially reduce dynamic dispatch when using the interface in a\n",(0,i.kt)("a",{parentName:"li",href:"#dynamic-types"},(0,i.kt)("inlineCode",{parentName:"a"},"DynPtr")),".")),(0,i.kt)("p",null,"Note that this applies to associated entities, not interface parameters."),(0,i.kt)("h2",{id:"interface-requiring-other-interfaces-revisited"},"Interface requiring other interfaces revisited"),(0,i.kt)("p",null,"Recall that an\n",(0,i.kt)("a",{parentName:"p",href:"#interface-requiring-other-interfaces"},"interface can require another interface be implemented for the type"),",\nas in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Iterable {\n  impl as Equatable;\n  // ...\n}\n")),(0,i.kt)("p",null,"This states that the type implementing the interface ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterable"),", which in this\ncontext is called ",(0,i.kt)("inlineCode",{parentName:"p"},"Self"),", must also implement the interface ",(0,i.kt)("inlineCode",{parentName:"p"},"Equatable"),". As is\ndone with ",(0,i.kt)("a",{parentName:"p",href:"#conditional-conformance"},"conditional conformance"),", we allow another\ntype to be specified between ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," to say some type other than ",(0,i.kt)("inlineCode",{parentName:"p"},"Self"),"\nmust implement an interface. For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface IntLike {\n  impl i32 as As(Self);\n  // ...\n}\n")),(0,i.kt)("p",null,"says that if ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"IntLike"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," must implement ",(0,i.kt)("inlineCode",{parentName:"p"},"As(Self)"),".\nSimilarly,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface CommonTypeWith(T:! Type) {\n  impl T as CommonTypeWith(Self);\n  // ...\n}\n")),(0,i.kt)("p",null,"says that if ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"CommonTypeWith(T)"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," must implement\n",(0,i.kt)("inlineCode",{parentName:"p"},"CommonTypeWith(Self)"),"."),(0,i.kt)("p",null,"The previous description of ",(0,i.kt)("inlineCode",{parentName:"p"},"impl as")," in an interface definition matches the\nbehavior of using a default of ",(0,i.kt)("inlineCode",{parentName:"p"},"Self")," when the type between ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," is\nomitted. So the previous definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"interface Iterable")," is equivalent to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface Iterable {\n  // ...\n  impl Self as Equatable;\n  // Equivalent to: impl as Equatable;\n}\n")),(0,i.kt)("p",null,"When implementing an interface with an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl as")," requirement, that requirement\nmust be satisfied by an implementation in an imported library, an implementation\nsomewhere in the same file, or a constraint in the impl declaration.\nImplementing the requiring interface is a promise that the requirement will be\nimplemented. This is like a\n",(0,i.kt)("a",{parentName:"p",href:"#declaring-implementations"},"forward declaration of an impl")," except that the\ndefinition can be broader instead of being required to match exactly."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// `Iterable` requires `Equatable`, so there must be some\n// impl of `Equatable` for `Vector(i32)` in this file.\nexternal impl Vector(i32) as Iterable { ... }\n\nfn RequiresEquatable[T:! Equatable](x: T) { ... }\nfn ProcessVector(v: Vector(i32)) {\n  // \u2705 Allowed since `Vector(i32)` is known to\n  // implement `Equatable`.\n  RequiresEquatable(v);\n}\n\n// Satisfies the requirement that `Vector(i32)` must\n// implement `Equatable` since `i32` is `Equatable`.\nexternal impl forall [T:! Equatable] Vector(T) as Equatable { ... }\n")),(0,i.kt)("p",null,"In some cases, the interface's requirement can be trivially satisfied by the\nimplementation itself, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"impl forall [T:! Type] T as CommonTypeWith(T) { ... }\n")),(0,i.kt)("p",null,"Here is an example where the requirement of interface ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterable")," that the type\nimplements interface ",(0,i.kt)("inlineCode",{parentName:"p"},"Equatable")," is satisfied by a constraint in the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),"\ndeclaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Foo(T:! Type) {}\n// This is allowed because we know that an `impl Foo(T) as Equatable`\n// will exist for all types `T` for which this impl is used, even\n// though there's neither an imported impl nor an impl in this file.\nexternal impl forall [T:! Type where Foo(T) is Equatable]\n    Foo(T) as Iterable {}\n")),(0,i.kt)("p",null,"This might be used to provide an implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Equatable")," for types that\nalready satisfy the requirement of implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterable"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Bar {}\nexternal impl Foo(Bar) as Equatable {}\n// Gives `Foo(Bar) is Iterable` using the blanket impl of\n// `Iterable` for `Foo(T)`.\n")),(0,i.kt)("h3",{id:"requirements-with-where-constraints"},"Requirements with ",(0,i.kt)("inlineCode",{parentName:"h3"},"where")," constraints"),(0,i.kt)("p",null,"An interface implementation requirement with a ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," clause is harder to\nsatisfy. Consider an interface ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," that has a requirement that interface ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," is\nalso implemented."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface A(T:! Type) {\n  let Result:! Type;\n}\ninterface B(T:! Type) {\n  impl as A(T) where .Result == i32;\n}\n")),(0,i.kt)("p",null,"An implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," for a set of types can only be valid if there is a\nvisible implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," with the same ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," parameter for those types with\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},".Result")," associated type set to ",(0,i.kt)("inlineCode",{parentName:"p"},"i32"),". That is\n",(0,i.kt)("a",{parentName:"p",href:"/proposals/p1088.md#less-strict-about-requirements-with-where-clauses"},"not sufficient"),",\nthough, unless the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," can't be specialized, either because it\nis ",(0,i.kt)("a",{parentName:"p",href:"#final-impls"},"marked ",(0,i.kt)("inlineCode",{parentName:"a"},"final"))," or is not\n",(0,i.kt)("a",{parentName:"p",href:"#parameterized-impls"},"parameterized"),". Implementations in other libraries can't\nmake ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," be implemented for fewer types, but can cause ",(0,i.kt)("inlineCode",{parentName:"p"},".Result")," to have a\ndifferent assignment."),(0,i.kt)("h2",{id:"observing-a-type-implements-an-interface"},"Observing a type implements an interface"),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"#observe-declarations"},(0,i.kt)("inlineCode",{parentName:"a"},"observe")," declaration")," can be used to show that two\ntypes are equal so code can pass type checking without explicitly writing casts,\nwithout requiring the compiler to do a unbounded search that may not terminate.\nAn ",(0,i.kt)("inlineCode",{parentName:"p"},"observe")," declaration can also be used to show that a type implements an\ninterface, in cases where the compiler will not work this out for itself."),(0,i.kt)("h3",{id:"observing-interface-requirements"},"Observing interface requirements"),(0,i.kt)("p",null,"One situation where this occurs is when there is a chain of\n",(0,i.kt)("a",{parentName:"p",href:"#interface-requiring-other-interfaces-revisited"},"interfaces requiring other interfaces"),".\nDuring the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," validation done during type checking, Carbon will only\nconsider the interfaces that are direct requirements of the interfaces the type\nis known to implement. An ",(0,i.kt)("inlineCode",{parentName:"p"},"observe...is")," declaration can be used to add an\ninterface that is a direct requirement to the set of interfaces whose direct\nrequirements will be considered for that type. This allows a developer to\nprovide a proof that there is a sequence of requirements that demonstrate that a\ntype implements an interface, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface A { }\ninterface B { impl as A; }\ninterface C { impl as B; }\ninterface D { impl as C; }\n\nfn RequiresA[T:! A](x: T);\nfn RequiresC[T:! C](x: T);\nfn RequiresD[T:! D](x: T) {\n  // \u2705 Allowed: `D` directly requires `C` to be implemented.\n  RequiresC(x);\n\n  // \u274c Illegal: No direct connection between `D` and `A`.\n  // RequiresA(x);\n\n  // `T` is `D` and `D` directly requires `C` to be\n  // implemented.\n  observe T is C;\n\n  // `T` is `C` and `C` directly requires `B` to be\n  // implemented.\n  observe T is B;\n\n  // \u2705 Allowed: `T` is `B` and `B` directly requires\n  //             `A` to be implemented.\n  RequiresA(x);\n}\n")),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"observe")," statements do not affect the selection of impls during code\ngeneration. For coherence, the impl used for a (type, interface) pair must\nalways be the same, independent of context. The\n",(0,i.kt)("a",{parentName:"p",href:"#termination-rule"},"termination rule")," governs when compilation may fail when the\ncompiler can't determine the impl to select."),(0,i.kt)("h3",{id:"observing-blanket-impls"},"Observing blanket impls"),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"observe...is")," declaration can also be used to observe that a type implements\nan interface because there is a ",(0,i.kt)("a",{parentName:"p",href:"#blanket-impls"},"blanket impl")," in terms of\nrequirements a type is already known to satisfy. Without an ",(0,i.kt)("inlineCode",{parentName:"p"},"observe"),"\ndeclaration, Carbon will only use blanket impls that are directly satisfied."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface A { }\ninterface B { }\ninterface C { }\ninterface D { }\n\nimpl forall [T:! A] T as B { }\nimpl forall [T:! B] T as C { }\nimpl forall [T:! C] T as D { }\n\nfn RequiresD(T:! D)(x: T);\nfn RequiresB(T:! B)(x: T);\n\nfn RequiresA(T:! A)(x: T) {\n  // \u2705 Allowed: There is a blanket implementation\n  //             of `B` for types implementing `A`.\n  RequiresB(x);\n\n  // \u274c Illegal: No implementation of `D` for type\n  //             `T` implementing `A`\n  // RequiresD(x);\n\n  // There is a blanket implementation of `B` for\n  // types implementing `A`.\n  observe T is B;\n\n  // There is a blanket implementation of `C` for\n  // types implementing `B`.\n  observe T is C;\n\n  // \u2705 Allowed: There is a blanket implementation\n  //             of `D` for types implementing `C`.\n  RequiresD(x);\n}\n")),(0,i.kt)("p",null,"In the case of an error, a quality Carbon implementation will do a deeper search\nfor chains of requirements and blanket impls and suggest ",(0,i.kt)("inlineCode",{parentName:"p"},"observe")," declarations\nthat would make the code compile if any solution is found."),(0,i.kt)("h2",{id:"operator-overloading"},"Operator overloading"),(0,i.kt)("p",null,"Operations are overloaded for a type by implementing an interface specific to\nthat interface for that type. For example, types implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Negatable"),"\ninterface to overload the unary ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Unary `-`.\ninterface Negatable {\n  let Result:! Type = Self;\n  fn Negate[me: Self]() -> Result;\n}\n")),(0,i.kt)("p",null,"Expressions using operators are rewritten into calls to these interface methods.\nFor example, ",(0,i.kt)("inlineCode",{parentName:"p"},"-x")," would be rewritten to ",(0,i.kt)("inlineCode",{parentName:"p"},"x.(Negatable.Negate)()"),"."),(0,i.kt)("p",null,"The interfaces and rewrites used for a given operator may be found in the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/README.md"},"expressions design"),".\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/carbon-language/carbon-lang/issues/1058"},"Question-for-leads issue #1058"),"\ndefines the naming scheme for these interfaces."),(0,i.kt)("h3",{id:"binary-operators"},"Binary operators"),(0,i.kt)("p",null,"Binary operators will have an interface that is\n",(0,i.kt)("a",{parentName:"p",href:"#parameterized-interfaces"},"parameterized")," based on the second operand. For\nexample, to say a type may be converted to another type using an ",(0,i.kt)("inlineCode",{parentName:"p"},"as"),"\nexpression, implement the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/as_expressions.md#extensibility"},(0,i.kt)("inlineCode",{parentName:"a"},"As")," interface"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface As(Dest:! Type) {\n  fn Convert[me: Self]() -> Dest;\n}\n")),(0,i.kt)("p",null,"The expression ",(0,i.kt)("inlineCode",{parentName:"p"},"x as U")," is rewritten to ",(0,i.kt)("inlineCode",{parentName:"p"},"x.(As(U).Convert)()"),". Note that the\nparameterization of the interface means it can be implemented multiple times to\nsupport multiple operand types."),(0,i.kt)("p",null,"Unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"as"),", for most binary operators the interface's argument will be the\n",(0,i.kt)("em",{parentName:"p"},"type")," of the right-hand operand instead of its ",(0,i.kt)("em",{parentName:"p"},"value"),". Consider an interface\nfor a binary operator like ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Binary `*`.\ninterface MultipliableWith(U:! Type) {\n  let Result:! Type = Self;\n  fn Multiply[me: Self](other: U) -> Result;\n}\n")),(0,i.kt)("p",null,"A use of binary ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," in source code will be rewritten to use this interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var left: Meters = ...;\nvar right: f64 = ...;\nvar result: auto = left * right;\n// Equivalent to:\nvar equivalent: left.(MultipliableWith(f64).Result)\n    = left.(MultipliableWith(f64).Multiply)(right);\n")),(0,i.kt)("p",null,"Note that if the types of the two operands are different, then swapping the\norder of the operands will result in a different implementation being selected.\nIt is up to the developer to make those consistent when that is appropriate. The\nstandard library will provide ",(0,i.kt)("a",{parentName:"p",href:"#adapting-types"},"adapters")," for defining the\nsecond implementation from the first, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface ComparableWith(RHS:! Type) {\n  fn Compare[me: Self](right: RHS) -> CompareResult;\n}\n\nadapter ReverseComparison\n    (T:! Type, U:! ComparableWith(RHS)) for T {\n  impl as ComparableWith(U) {\n    fn Compare[me: Self](right: RHS) -> CompareResult {\n      return ReverseCompareResult(right.Compare(me));\n    }\n  }\n}\n\nexternal impl SongByTitle as ComparableWith(SongTitle);\nexternal impl SongTitle as ComparableWith(SongByTitle)\n    = ReverseComparison(SongTitle, SongByTitle);\n")),(0,i.kt)("p",null,"In some cases the reverse operation may not be defined. For example, a library\nmight support subtracting a vector from a point, but not the other way around."),(0,i.kt)("p",null,"Further note that even if the reverse implementation exists,\n",(0,i.kt)("a",{parentName:"p",href:"#prioritization-rule"},"the impl prioritization rule")," might not pick it. For\nexample, if we have two types that support comparison with anything implementing\nan interface that the other implements:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface IntLike {\n  fn AsInt[me: Self]() -> i64;\n}\n\nclass EvenInt { ... }\nexternal impl EvenInt as IntLike;\nexternal impl EvenInt as ComparableWith(EvenInt);\n// Allow `EvenInt` to be compared with anything that\n// implements `IntLike`, in either order.\nexternal impl forall [T:! IntLike] EvenInt as ComparableWith(T);\nexternal impl forall [T:! IntLike] T as ComparableWith(EvenInt);\n\nclass PositiveInt { ... }\nexternal impl PositiveInt as IntLike;\nexternal impl PositiveInt as ComparableWith(PositiveInt);\n// Allow `PositiveInt` to be compared with anything that\n// implements `IntLike`, in either order.\nexternal impl forall [T:! IntLike] PositiveInt as ComparableWith(T);\nexternal impl forall [T:! IntLike] T as ComparableWith(PositiveInt);\n")),(0,i.kt)("p",null,"Then it will favor selecting the implementation based on the type of the\nleft-hand operand:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var even: EvenInt = ...;\nvar positive: PositiveInt = ...;\n// Uses `EvenInt as ComparableWith(T)` impl\nif (even < positive) { ... }\n// Uses `PositiveInt as ComparableWith(T)` impl\nif (positive > even) { ... }\n")),(0,i.kt)("h3",{id:"like-operator-for-implicit-conversions"},(0,i.kt)("inlineCode",{parentName:"h3"},"like")," operator for implicit conversions"),(0,i.kt)("p",null,"Because the type of the operands is directly used to select the implementation\nto use, there are no automatic implicit conversions, unlike with function or\nmethod calls. Given both a method and an interface implementation for\nmultiplying by a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"f64"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'class Meters {\n  fn Scale[me: Self](s: f64) -> Self;\n}\n// "Implementation One"\nexternal impl Meters as MultipliableWith(f64)\n    where .Result = Meters {\n  fn Multiply[me: Self](other: f64) -> Result {\n    return me.Scale(other);\n  }\n}\n')),(0,i.kt)("p",null,"the method will work with any argument that can be implicitly converted to ",(0,i.kt)("inlineCode",{parentName:"p"},"f64"),"\nbut the operator overload will only work with values that have the specific type\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"f64"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var height: Meters = ...;\nvar scale: f32 = 1.25;\n// \u2705 Allowed: `scale` implicitly converted\n//             from `f32` to `f64`.\nvar allowed: Meters = height.Scale(scale);\n// \u274c Illegal: `Meters` doesn't implement\n//             `MultipliableWith(f32)`.\nvar illegal: Meters = height * scale;\n")),(0,i.kt)("p",null,"The workaround is to define a parameterized implementation that performs the\nconversion. The implementation is for types that implement the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/implicit_conversions.md#extensibility"},(0,i.kt)("inlineCode",{parentName:"a"},"ImplicitAs")," interface"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'// "Implementation Two"\nexternal impl forall [T:! ImplicitAs(f64)]\n    Meters as MultipliableWith(T) where .Result = Meters {\n  fn Multiply[me: Self](other: T) -> Result {\n    // Carbon will implicitly convert `other` from type\n    // `T` to `f64` to perform this call.\n    return me.(Meters.(MultipliableWith(f64).Multiply))(other);\n  }\n}\n// \u2705 Allowed: uses `Meters as MultipliableWith(T)` impl\n//             with `T == f32` since `f32 is ImplicitAs(f64)`.\nvar now_allowed: Meters = height * scale;\n')),(0,i.kt)("p",null,"Observe that the ",(0,i.kt)("a",{parentName:"p",href:"#prioritization-rule"},"prioritization rule")," will still prefer\nthe unparameterized impl when there is an exact match."),(0,i.kt)("p",null,"To reduce the boilerplate needed to support these implicit conversions when\ndefining operator overloads, Carbon has the ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," operator. This operator can\nonly be used in the type or type-of-type part of an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," declaration, as part\nof a forward declaration or definition, in a place of a type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'// Notice `f64` has been replaced by `like f64`\n// compared to "implementation one" above.\nexternal impl Meters as MultipliableWith(like f64)\n    where .Result = Meters {\n  fn Multiply[me: Self](other: f64) -> Result {\n    return me.Scale(other);\n  }\n}\n')),(0,i.kt)("p",null,"This ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," definition actually defines two implementations. The first is the\nsame as this definition with ",(0,i.kt)("inlineCode",{parentName:"p"},"like f64")," replaced by ",(0,i.kt)("inlineCode",{parentName:"p"},"f64"),', giving something\nequivalent to "implementation one". The second implementation replaces the\n',(0,i.kt)("inlineCode",{parentName:"p"},"like f64")," with a parameter that ranges over types that can be implicitly\nconverted to ",(0,i.kt)("inlineCode",{parentName:"p"},"f64"),', equivalent to "implementation two".'),(0,i.kt)("p",null,"In general, each ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," adds one additional impl. There is always the impl with\nall of the ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," expressions replaced by their arguments with the definition\nsupplied in the source code. In addition, for each ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," expression, there is\nan impl with it replaced by a new parameter. These additional impls will\ndelegate to the main impl, which will trigger implicit conversions according to\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/expressions/implicit_conversions.md"},"Carbon's ordinary implicit conversion rules"),".\nIn this example, there are two uses of ",(0,i.kt)("inlineCode",{parentName:"p"},"like"),", producing three implementations"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"external impl like Meters as MultipliableWith(like f64)\n    where .Result = Meters {\n  fn Multiply[me: Self](other: f64) -> Result {\n    return me.Scale(other);\n  }\n}\n")),(0,i.kt)("p",null,'is equivalent to "implementation one", "implementation two", and:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"external impl forall [T:! ImplicitAs(Meters)]\n    T as MultipliableWith(f64) where .Result = Meters {\n  fn Multiply[me: Self](other: f64) -> Result {\n    // Will implicitly convert `me` to `Meters` in order to\n    // match the signature of this `Multiply` method.\n    return me.(Meters.(MultipliableWith(f64).Multiply))(other);\n  }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"like")," may be used in forward declarations in a way analogous to impl\ndefinitions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"external impl like Meters as MultipliableWith(like f64)\n    where .Result = Meters;\n}\n")),(0,i.kt)("p",null,"is equivalent to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'// All `like`s removed. Same as the declaration part of\n// "implementation one", without the body of the definition.\nexternal impl Meters as MultipliableWith(f64)\n    where .Result = Meters;\n\n// First `like` replaced with a wildcard.\nexternal impl forall [T:! ImplicitAs(Meters)]\n    T as MultipliableWith(f64) where .Result = Meters;\n\n// Second `like` replaced with a wildcard. Same as the\n// declaration part of "implementation two", without the\n// body of the definition.\nexternal impl forall [T:! ImplicitAs(f64)]\n    Meters as MultipliableWith(T) where .Result = Meters;\n')),(0,i.kt)("p",null,"In addition, the generated impl definition for a ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," is implicitly injected\nat the end of the (unique) source file in which the impl is first declared. That\nis, it is injected in the API file if the impl is declared in an API file, and\nin the sole impl file declaring the impl otherwise. This means an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl"),"\ndeclaration using ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," in an API file also makes the parameterized definition"),(0,i.kt)("p",null,"If one ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," declaration uses ",(0,i.kt)("inlineCode",{parentName:"p"},"like"),", other declarations must use ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," in the\nsame way to match."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," operator may be nested, as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"external impl like Vector(like String) as Printable;\n")),(0,i.kt)("p",null,"Which will generate implementations with declarations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"external impl Vector(String) as Printable;\nexternal impl forall [T:! ImplicitAs(Vector(String))] T as Printable;\nexternal impl forall [T:! ImplicitAs(String)] Vector(T) as Printable;\n")),(0,i.kt)("p",null,"The generated implementations must be legal or the ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," is illegal. For\nexample, it must be legal to define those impls in this library by the\n",(0,i.kt)("a",{parentName:"p",href:"#orphan-rule"},"orphan rule"),". In addition, the generated ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," definitions must\nonly require implicit conversions that are guaranteed to exist. For example,\nthere existing an implicit conversion from ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," does not imply that\nthere is one from ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector(T)")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector(String)"),", so the following use of\n",(0,i.kt)("inlineCode",{parentName:"p"},"like")," is illegal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// \u274c Illegal: Can't convert a value with type\n//             `Vector(T:! ImplicitAs(String))`\n//             to `Vector(String)` for `me`\n//             parameter of `Printable.Print`.\nexternal impl Vector(like String) as Printable;\n")),(0,i.kt)("p",null,"Since the additional implementation definitions are generated eagerly, these\nerrors will be reported in the file with the first declaration."),(0,i.kt)("p",null,"The argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," must either not mention any type parameters, or those\nparameters must be able to be determined due to being repeated outside of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"like")," expression."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// \u2705 Allowed: no parameters\nexternal impl like Meters as Printable;\n\n// \u274c Illegal: No other way to determine `T`\nexternal impl forall [T:! IntLike] like T as Printable;\n\n// \u274c Illegal: `T` being used in a `where` clause\n//             is insufficient.\nexternal impl forall [T:! IntLike] like T\n    as MultipliableWith(i64) where .Result = T;\n\n// \u274c Illegal: `like` can't be used in a `where`\n//             clause.\nexternal impl Meters as MultipliableWith(f64)\n    where .Result = like Meters;\n\n// \u2705 Allowed: `T` can be determined by another\n//             part of the query.\nexternal impl forall [T:! IntLike] like T\n    as MultipliableWith(T) where .Result = T;\nexternal impl forall [T:! IntLike] T\n    as MultipliableWith(like T) where .Result = T;\n\n// \u2705 Allowed: Only one `like` used at a time, so this\n//             is equivalent to the above two examples.\nexternal impl forall [T:! IntLike] like T\n    as MultipliableWith(like T) where .Result = T;\n")),(0,i.kt)("h2",{id:"parameterized-types"},"Parameterized types"),(0,i.kt)("p",null,"Types may have generic parameters. Those parameters may be used to specify types\nin the declarations of its members, such as data fields, member functions, and\neven interfaces being implemented. For example, a container type might be\nparameterized by the type of its elements:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class HashMap(\n    KeyType:! Hashable & EqualityComparable & Movable,\n    ValueType:! Movable) {\n  // `Self` is `HashMap(KeyType, ValueType)`.\n\n  // Parameters may be used in function signatures.\n  fn Insert[addr me: Self*](k: KeyType, v: ValueType);\n\n  // Parameters may be used in field types.\n  private var buckets: Vector((KeyType, ValueType));\n\n  // Parameters may be used in interfaces implemented.\n  impl as Container where .ElementType = (KeyType, ValueType);\n  impl as ComparableWith(HashMap(KeyType, ValueType));\n}\n")),(0,i.kt)("p",null,"Note that, unlike functions, every parameter to a type must either be generic or\ntemplate, using ",(0,i.kt)("inlineCode",{parentName:"p"},":!")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"template...:!"),", not dynamic, with a plain ",(0,i.kt)("inlineCode",{parentName:"p"},":"),"."),(0,i.kt)("p",null,"Two types are the same if they have the same name and the same arguments.\nCarbon's ",(0,i.kt)("a",{parentName:"p",href:"#manual-type-equality"},"manual type equality")," approach means that the\ncompiler may not always be able to tell when two type expressions are equal\nwithout help from the user, in the form of\n",(0,i.kt)("a",{parentName:"p",href:"#observe-declarations"},(0,i.kt)("inlineCode",{parentName:"a"},"observe")," declarations"),". This means Carbon will not in\ngeneral be able to determine when types are unequal."),(0,i.kt)("p",null,"Unlike an ",(0,i.kt)("a",{parentName:"p",href:"#parameterized-interfaces"},"interface's parameters"),", a type's\nparameters may be ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#deduced-parameter"},"deduced"),", as in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'fn ContainsKey[KeyType:! Movable, ValueType:! Movable]\n    (haystack: HashMap(KeyType, ValueType), needle: KeyType)\n    -> bool { ... }\nfn MyMapContains(s: String) {\n  var map: HashMap(String, i32) = (("foo", 3), ("bar", 5));\n  // \u2705 Deduces `KeyType` = `String` from the types of both arguments.\n  // Deduces `ValueType` = `i32` from the type of the first argument.\n  return ContainsKey(map, s);\n}\n')),(0,i.kt)("p",null,"Note that restrictions on the type's parameters from the type's declaration can\nbe ",(0,i.kt)("a",{parentName:"p",href:"#implied-constraints"},"implied constraints")," on the function's parameters."),(0,i.kt)("h3",{id:"specialization"},"Specialization"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/design/generics/terminology#generic-specialization"},"Specialization")," is used to improve\nperformance in specific cases when a general strategy would be inefficient. For\nexample, you might use\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Binary_search_algorithm"},"binary search")," for\ncontainers that support random access and keep their contents in sorted order\nbut ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Linear_search"},"linear search")," in other cases.\nTypes, like functions, may not be specialized directly in Carbon. This effect\ncan be achieved, however, through delegation."),(0,i.kt)("p",null,"For example, imagine we have a parameterized class ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional(T)")," that has a\ndefault storage strategy that works for all ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", but for some types we have a\nmore efficient approach. For pointers we can use a\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Null_pointer"},"null value"),' to represent "no\npointer", and for booleans we can support ',(0,i.kt)("inlineCode",{parentName:"p"},"True"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"False"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),' in a\nsingle byte. Clients of the optional library may want to add additional\nspecializations for their own types. We make an interface that represents "the\nstorage of ',(0,i.kt)("inlineCode",{parentName:"p"},"Optional(T)")," for type ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),'," written here as ',(0,i.kt)("inlineCode",{parentName:"p"},"OptionalStorage"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"interface OptionalStorage {\n  let Storage:! Type;\n  fn MakeNone() -> Storage;\n  fn Make(x: Self) -> Storage;\n  fn IsNone(x: Storage) -> bool;\n  fn Unwrap(x: Storage) -> Self;\n}\n")),(0,i.kt)("p",null,"The default implementation of this interface is provided by a\n",(0,i.kt)("a",{parentName:"p",href:"#blanket-impls"},"blanket implementation"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Default blanket implementation\nimpl forall [T:! Movable] T as OptionalStorage\n    where .Storage = (bool, T) {\n  ...\n}\n")),(0,i.kt)("p",null,"This implementation can then be\n",(0,i.kt)("a",{parentName:"p",href:"#lookup-resolution-and-specialization"},"specialized")," for more specific type\npatterns:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Specialization for pointers, using nullptr == None\nfinal external impl forall [T:! Type] T* as OptionalStorage\n    where .Storage = Array(Byte, sizeof(T*)) {\n  ...\n}\n// Specialization for type `bool`.\nfinal external impl bool as OptionalStorage\n    where .Storage = Byte {\n  ...\n}\n")),(0,i.kt)("p",null,"Further, libraries can implement ",(0,i.kt)("inlineCode",{parentName:"p"},"OptionalStorage")," for their own types, assuming\nthe interface is not marked ",(0,i.kt)("inlineCode",{parentName:"p"},"private"),". Then the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional(T)"),"\ncan delegate to ",(0,i.kt)("inlineCode",{parentName:"p"},"OptionalStorage")," for anything that can vary with ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Optional(T:! Movable) {\n  fn None() -> Self {\n    return {.storage = T.(OptionalStorage.MakeNone)()};\n  }\n  fn Some(x: T) -> Self {\n    return {.storage = T.(OptionalStorage.Make)(x)};\n  }\n  ...\n  private var storage: T.(OptionalStorage.Storage);\n}\n")),(0,i.kt)("p",null,"Note that the constraint on ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is just ",(0,i.kt)("inlineCode",{parentName:"p"},"Movable"),", not\n",(0,i.kt)("inlineCode",{parentName:"p"},"Movable & OptionalStorage"),", since the ",(0,i.kt)("inlineCode",{parentName:"p"},"Movable")," requirement is\n",(0,i.kt)("a",{parentName:"p",href:"#lookup-resolution-and-specialization"},"sufficient to guarantee")," that some\nimplementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"OptionalStorage")," exists for ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),". Carbon does not require\ncallers of ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional"),", even generic callers, to specify that the argument type\nimplements ",(0,i.kt)("inlineCode",{parentName:"p"},"OptionalStorage"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// \u2705 Allowed: `T` just needs to be `Movable` to form `Optional(T)`.\n//             A `T:! OptionalStorage` constraint is not required.\nfn First[T:! Movable & Eq](v: Vector(T)) -> Optional(T);\n")),(0,i.kt)("p",null,"Adding ",(0,i.kt)("inlineCode",{parentName:"p"},"OptionalStorage")," to the constraints on the parameter to ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional")," would\nobscure what types can be used as arguments. ",(0,i.kt)("inlineCode",{parentName:"p"},"OptionalStorage")," is an\nimplementation detail of ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional")," and need not appear in its public API."),(0,i.kt)("p",null,"In this example, a ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," is used to avoid repeating ",(0,i.kt)("inlineCode",{parentName:"p"},"OptionalStorage")," in the\ndefinition of ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional"),", since it has no name conflicts with the members of\n",(0,i.kt)("inlineCode",{parentName:"p"},"Movable"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class Optional(T:! Movable) {\n  private let U:! Movable & OptionalStorage = T;\n  fn None() -> Self {\n    return {.storage = U.MakeNone()};\n  }\n  fn Some(x: T) -> Self {\n    return {.storage = u.Make(x)};\n  }\n  ...\n  private var storage: U.Storage;\n}\n")),(0,i.kt)("h2",{id:"future-work"},"Future work"),(0,i.kt)("h3",{id:"dynamic-types"},"Dynamic types"),(0,i.kt)("p",null,"Generics provide enough structure to support runtime dispatch for values with\ntypes that vary at runtime, without giving up type safety. Both Rust and Swift\nhave demonstrated the value of this feature."),(0,i.kt)("h4",{id:"runtime-type-parameters"},"Runtime type parameters"),(0,i.kt)("p",null,"This feature is about allowing a function's type parameter to be passed in as a\ndynamic (non-generic) parameter. All values of that type would still be required\nto have the same type."),(0,i.kt)("h4",{id:"runtime-type-fields"},"Runtime type fields"),(0,i.kt)("p",null,"Instead of passing in a single type parameter to a function, we could store a\ntype per value. This changes the data layout of the value, and so is a somewhat\nmore invasive change. It also means that when a function operates on multiple\nvalues they could have different real types."),(0,i.kt)("h3",{id:"abstract-return-types"},"Abstract return types"),(0,i.kt)("p",null,"This lets you return an anonymous type implementing an interface from a\nfunction. In Rust this is the\n",(0,i.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/rfcs/1522-conservative-impl-trait.html"},(0,i.kt)("inlineCode",{parentName:"a"},"impl Trait")," return type"),"."),(0,i.kt)("p",null,'In Swift, there are discussions about implementing this feature under the name\n"reverse generics" or "opaque result types":\n',(0,i.kt)("a",{parentName:"p",href:"https://forums.swift.org/t/improving-the-ui-of-generics/22814#heading--reverse-generics"},"1"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://forums.swift.org/t/reverse-generics-and-opaque-result-types/21608"},"2"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://forums.swift.org/t/se-0244-opaque-result-types/21252"},"3"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://forums.swift.org/t/se-0244-opaque-result-types-reopened/22942"},"4"),",\nSwift is considering spelling this ",(0,i.kt)("inlineCode",{parentName:"p"},"<V: Collection> V")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"some Collection"),"."),(0,i.kt)("h3",{id:"evolution"},"Evolution"),(0,i.kt)("p",null,"There are a collection of use cases for making different changes to interfaces\nthat are already in use. These should be addressed either by describing how they\ncan be accomplished with existing generics features, or by adding features."),(0,i.kt)("p",null,"In addition, evolution from (C++ or Carbon) templates to generics needs to be\nsupported and made safe."),(0,i.kt)("h3",{id:"testing"},"Testing"),(0,i.kt)("p",null,"The idea is that you would write tests alongside an interface that validate the\nexpected behavior of any type implementing that interface."),(0,i.kt)("h3",{id:"impls-with-state"},"Impls with state"),(0,i.kt)("p",null,"A feature we might consider where an ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," itself can have state."),(0,i.kt)("h3",{id:"generic-associated-types-and-higher-ranked-types"},"Generic associated types and higher-ranked types"),(0,i.kt)("p",null,"This would be some way to express the requirement that there is a way to go from\na type to an implementation of an interface parameterized by that type."),(0,i.kt)("h4",{id:"generic-associated-types"},"Generic associated types"),(0,i.kt)("p",null,'Generic associated types are about when this is a requirement of an interface.\nThese are also called "associated type constructors."'),(0,i.kt)("h4",{id:"higher-ranked-types"},"Higher-ranked types"),(0,i.kt)("p",null,"Higher-ranked types are used to represent this requirement in a function\nsignature. They can be\n",(0,i.kt)("a",{parentName:"p",href:"https://smallcultfollowing.com/babysteps//blog/2016/11/03/associated-type-constructors-part-2-family-traits/"},"emulated using generic associated types"),"."),(0,i.kt)("h3",{id:"field-requirements"},"Field requirements"),(0,i.kt)("p",null,'We might want to allow interfaces to express the requirement that any\nimplementing type has a particular field. This would be to match the\nexpressivity of inheritance, which can express "all subtypes start with this\nlist of fields."'),(0,i.kt)("h3",{id:"bridge-for-c-customization-points"},"Bridge for C++ customization points"),(0,i.kt)("p",null,"See details in ",(0,i.kt)("a",{parentName:"p",href:"/design/generics/goals#bridge-for-c-customization-points"},"the goals document"),"."),(0,i.kt)("h3",{id:"variadic-arguments"},"Variadic arguments"),(0,i.kt)("p",null,"Some facility for allowing a function to generically take a variable number of\narguments."),(0,i.kt)("h3",{id:"range-constraints-on-generic-integers"},"Range constraints on generic integers"),(0,i.kt)("p",null,"We currently only support ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," clauses on type-of-types. We may want to also\nsupport constraints on generic integers. The constraint with the most expected\nvalue is the ability to do comparisons like ",(0,i.kt)("inlineCode",{parentName:"p"},"<"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},">="),". For example, you might\nconstrain the ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," member of ",(0,i.kt)("a",{parentName:"p",href:"#associated-constants"},(0,i.kt)("inlineCode",{parentName:"a"},"NSpacePoint"))," using an\nexpression like ",(0,i.kt)("inlineCode",{parentName:"p"},"PointT:! NSpacePoint where 2 <= .N and .N <= 3"),"."),(0,i.kt)("p",null,"The concern here is supporting this at compile time with more benefit than\ncomplexity. For example, we probably don't want to support integer-range based\ntypes at runtime, and there are also concerns about reasoning about comparisons\nbetween multiple generic integer parameters. For example, if ",(0,i.kt)("inlineCode",{parentName:"p"},"J < K")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"K <= L"),", can we call a function that requires ",(0,i.kt)("inlineCode",{parentName:"p"},"J < L"),"? There is also a\nsecondary syntactic concern about how to write this kind of constraint on a\nparameter, as opposed to an associated type, as in ",(0,i.kt)("inlineCode",{parentName:"p"},"N:! u32 where ___ >= 2"),"."),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/553"},"#553: Generics details part 1")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/731"},"#731: Generics details 2: adapters, associated types, parameterized interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/818"},"#818: Constraints for generics (generics details 3)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/931"},"#931: Generic impls access (details 4)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/920"},"#920: Generic parameterized impls (details 5)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/950"},"#950: Generic details 6: remove facets")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/983"},"#983: Generic details 7: final impls")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/990"},"#990: Generics details 8: interface default and final members")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1013"},"#1013: Generics: Set associated constants using ",(0,i.kt)("inlineCode",{parentName:"a"},"where")," constraints")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1084"},"#1084: Generics details 9: forward declarations")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1088"},"#1088: Generic details 10: interface-implemented requirements")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1144"},"#1144: Generic details 11: operator overloading")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1146"},"#1146: Generic details 12: parameterized types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/carbon-language/carbon-lang/pull/1327"},"#1327: Generics: ",(0,i.kt)("inlineCode",{parentName:"a"},"impl forall")))))}d.isMDXComponent=!0}}]);