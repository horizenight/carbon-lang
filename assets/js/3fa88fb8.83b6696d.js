"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8157],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,u=d["".concat(l,".").concat(m)]||d[m]||h[m]||o;return n?a.createElement(u,r(r({ref:t},p),{},{components:n})):a.createElement(u,r({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4214:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={},r="Principle: Low context-sensitivity",s={unversionedId:"principles/low_context_sensitivity",id:"principles/low_context_sensitivity",title:"Principle: Low context-sensitivity",description:"\x3c!--",source:"@site/../docs/project/principles/low_context_sensitivity.md",sourceDirName:"principles",slug:"/principles/low_context_sensitivity",permalink:"/carbon-lang/project/principles/low_context_sensitivity",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/../docs/project/principles/low_context_sensitivity.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Principle: All APIs are library APIs",permalink:"/carbon-lang/project/principles/library_apis_only"},next:{title:"Principle: Prefer providing only one way to do a given thing",permalink:"/carbon-lang/project/principles/one_way"}},l={},c=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Principle",id:"principle",level:2},{value:"Mitigations of context-sensitive costs",id:"mitigations-of-context-sensitive-costs",level:3},{value:"Visual aids",id:"visual-aids",level:4},{value:"Contextual <em>validity</em> rather than <em>meaning</em>",id:"contextual-validity-rather-than-meaning",level:4},{value:"Reduced cost of mistakes",id:"reduced-cost-of-mistakes",level:4},{value:"Compiler-checked context",id:"compiler-checked-context",level:5},{value:"Applications of the principle",id:"applications-of-the-principle",level:2},{value:"Imports and namespaces",id:"imports-and-namespaces",level:3},{value:"Name shadowing",id:"name-shadowing",level:3},{value:"Flow-sensitive typing",id:"flow-sensitive-typing",level:3},{value:"Coherence of names and generics",id:"coherence-of-names-and-generics",level:3},{value:"Performance",id:"performance",level:3}],p={toc:c};function h(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"principle-low-context-sensitivity"},"Principle: Low context-sensitivity"),(0,i.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#principle"},"Principle"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#mitigations-of-context-sensitive-costs"},"Mitigations of context-sensitive costs"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#visual-aids"},"Visual aids")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#contextual-_validity_-rather-than-_meaning_"},"Contextual ",(0,i.kt)("em",{parentName:"a"},"validity")," rather than ",(0,i.kt)("em",{parentName:"a"},"meaning"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#reduced-cost-of-mistakes"},"Reduced cost of mistakes"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#compiler-checked-context"},"Compiler-checked context")))))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#applications-of-the-principle"},"Applications of the principle"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#imports-and-namespaces"},"Imports and namespaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#name-shadowing"},"Name shadowing")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#flow-sensitive-typing"},"Flow-sensitive typing")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#coherence-of-names-and-generics"},"Coherence of names and generics")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#performance"},"Performance"))))),(0,i.kt)("h2",{id:"principle"},"Principle"),(0,i.kt)("p",null,"Carbon should favor designs and mechanisms that are not sensitive to context.\nInstead, we should favor constructs that are not ambiguous so that they don't\nneed context for disambiguation. This is in service to the goal that\n",(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write"},"Carbon code is easy to read, understand, and write"),".\nIn particular, this is about prioritizing reading and understanding over\nwriting. We should be willing to trade off conciseness, which still benefits\nreading as well as writing, for a sufficiently impactful reduction in the amount\nof context needed to read and understand code."),(0,i.kt)("p",null,"Context can be expensive in different ways, for example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It can be ",(0,i.kt)("em",{parentName:"li"},"large"),": it might require looking through a lot of lines of code\nto find all of the relevant contextual information."),(0,i.kt)("li",{parentName:"ul"},"It can be ",(0,i.kt)("em",{parentName:"li"},"distant"),": the further away from the current declaration or\ndefinition, the more expensive it is to find contextual information. This\ncan scale from a separate definition in the same file, to a separate file,\nor even to a separate package."),(0,i.kt)("li",{parentName:"ul"},"It can be ",(0,i.kt)("em",{parentName:"li"},"unpredictable"),": it might require careful searching of large\nbodies of code to locate the contextual information if its location cannot\nbe predicted."),(0,i.kt)("li",{parentName:"ul"},"It can be ",(0,i.kt)("em",{parentName:"li"},"subtle"),": the contextual clues might be easily missed or mistaken.")),(0,i.kt)("p",null,"Code that isn't context sensitive is easier to copy or move between contexts,\nlike files or functions. It is code that needs fewer changes when it is\nrefactored, in support of\n",(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals.md#software-and-language-evolution"},"software evolution"),"."),(0,i.kt)("p",null,"In general, we should start with more restrictive constructs that limit\nambiguity and see if we can make them work. If we find those restrictions are\nburdensome, we will then have more information to inform the next step. Ideally\nwe would address those use cases with simple tools that solve multiple problems.\nThe goal is to make a bunch of orthogonal mechanisms, each of which are easily\nunderstood and act in unsurprising ways."),(0,i.kt)("p",null,"If that next step is to loosen restrictions, that is generally easier to do\nwhile maintaining compatibility with existing code than adding new restrictions."),(0,i.kt)("h3",{id:"mitigations-of-context-sensitive-costs"},"Mitigations of context-sensitive costs"),(0,i.kt)("p",null,"There are several ways that the potential costs of context-sensitive code can be\nmitigated. These techniques can and should be leveraged to help minimize and\nmitigate the contextual costs of Carbon features, and in some cases may provide\na path to a feature that would otherwise be prohibitively costly."),(0,i.kt)("h4",{id:"visual-aids"},"Visual aids"),(0,i.kt)("p",null,"A direct way to reduce contextual costs is through lexical and syntactic\nstructures that form visual aids. These can both reinforce what the context is\nand aid the reader in the expensive aspect of navigating the context. For\nexample, representing contexts with indentation, or IDE highlighting of matching\nparentheses and braces. These visual hints make it easier for developers to\nnotice contextual elements."),(0,i.kt)("h4",{id:"contextual-validity-rather-than-meaning"},"Contextual ",(0,i.kt)("em",{parentName:"h4"},"validity")," rather than ",(0,i.kt)("em",{parentName:"h4"},"meaning")),(0,i.kt)("p",null,"When the context only affects the ",(0,i.kt)("em",{parentName:"p"},"validity")," of code, but not its meaning, the\ncosts are significantly reduced. In that case, understanding the meaning or\nbehavior of the code doesn't require context, and a developer can easily rely on\nthe compiler to check the validity. A simple example of this is contextually\nvalid syntax, which is relatively common and inexpensive. However, reusing the\nsame syntax with different contexts ",(0,i.kt)("em",{parentName:"p"},"with different meanings")," shifts the\ncontextual information from simple validity to impacting the meaning of code."),(0,i.kt)("h4",{id:"reduced-cost-of-mistakes"},"Reduced cost of mistakes"),(0,i.kt)("p",null,"Another mitigation for the costs of context-sensitive code is when the cost of a\nmistake due to the context is low. Some simple examples:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Context-sensitivity in comments is less expensive in general than in code."),(0,i.kt)("li",{parentName:"ul"},"In places where the general meaning is clear, developers can safely and\nreliably work with that general understanding, and the context only provides\na minor refinement.")),(0,i.kt)("h5",{id:"compiler-checked-context"},"Compiler-checked context"),(0,i.kt)("p",null,"Another way the costs of mistakes can be reduced is when the compiler can\nreliably detect them. This is the fundamental idea behind statically\ntype-checked languages: the compiler enforcement reduces the contextual cost of\nknowing what the types are. How early and effectively the compiler can detect\nthe mistakes also plays a role in reducing this cost, which is part of the value\nproposition for\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/generics/terminology.md#definition-checking"},"definition-checked"),"\ngenerics."),(0,i.kt)("p",null,"An example of this situation in Rust is that the same syntax is used for a move\nand a copy of the value in a variable. Those cases are distinguished by whether\nthe type implements a specific trait, which may not be readily ascertained. The\ncompiler verifies that the code never uses a variable that is no longer valid\ndue to having been moved from, which is expected to catch the problems that\ncould arise from this difference. Otherwise the semantic difference between a\nmove and a copy is considered in Rust to be low-enough stakes for there to be no\nneed to signal that difference in the code."),(0,i.kt)("p",null,"However, the reasoning that makes this example a good design on balance for Rust\ndoesn't necessarily apply to Carbon. The compiler is checking to prevent\n",(0,i.kt)("em",{parentName:"p"},"errors"),", but it can't reliably check for unpredictable ",(0,i.kt)("em",{parentName:"p"},"performance"),". Given\nCarbon's priorities, that might make this level of contextual information still\ntoo expensive."),(0,i.kt)("p",null,"More background on this area of Rust specifically is presented in\n",(0,i.kt)("a",{parentName:"p",href:"https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html"},"their blog post on language ergonomics"),"."),(0,i.kt)("h2",{id:"applications-of-the-principle"},"Applications of the principle"),(0,i.kt)("p",null,"There are many parts of Carbon that could potentially be analyzed through this\nlens, and we can't enumerate them all here. This section focuses on several\nexamples to help illustrate how the principle is likely to be relevant to\nCarbon. They focus on either cases that showcase the principle in effect or\ncases which make challenging tradeoffs of the costs in the principle."),(0,i.kt)("h3",{id:"imports-and-namespaces"},"Imports and namespaces"),(0,i.kt)("p",null,"There are several parts of the way\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/code_and_name_organization/#imports"},"imports")," and\n",(0,i.kt)("a",{parentName:"p",href:"/docs/design/code_and_name_organization/#namespaces"},"namespaces")," are designed\nin Carbon that reflect applications of this principle:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Adding an import or reordering imports should never change behavior of\nexisting code. This means the reader doesn't have to look through all the\nimports to understand how code behaves. This is also important for tooling,\nwhich should not have to worry about unwanted side effects when adding or\nsorting imports.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Carbon doesn't provide an analogy to C++'s\n",(0,i.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/namespace#Using-directives"},(0,i.kt)("inlineCode",{parentName:"a"},"using namespace")),"\nor a\n",(0,i.kt)("a",{parentName:"p",href:"/proposals/p0107.md#broader-imports-either-all-names-or-arbitrary-code"},'"wildcard imports" mechanisms'),"\nthat merge the names from one namespace into another. Either would introduce\nambiguity in where a name is coming from, making the code more\ncontext-sensitive.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Carbon doesn't support large blocks of code\n",(0,i.kt)("a",{parentName:"p",href:"/proposals/p0107.md#scoped-namespaces"},"inside a namespace declaration"),",\nwhere the reader would have to search for the beginning of the block to see\nwhat namespace applies."))),(0,i.kt)("h3",{id:"name-shadowing"},"Name shadowing"),(0,i.kt)("p",null,"We should limit how names can be reused with shadowing rules, so the meaning of\na name doesn't change in surprising ways between scopes. Further, if you find a\nmatching declaration you don't have to keep searching to see if there is another\nthat hides the one you found. This both expands the context you have to\nconsider, and is an opportunity to make a mistake identifying the correct\ncontext, potentially leading to misunderstanding of the code."),(0,i.kt)("h3",{id:"flow-sensitive-typing"},"Flow-sensitive typing"),(0,i.kt)("p",null,"This principle is an argument against\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Flow-sensitive_typing"},"flow-sensitive typing"),",\nwhere the type of a name can change depending on control flow. For example,\n",(0,i.kt)("a",{parentName:"p",href:"http://joeduffyblog.com/2016/02/07/the-error-model/#the-syntax"},"Midori used this for optional types"),".\nIf we were to support this in Carbon, you could unwrap an optional value by\ntesting it against ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var x: Optional(Int) = ...;\nif (x != None) {\n  // x has type Int.\n  PrintInt(x);\n}\n// x is back to type Optional(Int).\n")),(0,i.kt)("p",null,"This can be taken farther, this example has ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," taking on three different types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"var x: Optional(Optional(Int)) = ...;\nif (x != None) {\n  // x has type Optional(Int).\n  if (x != None) {\n    // x has type Int.\n    PrintInt(x);\n  }\n  // x has type Optional(Int).\n}\n// x has type Optional(Optional(Int)).\n")),(0,i.kt)("p",null,"The concern here is that the context is very subtle. The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is affected\nby otherwise ordinary-looking ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statements and closing braces (",(0,i.kt)("inlineCode",{parentName:"p"},"}"),")."),(0,i.kt)("p",null,"While we might not want to completely eliminate the possibility of\nflow-sensitive typing in Carbon, it would have to overcome a large hurdle. We\nwould only want a flow-sensitive feature if it delivered sufficiently large\nusability, consistency, or expressivity gains."),(0,i.kt)("h3",{id:"coherence-of-names-and-generics"},"Coherence of names and generics"),(0,i.kt)("p",null,"Carbon ",(0,i.kt)("a",{parentName:"p",href:"/docs/design/code_and_name_organization/#packages"},"packages")," are\ndesigned to ensure all declared names belong to exactly one package and the\ncompiler can enforcement Carbon's equivalent\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/One_Definition_Rule"},"one-definition rule (ODR)"),".\nThis avoids an issue in C++ where the ODR is not reliably checked by the\ncompiler, which can leave the correctness of programs dependent on both distant\nand subtle contextual information."),(0,i.kt)("p",null,"Similarly, Carbon generics should have\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Ixrec/rust-orphan-rules#what-is-coherence"},"coherence, like Rust"),",\nwhere types have a single implementation of an interface. And this should be\nenforced by the compiler, using rules like\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Ixrec/rust-orphan-rules#what-are-the-orphan-rules"},"Rust's orphan rules"),"."),(0,i.kt)("h3",{id:"performance"},"Performance"),(0,i.kt)("p",null,"Since\n",(0,i.kt)("a",{parentName:"p",href:"/docs/project/goals.md#performance-critical-software"},"Carbon's number one goal is performance"),",\nit is important that the performance characteristics of code be predictable and\nreadily determined by readers. This argues that those characteristics should not\ndepend on expensive context. For example, Carbon should not provide a\n",(0,i.kt)("inlineCode",{parentName:"p"},"dynamic_cast")," facility with the same capabilities of C++'s where distant\naspects of the inheritance structure can cause surprising performance\ndifferences. Similarly, Carbon should try to ensure normal looking method calls\nand data member access don't have the surprising performance costs caused by\nvirtual inheritance in C++."),(0,i.kt)("p",null,"More generally, Carbon should avoid features with hidden costs, particularly\nwhen they scale based on subtle aspects of the context where those features are\nused."))}h.isMDXComponent=!0}}]);