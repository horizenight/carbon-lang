"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1618],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),c=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=c(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=c(n),h=r,d=m["".concat(p,".").concat(h)]||m[h]||u[h]||i;return n?a.createElement(d,l(l({ref:t},s),{},{components:n})):a.createElement(d,l({ref:t},s))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var c=2;c<i;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4358:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={},l="Pattern matching",o={unversionedId:"pattern_matching",id:"pattern_matching",title:"Pattern matching",description:"\x3c!--",source:"@site/../docs/design/pattern_matching.md",sourceDirName:".",slug:"/pattern_matching",permalink:"/design/pattern_matching",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/../docs/design/pattern_matching.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Naming conventions",permalink:"/design/naming_conventions"},next:{title:"Primitive types",permalink:"/design/primitive_types"}},p={},c=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"TODO",id:"todo",level:2},{value:"Overview",id:"overview",level:2},{value:"Pattern match control flow",id:"pattern-match-control-flow",level:3},{value:"Pattern matching in local variables",id:"pattern-matching-in-local-variables",level:3},{value:"Open questions",id:"open-questions",level:2},{value:"Slice or array nested value pattern matching",id:"slice-or-array-nested-value-pattern-matching",level:3},{value:"Generic/template pattern matching",id:"generictemplate-pattern-matching",level:3},{value:"Pattern matching as function overload resolution",id:"pattern-matching-as-function-overload-resolution",level:3}],s={toc:c};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"pattern-matching"},"Pattern matching"),(0,r.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#todo"},"TODO")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#overview"},"Overview"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#pattern-match-control-flow"},"Pattern match control flow")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#pattern-matching-in-local-variables"},"Pattern matching in local variables")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#open-questions"},"Open questions"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#slice-or-array-nested-value-pattern-matching"},"Slice or array nested value pattern matching")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#generictemplate-pattern-matching"},"Generic/template pattern matching")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#pattern-matching-as-function-overload-resolution"},"Pattern matching as function overload resolution"))))),(0,r.kt)("h2",{id:"todo"},"TODO"),(0,r.kt)("p",null,"This is a skeletal design, added to support ",(0,r.kt)("a",{parentName:"p",href:"/design/"},"the overview"),". It should\nnot be treated as accepted by the core team; rather, it is a placeholder until\nwe have more time to examine this detail. Please feel welcome to rewrite and\nupdate as appropriate."),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"The most prominent mechanism to manipulate and work with types in Carbon is\npattern matching. This may seem like a deviation from C++, but in fact this is\nlargely about building a clear, coherent model for a fundamental part of C++:\noverload resolution."),(0,r.kt)("h3",{id:"pattern-match-control-flow"},"Pattern match control flow"),(0,r.kt)("p",null,"The most powerful form and easiest to explain form of pattern matching is a\ndedicated control flow construct that subsumes the ",(0,r.kt)("inlineCode",{parentName:"p"},"switch")," of C and C++ into\nsomething much more powerful, ",(0,r.kt)("inlineCode",{parentName:"p"},"match"),". This is not a novel construct, and is\nwidely used in existing languages (Swift and Rust among others) and is currently\nunder active investigation for C++. Carbon's ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," can be used as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fn Bar() -> (i32, (f32, f32));\nfn Foo() -> f32 {\n  match (Bar()) {\n    case (42, (x: f32, y: f32)) => {\n      return x - y;\n    }\n    case (p: i32, (x: f32, _: f32)) if (p < 13) => {\n      return p * x;\n    }\n    case (p: i32, _: auto) if (p > 3) => {\n      return p * Pi;\n    }\n    default => {\n      return Pi;\n    }\n  }\n}\n")),(0,r.kt)("p",null,"There is a lot going on here. First, let's break down the core structure of a\n",(0,r.kt)("inlineCode",{parentName:"p"},"match")," statement. It accepts a value that will be inspected, here the result of\nthe call to ",(0,r.kt)("inlineCode",{parentName:"p"},"Bar()"),". It then will find the ",(0,r.kt)("em",{parentName:"p"},"first")," ",(0,r.kt)("inlineCode",{parentName:"p"},"case")," that matches this\nvalue, and execute that block. If none match, then it executes the default\nblock."),(0,r.kt)("p",null,"Each ",(0,r.kt)("inlineCode",{parentName:"p"},"case")," contains a pattern. The first part is a value pattern\n(",(0,r.kt)("inlineCode",{parentName:"p"},"(p: i32, _: auto)")," for example) optionally followed by an ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," and boolean\npredicate. The value pattern has to match, and then the predicate has to\nevaluate to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," for the overall pattern to match. Value patterns can be\ncomposed of the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An expression (",(0,r.kt)("inlineCode",{parentName:"li"},"42")," for example), whose value must be equal to match."),(0,r.kt)("li",{parentName:"ul"},"An identifier to bind the value to, followed by a colon (",(0,r.kt)("inlineCode",{parentName:"li"},":"),") and a type\n(",(0,r.kt)("inlineCode",{parentName:"li"},"i32")," for example). An underscore (",(0,r.kt)("inlineCode",{parentName:"li"},"_"),") may be used instead of the\nidentifier to discard the value once matched."),(0,r.kt)("li",{parentName:"ul"},"A tuple destructuring pattern containing a tuple of value patterns\n(",(0,r.kt)("inlineCode",{parentName:"li"},"(x: f32, y: f32)"),") which match against tuples and tuple-like values by\nrecursively matching on their elements."),(0,r.kt)("li",{parentName:"ul"},"An unwrapping pattern containing a nested value pattern which matches\nagainst a variant or variant-like value by unwrapping it.")),(0,r.kt)("p",null,"In order to match a value, whatever is specified in the pattern must match.\nUsing ",(0,r.kt)("inlineCode",{parentName:"p"},"auto")," for a type will always match, making ",(0,r.kt)("inlineCode",{parentName:"p"},"_: auto")," the wildcard\npattern."),(0,r.kt)("h3",{id:"pattern-matching-in-local-variables"},"Pattern matching in local variables"),(0,r.kt)("p",null,"Value patterns may be used when declaring local variables to conveniently\ndestructure them and do other type manipulations. However, the patterns must\nmatch at compile time, so they can't use an ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," clause."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fn Bar() -> (i32, (f32, f32));\nfn Foo() -> i32 {\n  var (p: i32, _: auto) = Bar();\n  return p;\n}\n")),(0,r.kt)("p",null,"This extracts the first value from the result of calling ",(0,r.kt)("inlineCode",{parentName:"p"},"Bar()")," and binds it to\na local variable named ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," which is then returned."),(0,r.kt)("h2",{id:"open-questions"},"Open questions"),(0,r.kt)("h3",{id:"slice-or-array-nested-value-pattern-matching"},"Slice or array nested value pattern matching"),(0,r.kt)("p",null,'An open question is how to effectively fit a "slice" or "array" pattern into\nnested value pattern matching, or whether we shouldn\'t do so.'),(0,r.kt)("h3",{id:"generictemplate-pattern-matching"},"Generic/template pattern matching"),(0,r.kt)("p",null,'An open question is going beyond a simple "type" to things that support generics\nand/or templates.'),(0,r.kt)("h3",{id:"pattern-matching-as-function-overload-resolution"},"Pattern matching as function overload resolution"),(0,r.kt)("p",null,"Need to flesh out specific details of how overload selection leverages the\npattern matching machinery, what (if any) restrictions are imposed, etc."))}u.isMDXComponent=!0}}]);