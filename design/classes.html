<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-design docs-doc-id-classes">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-rc.1">
<title data-rh="true">Classes | Carbon Language</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://emlai.github.io/carbon-lang/design/classes"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-design-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-design-current"><meta data-rh="true" property="og:title" content="Classes | Carbon Language"><meta data-rh="true" name="description" content="&lt;!--"><meta data-rh="true" property="og:description" content="&lt;!--"><link data-rh="true" rel="icon" href="/carbon-lang/img/carbon-logo.png"><link data-rh="true" rel="canonical" href="https://emlai.github.io/carbon-lang/design/classes"><link data-rh="true" rel="alternate" href="https://emlai.github.io/carbon-lang/design/classes" hreflang="en"><link data-rh="true" rel="alternate" href="https://emlai.github.io/carbon-lang/design/classes" hreflang="x-default"><link rel="stylesheet" href="/carbon-lang/assets/css/styles.009a6ecf.css">
<link rel="preload" href="/carbon-lang/assets/js/runtime~main.256c0991.js" as="script">
<link rel="preload" href="/carbon-lang/assets/js/main.5fcc8113.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/carbon-lang/"><div class="navbar__logo"><img src="/carbon-lang/img/carbon-logo.png" alt="Carbon Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/carbon-lang/img/carbon-logo.png" alt="Carbon Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Carbon Language</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/carbon-lang/design">Design</a><a class="navbar__item navbar__link" href="/carbon-lang/spec">Spec</a><a class="navbar__item navbar__link" href="/carbon-lang/project">Project</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/carbon-language/carbon-lang" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design">Language design</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/aliases">Aliases</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/blocks_and_statements">Blocks and statements</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/carbon-lang/design/classes">Classes</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/code_and_name_organization">Code and name organization</a><button aria-label="Toggle the collapsible sidebar category &#x27;Code and name organization&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/control_flow">Control flow</a><button aria-label="Toggle the collapsible sidebar category &#x27;Control flow&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/expressions">Expressions</a><button aria-label="Toggle the collapsible sidebar category &#x27;Expressions&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/functions">Functions</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/generics">Generics</a><button aria-label="Toggle the collapsible sidebar category &#x27;Generics&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/interoperability">Bidirectional interoperability with C/C++</a><button aria-label="Toggle the collapsible sidebar category &#x27;Bidirectional interoperability with C/C++&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/lexical_conventions">Lexical conventions</a><button aria-label="Toggle the collapsible sidebar category &#x27;Lexical conventions&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/metaprogramming">Metaprogramming</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/name_lookup">Name lookup</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/naming_conventions">Naming conventions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/pattern_matching">Pattern matching</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/primitive_types">Primitive types</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/templates">Templates</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/tuples">Tuples</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/type_inference">Type inference</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/variables">Variables</a></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/carbon-lang/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Classes</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Classes</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="table-of-contents">Table of contents<a class="hash-link" href="#table-of-contents" title="Direct link to heading">​</a></h2><ul><li><a href="#overview">Overview</a></li><li><a href="#use-cases">Use cases</a><ul><li><a href="#data-classes">Data classes</a></li><li><a href="#encapsulated-types">Encapsulated types</a><ul><li><a href="#without-inheritance">Without inheritance</a></li><li><a href="#with-inheritance-and-subtyping">With inheritance and subtyping</a><ul><li><a href="#polymorphic-types">Polymorphic types</a><ul><li><a href="#interface-as-base-class">Interface as base class</a></li></ul></li><li><a href="#non-polymorphic-inheritance">Non-polymorphic inheritance</a></li><li><a href="#interop-with-c-multiple-inheritance">Interop with C++ multiple inheritance</a></li></ul></li></ul></li><li><a href="#mixins">Mixins</a></li></ul></li><li><a href="#background">Background</a></li><li><a href="#members">Members</a><ul><li><a href="#data-members-have-an-order">Data members have an order</a></li></ul></li><li><a href="#struct-types">Struct types</a><ul><li><a href="#literals">Literals</a></li><li><a href="#type-expression">Type expression</a></li><li><a href="#assignment-and-initialization">Assignment and initialization</a></li><li><a href="#operations-performed-field-wise">Operations performed field-wise</a></li></ul></li><li><a href="#nominal-class-types">Nominal class types</a><ul><li><a href="#forward-declaration">Forward declaration</a></li><li><a href="#self">Self</a></li><li><a href="#construction">Construction</a><ul><li><a href="#assignment">Assignment</a></li></ul></li><li><a href="#member-functions">Member functions</a><ul><li><a href="#class-functions">Class functions</a></li><li><a href="#methods">Methods</a></li><li><a href="#name-lookup-in-member-function-definitions">Name lookup in member function definitions</a></li></ul></li><li><a href="#nominal-data-classes">Nominal data classes</a></li><li><a href="#member-type">Member type</a></li><li><a href="#let">Let</a></li><li><a href="#alias">Alias</a></li><li><a href="#inheritance">Inheritance</a><ul><li><a href="#virtual-methods">Virtual methods</a><ul><li><a href="#virtual-override-keywords">Virtual override keywords</a></li></ul></li><li><a href="#subtyping">Subtyping</a></li><li><a href="#constructors">Constructors</a><ul><li><a href="#partial-facet">Partial facet</a></li><li><a href="#usage">Usage</a></li></ul></li><li><a href="#assignment-with-inheritance">Assignment with inheritance</a></li></ul></li><li><a href="#destructors">Destructors</a></li><li><a href="#access-control">Access control</a><ul><li><a href="#private-access">Private access</a></li><li><a href="#protected-access">Protected access</a></li><li><a href="#friends">Friends</a></li><li><a href="#test-friendship">Test friendship</a></li><li><a href="#access-control-for-construction">Access control for construction</a></li></ul></li><li><a href="#operator-overloading">Operator overloading</a></li></ul></li><li><a href="#future-work">Future work</a><ul><li><a href="#struct-literal-shortcut">Struct literal shortcut</a></li><li><a href="#optional-named-parameters">Optional named parameters</a><ul><li><a href="#field-defaults-for-struct-types">Field defaults for struct types</a></li><li><a href="#destructuring-in-pattern-matching">Destructuring in pattern matching</a></li><li><a href="#discussion">Discussion</a></li></ul></li><li><a href="#inheritance-1">Inheritance</a><ul><li><a href="#c-abstract-base-classes-interoperating-with-object-safe-interfaces">C++ abstract base classes interoperating with object-safe interfaces</a></li><li><a href="#overloaded-methods">Overloaded methods</a></li><li><a href="#interop-with-c-inheritance">Interop with C++ inheritance</a><ul><li><a href="#virtual-base-classes">Virtual base classes</a></li></ul></li></ul></li><li><a href="#mixins-1">Mixins</a></li><li><a href="#memory-layout">Memory layout</a></li><li><a href="#no-static-variables">No <code>static</code> variables</a></li><li><a href="#computed-properties">Computed properties</a></li><li><a href="#interfaces-implemented-for-data-classes">Interfaces implemented for data classes</a></li></ul></li><li><a href="#references">References</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="overview">Overview<a class="hash-link" href="#overview" title="Direct link to heading">​</a></h2><p>A Carbon <em>class</em> is a user-defined
<a href="https://en.wikipedia.org/wiki/Record_(computer_science)" target="_blank" rel="noopener noreferrer">record type</a>. A
class has members that are referenced by their names, in contrast to a
<a href="/carbon-lang/design/tuples">Carbon tuple</a> which defines a
<a href="https://en.wikipedia.org/wiki/Product_type" target="_blank" rel="noopener noreferrer">product type</a> whose members are
referenced positionally.</p><p>Classes are the primary mechanism for users to extend the Carbon type system and
are deeply rooted in C++ and its history (C and Simula). We call them classes
rather than other terms as that is both familiar to existing programmers and
accurately captures their essence: they define the types of objects with
(optional) support for methods, encapsulation, and so on.</p><p>Carbon supports both named, or &quot;nominal&quot;, and unnamed, anonymous, or
&quot;structural&quot;, class types. Nominal class types are all distinct, but structural
types are equal if they have the same sequence of member types and names.
Structural class literals may be used to initialize or assign values to nominal
class variables.</p><p>A class type defines the interpretation of the bytes of a value of that type,
including the size, data members, and layout. It defines the operations that may
be performed on those values, including what methods may be called. A class type
may directly have constant members. The type itself is a compile-time immutable
constant value.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="use-cases">Use cases<a class="hash-link" href="#use-cases" title="Direct link to heading">​</a></h2><p>The use cases for classes include both cases motivated by C++ interop, and cases
that we expect to be included in idiomatic Carbon-only code.</p><p><strong>This design currently only attempts to address the &quot;data classes&quot; and
&quot;encapsulated types&quot; use cases.</strong> Addressing the &quot;interface as base class&quot;,
&quot;interop with C++ multiple inheritance&quot; and &quot;mixin&quot; use cases is future work.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="data-classes">Data classes<a class="hash-link" href="#data-classes" title="Direct link to heading">​</a></h3><p>Data classes are types that consist of data fields that are publicly accessible
and directly read and manipulated by client code. They have few if any methods,
and generally are not involved in inheritance at all.</p><p>Examples include:</p><ul><li>a key and value pair returned from a <code>SortedMap</code> or <code>HashMap</code></li><li>a 2D point that might be used in a rendering API</li></ul><p>Properties:</p><ul><li>Operations like copy, move, destroy, unformed, and so on are defined
field-wise.</li><li>Anonymous classes types and literals should match data class semantics.</li></ul><p>Expected in idiomatic Carbon-only code.</p><p><strong>Background:</strong> Kotlin has a dedicated concise syntax for defining
<a href="https://kotlinlang.org/docs/data-classes.html" target="_blank" rel="noopener noreferrer"><em>data classes</em></a> that avoids
boilerplate. Python has a
<a href="https://docs.python.org/3/library/dataclasses.html" target="_blank" rel="noopener noreferrer">data class library</a>,
proposed in <a href="https://www.python.org/dev/peps/pep-0557/" target="_blank" rel="noopener noreferrer">PEP 557</a>, that fills a
similar role.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="encapsulated-types">Encapsulated types<a class="hash-link" href="#encapsulated-types" title="Direct link to heading">​</a></h3><p>There are several categories of types that support
<a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" target="_blank" rel="noopener noreferrer">encapsulation</a>.
This is done by making their data fields private so access and modification of
values are all done through methods defined on the type.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="without-inheritance">Without inheritance<a class="hash-link" href="#without-inheritance" title="Direct link to heading">​</a></h4><p>The common case for encapsulated types are those that do not participate in
inheritance. These types neither support being inherited from (they are
<a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)#Non-subclassable_classes" target="_blank" rel="noopener noreferrer">&quot;final&quot;</a>)
nor do they extend other types.</p><p>Examples of this use case include:</p><ul><li>strings, containers, iterators</li><li>types with invariants such as <code>Date</code></li><li>RAII types that are movable but not copyable like C++&#x27;s <code>std::unique_ptr</code> or
a file handle</li><li>non-movable types like <code>Mutex</code></li></ul><p>We expect two kinds of methods on these types: public methods defining the API
for accessing and manipulating values of the type, and private helper methods
used as an implementation detail of the public methods.</p><p>These types are expected in idiomatic Carbon-only code.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="with-inheritance-and-subtyping">With inheritance and subtyping<a class="hash-link" href="#with-inheritance-and-subtyping" title="Direct link to heading">​</a></h4><p>The <a href="https://en.wikipedia.org/wiki/Subtyping" target="_blank" rel="noopener noreferrer">subtyping</a> you get with
inheritance is that you may assign the address of an object of a derived type to
a pointer to its base type. For this to work, the compiler needs implementation
strategies that allow operations performed through the pointer to the base type
work independent of which derived type it actually points to. These strategies
include:</p><ul><li>Arranging for the the data layout of derived types to start with the data
layout of the base type as a prefix.</li><li>Putting a pointer to a table of function pointers, a
<a href="https://en.wikipedia.org/wiki/Virtual_method_table" target="_blank" rel="noopener noreferrer"><em>vtable</em></a>, as the first
data member of the object. This allows methods to be
<a href="https://en.wikipedia.org/wiki/Virtual_function" target="_blank" rel="noopener noreferrer"><em>virtual</em></a> and have a
derived-type-specific implementation, an <em>override</em>, that is used even when
invoking the method on a pointer to a base type.</li><li>Non-virtual methods implemented on a base type should be applicable to all
derived types. In general, derived types should not attempt to overload or
override non-virtual names defined in the base type.</li></ul><p>Note that these subtyping implementation strategies generally rely on
encapsulation, but encapsulation is not a strict requirement in all cases.</p><p>This subtyping relationship also creates safety concerns, which Carbon should
protect against.
<a href="https://en.wikipedia.org/wiki/Object_slicing" target="_blank" rel="noopener noreferrer">Slicing problems</a> can arise when
the source or target of an assignment is a dereferenced pointer to the base
type. It is also incorrect to delete an object with a non-virtual destructor
through a pointer to a base type.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="polymorphic-types">Polymorphic types<a class="hash-link" href="#polymorphic-types" title="Direct link to heading">​</a></h5><p>Carbon will fully support single-inheritance type hierarchies with polymorphic
types.</p><p>Polymorphic types support
<a href="https://en.wikipedia.org/wiki/Dynamic_dispatch" target="_blank" rel="noopener noreferrer">dynamic dispatch</a> using a
<a href="https://en.wikipedia.org/wiki/Virtual_method_table" target="_blank" rel="noopener noreferrer">vtable</a>, and data members,
but only single inheritance. Individual methods opt in to using dynamic
dispatch, so types will have a mix of
<a href="https://en.wikipedia.org/wiki/Virtual_function" target="_blank" rel="noopener noreferrer">&quot;virtual&quot;</a> and non-virtual
methods. Polymorphic types support traditional
<a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" target="_blank" rel="noopener noreferrer">object-oriented single inheritance</a>,
a mix of <a href="https://en.wikipedia.org/wiki/Subtyping" target="_blank" rel="noopener noreferrer">subtyping</a> and
<a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)#Code_reuse" target="_blank" rel="noopener noreferrer">implementation and code reuse</a>.</p><p>We exclude complex multiple inheritance schemes, virtual inheritance, and so on
from this use case. This is to avoid the complexity and overhead they bring,
particularly since the use of these features in C++ is generally discouraged.
The rule is that every type has at most one base type with data members for
subtyping purposes. Carbon will support additional base types as long as they
<a href="#interface-as-base-class">don&#x27;t have data members</a> or
<a href="#mixins">don&#x27;t support subtyping</a>.</p><p><strong>Background:</strong>
<a href="https://www.youtube.com/watch?v=OMPfEXIlTVE" target="_blank" rel="noopener noreferrer">The &quot;Nothing is Something&quot; talk by Sandi Metz</a>
and
<a href="https://python-patterns.guide/gang-of-four/composition-over-inheritance/" target="_blank" rel="noopener noreferrer">the Composition Over Inheritance Principle</a>
describe design patterns to use instead of multiple inheritance to support types
that vary over multiple axes.</p><p>In rare cases where the complex multiple inheritance schemes of C++ are truly
needed, they can be effectively approximated using a combination of these
simpler building blocks.</p><p>Polymorphic types support a number of different kinds of methods:</p><ul><li>They will have virtual methods:<ul><li>Polymorphic types will typically include virtual destructors.</li><li>The virtual methods types may have default implementations or be
<a href="https://en.wikipedia.org/wiki/Method_(computer_programming)#Abstract_methods" target="_blank" rel="noopener noreferrer"><em>abstract</em></a>
(or
<a href="https://en.wikipedia.org/wiki/Virtual_function#Abstract_classes_and_pure_virtual_functions" target="_blank" rel="noopener noreferrer"><em>pure virtual</em></a>).
In the latter case, they must be implemented in any derived class that
can be instantiated.</li><li>Virtual methods may be
<a href="https://en.wikipedia.org/wiki/Access_modifiers" target="_blank" rel="noopener noreferrer"><em>protected</em></a> or
<a href="https://stackoverflow.com/questions/2170688/private-virtual-method-in-c" target="_blank" rel="noopener noreferrer"><em>private</em></a>,
intended to be called by methods in the base type but implemented in the
descendant.</li></ul></li><li>They may have non-virtual public or private helper methods, like
<a href="#without-inheritance">encapsulated types without inheritance</a>. These avoid
the overhead of a virtual function call, and can be written when the base
class has sufficient data members.</li><li>They may have protected helper methods, typically non-virtual, provided by
the base type to be called by the descendant.</li></ul><p>Note that there are two uses for protected methods: those implemented in the
base and called in the descendant, and the other way around.
<a href="https://www.youtube.com/watch?v=3MNVP9-hglc" target="_blank" rel="noopener noreferrer">&quot;The End Of Object Inheritance &amp; The Beginning Of A New Modularity&quot; talk by Augie Fackler and Nathaniel Manista</a>
discusses design patterns that split up types to reduce the number of kinds of
calls between base and derived types, and make sure calls only go in one
direction.</p><p>We expect polymorphic types in idiomatic Carbon-only code, at least for the
medium term. Extending this design to support polymorphic types is future work.</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="interface-as-base-class">Interface as base class<a class="hash-link" href="#interface-as-base-class" title="Direct link to heading">​</a></h6><p>We distinguish the specific case of polymorphic base classes that have no data
members:</p><ul><li>From an implementation perspective, the lack of data members removes most of
the problems with supporting multiple inheritance.</li><li>They are about decoupling two pieces of code instead of collaborating.</li><li>As a use case, they are used primarily for subtyping and much less
implementation reuse than other polymorphic types.</li><li>This case overlaps with the
<a href="/carbon-lang/docs/design/generics/terminology.md#interface">interface</a> concept
introduced for <a href="/carbon-lang/docs/design/generics/overview.md">Carbon generics</a>.</li></ul><p>Removing support for data fields greatly simplifies supporting multiple
inheritance. For example, it removes the need for a mechanism to figure out the
offset of those data fields in the object. Similarly we don&#x27;t need
<a href="https://en.wikipedia.org/wiki/Virtual_inheritance" target="_blank" rel="noopener noreferrer">C++&#x27;s virtual inheritance</a>
to avoid duplicating those fields. Some complexities still remain, such as
pointers changing values when casting to a secondary parent type, but these seem
manageable given the benefits of supporting this useful case of multiple
inheritance.</p><p>While an interface base class is generally for providing an API that allows
decoupling two pieces of code, a polymorphic type is a collaboration between a
base and derived type to provide some functionality. This is a bit like the
difference between a library and a framework, where you might use many of the
former but only one of the latter.</p><p>Interface base classes are primarily used for subtyping. The extent of
implementation reuse is generally limited by the lack of data members, and the
decoupling role they play is usually about defining an API as a set of public
pure-virtual methods. Compared to other polymorphic types, they more rarely have
methods with implementations (virtual or not), or have methods with restricted
access. The main use case is when there is a method that is implemented in terms
of pure-virtual methods. Those pure-virtual methods may be marked as protected
to ensure they are only called through the non-abstract API, but can still be
implemented in descendants.</p><p>While it is typical for this case to be associated with single-level inheritance
hierarchies, there are some cases where there is an interface at the root of a
type hierarchy and polymorphic types as interior branches of the tree. The case
of generic interfaces extending or requiring other interface would also be
modeled by deeper inheritance hierarchies.</p><p>An interface as base class needs to either have a virtual destructor or forbid
deallocation.</p><p>There is significant overlap between interface base classes and
<a href="/carbon-lang/design/generics/overview#interfaces">Carbon interfaces</a>. Both represent APIs as a
collection of method names and signatures to implement. The subset of interfaces
that support dynamic dispatch are called <em>object-safe</em>, following
<a href="https://doc.rust-lang.org/reference/items/traits.html#object-safety" target="_blank" rel="noopener noreferrer">Rust</a>:</p><ul><li>They don&#x27;t have a <code>Self</code> in the signature of a method in a contravariant
position like a parameter.</li><li>They don&#x27;t have free associated types or other associated items used in a
method signature.</li></ul><p>The restrictions on object-safe interfaces match the restrictions on base class
methods. The main difference is the representation in memory. A type extending a
base class with virtual methods includes a pointer to the table of methods in
the object value itself, while a type implementing an interface would store the
pointer alongside the pointer to the value in a <code>DynPtr(MyInterface)</code>. Of
course, the interface option also allows the method table to be passed at
compile time.</p><p><strong>Note:</strong> This presumes that we include some concept of <code>final</code> methods in
interfaces to match non-virtual functions in base classes.</p><p>We expect idiomatic Carbon-only code to generally use Carbon interfaces instead
of interface base classes. We may still support interface base classes long term
if we determine that the ability to put the pointer to the method
implementations in the object value is important for users, particularly with a
single parent as in the <a href="#polymorphic-types">polymorphic type case</a>. Extending
this design to support interface base classes is future work.</p><p><strong>Background:</strong>
<a href="https://en.wikipedia.org/wiki/Abstract_type" target="_blank" rel="noopener noreferrer">C++ abstract base classes</a> that
don&#x27;t have data members and
<a href="https://en.wikipedia.org/wiki/Interface_(Java)" target="_blank" rel="noopener noreferrer">Java interfaces</a> model this
case.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="non-polymorphic-inheritance">Non-polymorphic inheritance<a class="hash-link" href="#non-polymorphic-inheritance" title="Direct link to heading">​</a></h5><p>While it is not common, there are cases where C++ code uses inheritance without
dynamic dispatch or a
<a href="https://en.wikipedia.org/wiki/Virtual_method_table" target="_blank" rel="noopener noreferrer">vtable</a>. Instead, methods
are never overridden, and derived types only add data and methods. There are
some cases where this is done in C++ but would be done differently in Carbon:</p><ul><li>For implementation reuse without subtyping, Carbon code should use mixins or
composition. Carbon won&#x27;t support private inheritance.</li><li>Carbon will allow data members to have size zero, so the
<a href="https://en.cppreference.com/w/cpp/language/ebo" target="_blank" rel="noopener noreferrer">empty-base optimization</a> is
unnecessary.</li><li>For cases where the derived type does not add any data members, in Carbon
you can potentially use adapter types instead of inheritance.</li></ul><p>However, there are still some cases where non-virtual inheritance makes sense.
One is a parameterized type where a prefix of the data is the same independent
of the parameter. An example of this is containers with a
<a href="https://akrzemi1.wordpress.com/2014/04/14/common-optimizations/#sbo" target="_blank" rel="noopener noreferrer">small-buffer optimization</a>,
as described in the talk
<a href="https://www.youtube.com/watch?v=vElZc6zSIXM" target="_blank" rel="noopener noreferrer">CppCon 2016: Chandler Carruth &quot;High Performance Code 201: Hybrid Data Structures&quot;</a>.
By moving the data and methods that don&#x27;t depend on the buffer size to a base
class, we reduce the instantiation overhead for monomorphization. The base type
is also useful for reducing instantiation for consumers of the container, as
long as they only need to access methods defined in the base.</p><p>Another case for non-virtual inheritance is for different node types within a
data structure that have some data members in common. This is done in LLVM&#x27;s
map,
<a href="https://github.com/llvm-mirror/libcxx/blob/master/include/__tree" target="_blank" rel="noopener noreferrer">red-black tree</a>,
and list data structure types. In a linked list, the base type might have the
next and previous pointers, which is enough for a sentinel node, and there would
also be a derived type with the actual data member. The base type can define
operations like &quot;splice&quot; that only operate on the pointers not the data, and
this is in fact enforced by the type system. Only the derived node type needs to
be parameterized by the element type, saving on instantiation costs as before.</p><p>Many of the concerns around non-polymorphic inheritance are the same as for the
non-virtual methods of <a href="#polymorphic-types">polymorphic types</a>. Assignment and
destruction are examples of operations that need particular care to be sure they
are only done on values of the correct type, rather than through a subtyping
relationship. This means having some extrinsic way of knowing when it is safe to
downcast before performing one of those operations, or performing them on
pointers that were never upcast to the base type.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="interop-with-c-multiple-inheritance">Interop with C++ multiple inheritance<a class="hash-link" href="#interop-with-c-multiple-inheritance" title="Direct link to heading">​</a></h5><p>While Carbon won&#x27;t support all the C++ forms of multiple inheritance, Carbon
code will still need to interoperate with C++ code that does. Of particular
concern are the <code>std::iostream</code> family of types. Most uses of those types are
the input and output variations or could be migrated to use those variations,
not the harder bidirectional cases.</p><p>Much of the complexity of this interoperation could be alleviated by adopting
the restriction that Carbon code can&#x27;t directly access the fields of a virtual
base class. In the cases where such access is needed, the workaround is to
access them through C++ functions.</p><p>We do not expect idiomatic Carbon-only code to use multiple inheritance.
Extending this design to support interoperating with C++ types using multiple
inheritance is future work.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="mixins">Mixins<a class="hash-link" href="#mixins" title="Direct link to heading">​</a></h3><p>A <a href="https://en.wikipedia.org/wiki/Mixin" target="_blank" rel="noopener noreferrer">mixin</a> is a declaration of data,
methods, and interface implementations that can be added to another type, called
the &quot;main type&quot;. The methods of a mixin may also use data, methods, and
interface implementations provided by the main type. Mixins are designed around
implementation reuse rather than subtyping, and so don&#x27;t need to use a vtable.</p><p>A mixin might be an implementation detail of a <a href="#data-classes">data class</a>, or
<a href="#encapsulated-types">encapsulated type</a>. A mixin might partially implement an
<a href="#interface-as-base-class">interface as base class</a>.</p><p><strong>Examples:</strong>
<a href="https://www.boost.org/doc/libs/1_63_0/doc/html/intrusive.html" target="_blank" rel="noopener noreferrer">intrusive linked list</a>,
intrusive reference count</p><p>In both of these examples, the mixin needs the ability to convert between a
pointer to the mixin&#x27;s data (like a &quot;next&quot; pointer or reference count) and a
pointer to the containing object with the main type.</p><p>Mixins are expected in idiomatic Carbon-only code. Extending this design to
support mixins is future work.</p><p><strong>Background:</strong> Mixins are typically implemented using the
<a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" target="_blank" rel="noopener noreferrer">curiously recurring template pattern</a>
in C++, but other languages support them directly.</p><ul><li>In Dart, the mixin defines an interface that the destination type ends up
implementing, which restores a form of subtyping. See
<a href="https://medium.com/flutter-community/dart-what-are-mixins-3a72344011f3" target="_blank" rel="noopener noreferrer">Dart: What are mixins?</a>.</li><li>Swift is considering
<a href="https://github.com/Anton3/swift-evolution/blob/mixins/proposals/NNNN-mixins.md" target="_blank" rel="noopener noreferrer">a proposal to add mixin support</a>.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="background">Background<a class="hash-link" href="#background" title="Direct link to heading">​</a></h2><p>See how other languages tackle this problem:</p><ul><li><a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html" target="_blank" rel="noopener noreferrer">Swift</a><ul><li>has two different concepts: classes support
<a href="https://docs.swift.org/swift-book/LanguageGuide/Inheritance.html" target="_blank" rel="noopener noreferrer">inheritance</a>
and use
<a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" target="_blank" rel="noopener noreferrer">reference counting</a>
while structs have value semantics</li><li>may have
<a href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html" target="_blank" rel="noopener noreferrer">constructor functions called &quot;initializers&quot;</a>
and
<a href="https://docs.swift.org/swift-book/LanguageGuide/Deinitialization.html" target="_blank" rel="noopener noreferrer">destructors called &quot;deinitializers&quot;</a></li><li>supports
<a href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html" target="_blank" rel="noopener noreferrer">properties</a>,
including computed &amp; lazy properties</li><li>methods are const by default
<a href="https://docs.swift.org/swift-book/LanguageGuide/Methods.html#ID239" target="_blank" rel="noopener noreferrer">unless marked mutating</a></li><li>supports
<a href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html" target="_blank" rel="noopener noreferrer">extensions</a></li><li>has per-field
<a href="https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html" target="_blank" rel="noopener noreferrer">access control</a></li></ul></li><li><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html" target="_blank" rel="noopener noreferrer">Rust</a><ul><li>has no support for inheritance</li><li>has no special constructor functions, instead has literal syntax</li><li>has some convenience syntax for common cases:
<a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name" target="_blank" rel="noopener noreferrer">variable and field names matching</a>,
<a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax" target="_blank" rel="noopener noreferrer">updating a subset of fields</a></li><li><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types" target="_blank" rel="noopener noreferrer">can have unnamed fields</a></li><li><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#unit-like-structs-without-any-fields" target="_blank" rel="noopener noreferrer">supports structs with size 0</a></li></ul></li><li><a href="https://ziglang.org/documentation/0.6.0/#struct" target="_blank" rel="noopener noreferrer">Zig</a><ul><li><a href="https://ziglang.org/documentation/0.6.0/#packed-struct" target="_blank" rel="noopener noreferrer">explicitly mark structs as packed to manually control layout</a></li><li>has a struct literal syntax,
<a href="https://ziglang.org/documentation/0.6.0/#Anonymous-Struct-Literals" target="_blank" rel="noopener noreferrer">including for anonymous structs</a></li><li>no special constructor functions</li><li>supports fields with undefined values</li><li>supports structs with size 0</li><li>supports generics by way of memoized compile time functions accepting
and returning types</li><li><a href="https://ziglang.org/documentation/0.6.0/#toc-Default-Field-Values" target="_blank" rel="noopener noreferrer">supports default field values</a></li><li><a href="https://ziglang.org/#Small-simple-language" target="_blank" rel="noopener noreferrer">has no properties or operator overloading -- Zig does not like hidden control flow</a></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="members">Members<a class="hash-link" href="#members" title="Direct link to heading">​</a></h2><p>The members of a class are named, and are accessed with the <code>.</code> notation. For
example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var p: Point2D = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Data member access</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">p.x = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">p.y = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Method call</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Print(p.DistanceFromOrigin());</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><a href="/carbon-lang/design/tuples">Tuples</a> are used for cases where accessing the members positionally
is more appropriate.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="data-members-have-an-order">Data members have an order<a class="hash-link" href="#data-members-have-an-order" title="Direct link to heading">​</a></h3><p>The data members of a class, or <em>fields</em>, have an order that matches the order
they are declared in. This determines the order of those fields in memory, and
the order that the fields are destroyed when a value goes out of scope or is
deallocated.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="struct-types">Struct types<a class="hash-link" href="#struct-types" title="Direct link to heading">​</a></h2><p><em>Structural data classes</em>, or <em>struct types</em>, are convenient for defining
<a href="#data-classes">data classes</a> in an ad-hoc manner. They would commonly be used:</p><ul><li>as the return type of a function that returns multiple values and wants
those values to have names so a <a href="/carbon-lang/design/tuples">tuple</a> is inappropriate</li><li>as an initializer for other <code>class</code> variables or values</li><li>as a type parameter to a container</li></ul><p>Note that struct types are examples of <em>data class types</em> and are still classes.
The <a href="#nominal-data-classes">&quot;nominal data classes&quot; section</a> describes another
way to define a data class type. Also note that there is no <code>struct</code> keyword,
&quot;struct&quot; is just convenient shorthand terminology for a structural data class.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="literals">Literals<a class="hash-link" href="#literals" title="Direct link to heading">​</a></h3><p><em>Structural data class literals</em>, or <em>struct literals</em>, are written using this
syntax:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var kvpair: auto = {.key = &quot;the&quot;, .value = 27};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This produces a struct value with two fields:</p><ul><li>The first field is named &quot;<code>key</code>&quot; and has the value <code>&quot;the&quot;</code>. The type of the
field is set to the type of the value, and so is <code>String</code>.</li><li>The second field is named &quot;<code>value</code>&quot; and has the value <code>27</code>. The type of the
field is set to the type of the value, and so is <code>i32</code>.</li></ul><p>Note: A comma <code>,</code> may optionally be included after the last field:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var kvpair: auto = {.key = &quot;the&quot;, .value = 27,};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Open question:</strong> To keep the literal syntax from being ambiguous with compound
statements, Carbon will adopt some combination of:</p><ul><li>looking ahead after a <code>{</code> to see if it is followed by <code>.name</code>;</li><li>not allowing a struct literal at the beginning of a statement;</li><li>only allowing <code>{</code> to introduce a compound statement in contexts introduced
by a keyword where they are required, like requiring <code>{ ... }</code> around the
cases of an <code>if...else</code> statement.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="type-expression">Type expression<a class="hash-link" href="#type-expression" title="Direct link to heading">​</a></h3><p>The type of <code>kvpair</code> in the last example would be represented by this
expression:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{.key: String, .value: i32}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This syntax is intended to parallel the literal syntax, and so uses commas (<code>,</code>)
to separate fields instead of a semicolon (<code>;</code>) terminator. This choice also
reflects the expected use inline in function signature declarations.</p><p>Struct types may only have data members, so the type declaration is just a list
of field names and types. The result of a struct type expression is an immutable
compile-time type value.</p><p>Note: Like with struct literal expressions, a comma <code>,</code> may optionally be
included after the last field:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{.key: String, .value: i32,}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Also note that <code>{}</code> represents both the empty struct literal and its type.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="assignment-and-initialization">Assignment and initialization<a class="hash-link" href="#assignment-and-initialization" title="Direct link to heading">​</a></h3><p>When initializing or assigning a variable with a data class such as a struct
type to a struct value on the right hand side, the order of the fields does not
have to match, just the names.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var different_order: {.x: i32, .y: i32} = {.y = 2, .x = 3};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(different_order.x == 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(different_order.y == 2);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Initialization and assignment occur field-by-field. The order of fields is
determined from the target on the left side of the <code>=</code>. This rule matches what
we expect for classes with encapsulation more generally.</p><p><strong>Open question:</strong> What operations and in what order happen for assignment and
initialization?</p><ul><li>Is assignment just destruction followed by initialization? Is that
destruction completed for the whole object before initializing, or is it
interleaved field-by-field?</li><li>When initializing to a literal value, is a temporary containing the literal
value constructed first or are the fields initialized directly? The latter
approach supports types that can&#x27;t be moved or copied, such as mutex.</li><li>Perhaps some operations are <em>not</em> ordered with respect to each other?</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="operations-performed-field-wise">Operations performed field-wise<a class="hash-link" href="#operations-performed-field-wise" title="Direct link to heading">​</a></h3><p>Generally speaking, the operations that are available on a data class value,
such as a value with a struct type, are dependent on those operations being
available for all the types of the fields.</p><p>For example, two values of the same data class type may be compared for equality
or inequality if equality is supported for every member of the type:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var p: auto = {.x = 2, .y = 3};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(p == {.x = 2, .y = 3});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(p != {.x = 2, .y = 4});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert({.x = 2, .y = 4} != {.x = 5, .y = 3});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Equality and inequality comparisons are also allowed between different data
class types when:</p><ul><li>At least one is a struct type.</li><li>They have the same set of field names, though the order may be different.</li><li>Equality comparison is defined between the pairs of member types with the
same field names.</li></ul><p>For example, since
<a href="/carbon-lang/proposals/p0702.md#built-in-comparisons-and-implicit-conversions">comparison between <code>i32</code> and <code>u32</code> is defined</a>,
equality comparison between values of types <code>{.x: i32, .y: i32}</code> and
<code>{.y: u32, .x: u32}</code> is as well. Equality and inequality comparisons compare
fields using the field order of the left-hand operand and stop once the outcome
of the comparison is determined. However, the comparison order and
short-circuiting are generally expected to affect only the performance
characteristics of the comparison and not its meaning.</p><p>Ordering comparisons, such as <code>&lt;</code> and <code>&lt;=</code>, use the order of the fields to do a
<a href="https://en.wikipedia.org/wiki/Lexicographic_order" target="_blank" rel="noopener noreferrer">lexicographical comparison</a>.
The argument types must have a matching order of the field names. Otherwise, the
restrictions on ordering comparisons between different data class types are
analogous to equality comparisons:</p><ul><li>At least one is a struct type.</li><li>Ordering comparison is defined between the pairs of member types with the
same field names.</li></ul><p>Implicit conversion from a struct type to a data class type is allowed when the
set of field names is the same and implicit conversion is defined between the
pairs of member types with the same field names. So calling a function
effectively performs an assignment from each of the caller&#x27;s arguments to the
function&#x27;s parameters, and will be valid when those assignments are all valid.</p><p>A data class has an unformed state if all its members do. Treatment of unformed
state follows proposal
<a href="https://github.com/carbon-language/carbon-lang/pull/257" target="_blank" rel="noopener noreferrer">#257</a>.</p><p>Destruction is performed field-wise in reverse order.</p><p>Extending user-defined operations on the fields to an operation on an entire
data class is <a href="#interfaces-implemented-for-data-classes">future work</a>.</p><p><strong>References:</strong> The rules for assignment, comparison, and implicit conversion
for argument passing were decided in
<a href="https://github.com/carbon-language/carbon-lang/issues/710" target="_blank" rel="noopener noreferrer">question-for-leads issue #710</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="nominal-class-types">Nominal class types<a class="hash-link" href="#nominal-class-types" title="Direct link to heading">​</a></h2><p>The declarations for nominal class types will have:</p><ul><li>an optional <code>abstract</code> or <code>base</code> prefix</li><li><code>class</code> introducer</li><li>the name of the class</li><li>an optional <code>extends</code> followed by the name of the immediate base class</li><li><code>{</code>, an open curly brace</li><li>a sequence of declarations</li><li><code>}</code>, a close curly brace</li></ul><p>Declarations should generally match declarations that can be declared in other
contexts, for example variable declarations with <code>var</code> will define
<a href="https://en.wikipedia.org/wiki/Instance_variable" target="_blank" rel="noopener noreferrer">instance variables</a>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class TextLabel {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var text: String = &quot;default&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The main difference here is that <code>&quot;default&quot;</code> is a default instead of an
initializer, and will be ignored if another value is supplied for that field
when constructing a value. Defaults must be constants whose value can be
determined at compile time.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="forward-declaration">Forward declaration<a class="hash-link" href="#forward-declaration" title="Direct link to heading">​</a></h3><p>To support circular references between class types, we allow
<a href="https://en.wikipedia.org/wiki/Forward_declaration" target="_blank" rel="noopener noreferrer">forward declaration</a> of
types. Forward declarations end with semicolon <code>;</code> after the name of the class,
instead of any <code>extends</code> clause and the block of declarations in curly braces
<code>{</code>...<code>}</code>. A type that is forward declared is considered incomplete until the
end of a definition with the same name.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Forward declaration of `GraphNode`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class GraphNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class GraphEdge {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var head: GraphNode*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var tail: GraphNode*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class GraphNode {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var edges: Vector(GraphEdge*);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `GraphNode` is first complete here.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Open question:</strong> What is specifically allowed and forbidden with an incomplete
type has not yet been decided.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="self">Self<a class="hash-link" href="#self" title="Direct link to heading">​</a></h3><p>A <code>class</code> definition may provisionally include references to its own name in
limited ways. These limitations arise from the type not being complete until the
end of its definition is reached.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class IntListNode {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var data: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var next: IntListNode*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>An equivalent definition of <code>IntListNode</code>, since <code>Self</code> is an alias for the
current type, is:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class IntListNode {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var data: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var next: Self*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>Self</code> refers to the innermost type declaration:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class IntList {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  class IntListNode {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var data: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var next: Self*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var first: IntListNode*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="construction">Construction<a class="hash-link" href="#construction" title="Direct link to heading">​</a></h3><p>Any function with access to all the data fields of a class can construct one by
converting a <a href="#struct-types">struct value</a> to the class type:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var tl1: TextLabel = {.x = 1, .y = 2};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var tl2: auto = {.x = 1, .y = 2} as TextLabel;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(tl1.x == tl2.x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn ReturnsATextLabel() -&gt; TextLabel {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return {.x = 1, .y = 2};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var tl3: TextLabel = ReturnsATextLabel();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn AcceptsATextLabel(tl: TextLabel) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return tl.x + tl.y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(AcceptsATextLabel({.x = 2, .y = 4}) == 6);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that a nominal class, unlike a <a href="#type-expression">struct type</a>, can define
default values for fields, and so may be initialized with a
<a href="#literals">struct value</a> that omits some or all of those fields.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="assignment">Assignment<a class="hash-link" href="#assignment" title="Direct link to heading">​</a></h4><p>Assignment to a struct value is also allowed in a function with access to all
the data fields of a class. Assignment always overwrites all of the field
members.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var tl: TextLabel = {.x = 1, .y = 2};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(tl.text == &quot;default&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ✅ Allowed: assigns all fields</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tl = {.x = 3, .y = 4, .text = &quot;new&quot;};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ✅ Allowed: This statement is evaluated in two steps:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 1. {.x = 5, .y = 6} is converted into a new TextLabel value,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    using default for field `text`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2. tl is assigned to a TextLabel, which has values for all</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    fields.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tl = {.x = 5, .y = 6};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(tl.text == &quot;default&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Open question:</strong> This behavior might be surprising because there is an
ambiguity about whether to use the default value or the previous value for a
field. We could require all fields to be specified when assigning, and only use
field defaults when initializing a new value.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Forbidden: should tl.text == &quot;default&quot; or &quot;new&quot;?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tl = {.x = 5, .y = 6};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="member-functions">Member functions<a class="hash-link" href="#member-functions" title="Direct link to heading">​</a></h3><p>Member functions can either be class functions or methods. Class functions are
members of the type, while methods can only be called on instances.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="class-functions">Class functions<a class="hash-link" href="#class-functions" title="Direct link to heading">​</a></h4><p>A class function is like a
<a href="https://en.wikipedia.org/wiki/Static_(keyword)#Static_method" target="_blank" rel="noopener noreferrer">C++ static member function or method</a>,
and is declared like a function at file scope. The declaration can include a
definition of the function body, or that definition can be provided out of line
after the class definition is finished. A common use is for constructor
functions.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Origin() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.x = 0, .y = 0};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn CreateCentered() -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn Point.CreateCentered() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return {.x = ScreenWidth() / 2, .y = ScreenHeight() / 2};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Class functions are members of the type, and may be accessed as using dot <code>.</code>
member access either the type or any instance.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var p1: Point = Point.Origin();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var p2: Point = p1.CreateCentered();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="methods">Methods<a class="hash-link" href="#methods" title="Direct link to heading">​</a></h4><p><a href="https://en.wikipedia.org/wiki/Method_(computer_programming)" target="_blank" rel="noopener noreferrer">Method</a>
declarations are distinguished from <a href="#class-functions">class function</a>
declarations by having a <code>me</code> parameter in square brackets <code>[</code>...<code>]</code> before the
explicit parameter list in parens <code>(</code>...<code>)</code>. There is no implicit member access
in methods, so inside the method body members are accessed through the <code>me</code>
parameter. Methods may be written lexically inline or after the class
declaration.</p><div class="language-carbon codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-carbon codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Circle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Diameter[me: Self]() -&gt; f32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return me.radius * 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Expand[addr me: Self*](distance: f32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var center: Point;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var radius: f32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn Circle.Expand[addr me: Self*](distance: f32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  me-&gt;radius += distance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var c: Circle = {.center = Point.Origin(), .radius = 1.5 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(Math.Abs(c.Diameter() - 3.0) &lt; 0.001);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c.Expand(0.5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(Math.Abs(c.Diameter() - 4.0) &lt; 0.001);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>Methods are called using using the dot <code>.</code> member syntax, <code>c.Diameter()</code> and
<code>c.Expand(</code>...<code>)</code>.</li><li><code>Diameter</code> computes and returns the diameter of the circle without modifying
the <code>Circle</code> instance. This is signified using <code>[me: Self]</code> in the method
declaration.</li><li><code>c.Expand(</code>...<code>)</code> does modify the value of <code>c</code>. This is signified using
<code>[addr me: Self*]</code> in the method declaration.</li></ul><p>The pattern &#x27;<code>addr</code> <em>patt</em>&#x27; means &quot;first take the address of the argument, which
must be an
<a href="https://en.wikipedia.org/wiki/Value_(computer_science)#lrvalue" target="_blank" rel="noopener noreferrer">l-value</a>, and
then match pattern <em>patt</em> against it&quot;.</p><p>If the method declaration also includes
<a href="/carbon-lang/docs/design/generics/overview.md#deduced-parameters">deduced generic parameters</a>,
the <code>me</code> parameter must be in the same list in square brackets <code>[</code>...<code>]</code>. The
<code>me</code> parameter may appear in any position in that list, as long as it appears
after any names needed to describe its type.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="name-lookup-in-member-function-definitions">Name lookup in member function definitions<a class="hash-link" href="#name-lookup-in-member-function-definitions" title="Direct link to heading">​</a></h4><p>When defining a member function lexically inline, we delay type checking of the
function body until the definition of the current type is complete. This means
that name lookup <em>for members of objects</em> is also delayed. That means that you
can reference <code>me.F()</code> in a lexically inline method definition even before the
declaration of <code>F</code> in that class definition. However, other names still need to
be declared before they are used. This includes unqualified names, names within
namespaces, and names <em>for members of types</em>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Distance[me: Self]() -&gt; f32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ✅ Allowed: `x` and `y` are names for members of an object,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // and so lookup is delayed until `type_of(me) == Self` is complete.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Math.Sqrt(me.x * me.x + me.y * me.y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn CreatePolarInvalid(r: f32, theta: f32) -&gt; Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ❌ Forbidden: unqualified name used before declaration.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Create(r * Math.Cos(theta), r * Math.Sin(theta));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn CreatePolarValid1(r: f32, theta: f32) -&gt; Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ❌ Forbidden: `Create` is not yet declared.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Point.Create(r * Math.Cos(theta), r * Math.Sin(theta));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn CreatePolarValid2(r: f32, theta: f32) -&gt; Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ❌ Forbidden: `Create` is not yet declared.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Self.Create(r * Math.Cos(theta), r * Math.Sin(theta));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Create(x: f32, y: f32) -&gt; Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ✅ Allowed: checking that conversion of `{.x: f32, .y: f32}`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // to `Point` is delayed until `Point` is complete.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.x = x, .y = y};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn CreateXEqualsY(xy: f32) -&gt; Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ✅ Allowed: `Create` is declared earlier.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Create(xy, xy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn CreateXAxis(x: f32) -&gt; Point;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Angle[me: Self]() -&gt; f32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: f32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: f32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn Point.CreateXAxis(x: f32) -&gt; Point;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `Point` type is complete.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Members of `Point` like `Create` are in scope.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Create(x, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn Point.Angle[me: Self]() -&gt; f32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `Point` type is complete.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Function is checked immediately.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Math.ATan2(me.y, me.x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Note:</strong> The details of name lookup are still being decided in issue
<a href="https://github.com/carbon-language/carbon-lang/issues/472" target="_blank" rel="noopener noreferrer">#472: Open question: Calling functions defined later in the same file</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nominal-data-classes">Nominal data classes<a class="hash-link" href="#nominal-data-classes" title="Direct link to heading">​</a></h3><p>We will mark <a href="#data-classes">data classes</a> with an <code>impl as Data {}</code> line.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class TextLabel {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var text: String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // This line makes `TextLabel` a data class, which defines</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // a number of operations field-wise.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Data {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The fields of data classes must all be public. That line will add
<a href="#operations-performed-field-wise">field-wise implementations and operations of all interfaces that a struct with the same fields would get by default</a>.</p><p>The word <code>Data</code> here refers to an empty interface in the Carbon prologue. That
interface would then be part of our
<a href="#interfaces-implemented-for-data-classes">strategy for defining how other interfaces are implemented for data classes</a>.</p><p><strong>References:</strong> Rationale for this approach is given in proposal
<a href="/carbon-lang/proposals/p0722.md#nominal-data-class">#722</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="member-type">Member type<a class="hash-link" href="#member-type" title="Direct link to heading">​</a></h3><p>Additional types may be defined in the scope of a class definition.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class StringCounts {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  class Node {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var key: String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var count: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var counts: Vector(Node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The inner type is a member of the type, and is given the name
<code>StringCounts.Node</code>. This case is called a <em>member class</em> since the type is a
class, but other kinds of type declarations, like choice types, are allowed.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="let">Let<a class="hash-link" href="#let" title="Direct link to heading">​</a></h3><p>Other type constants can be defined using a <code>let</code> declaration:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Pi:! f32 = 3.141592653589793;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let IndexType:! Type = i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The <code>:!</code> indicates that this is defining a compile-time constant, and so does
not affect the storage of instances of that class.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="alias">Alias<a class="hash-link" href="#alias" title="Direct link to heading">​</a></h3><p>You may declare aliases of the names of class members. This is to allow them to
be renamed in multiple steps or support alternate names.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class StringPair {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var key: String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var value: String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias first = key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias second = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var sp1: StringPair = {.key = &quot;K&quot;, .value = &quot;1&quot;};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var sp2: StringPair = {.first = &quot;K&quot;, .second = &quot;2&quot;};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(sp1.first == sp2.key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(&amp;sp1.first == &amp;sp1.key);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Future work:</strong> This needs to be connected to the broader design of aliases,
once that lands.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="inheritance">Inheritance<a class="hash-link" href="#inheritance" title="Direct link to heading">​</a></h3><p>Carbon supports
<a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" target="_blank" rel="noopener noreferrer">inheritance</a>
using a
<a href="https://en.wikipedia.org/wiki/Class_(computer_programming)#Hierarchical" target="_blank" rel="noopener noreferrer">class hierarchy</a>,
on an opt-in basis. Classes by default are
<a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)#Non-subclassable_classes" target="_blank" rel="noopener noreferrer"><em>final</em></a>,
which means they may not be extended. To declare a class as allowing extension,
use either the <code>base class</code> or <code>abstract class</code> introducer:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">base class MyBaseClass { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A <em>base class</em> may be <em>extended</em> to get a <em>derived class</em>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">base class MiddleDerived extends MyBaseClass { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class FinalDerived extends MiddleDerived { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Forbidden: class Illegal extends FinalDerived { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>An <em><a href="https://en.wikipedia.org/wiki/Abstract_type" target="_blank" rel="noopener noreferrer">abstract class</a></em> or <em>abstract
base class</em> is a base class that may not be instantiated.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">abstract class MyAbstractClass { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Forbidden: var a: MyAbstractClass = ...;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Future work:</strong> For now, the Carbon design only supports single inheritance. In
the future, Carbon will support multiple inheritance with limitations on all
base classes except the one listed first.</p><p><strong>Terminology:</strong> We say <code>MiddleDerived</code> and <code>FinalDerived</code> are <em>derived
classes</em>, transitively extending or <em>derived from</em> <code>MyBaseClass</code>. Similarly
<code>FinalDerived</code> is derived from or extends <code>MiddleDerived</code>. <code>MiddleDerived</code> is
<code>FinalDerived</code>&#x27;s <em>immediate base class</em>, and both <code>MiddleDerived</code> and
<code>MyBaseClass</code> are base classes of <code>FinalDerived</code>. Base classes that are not
abstract are called <em>extensible classes</em>.</p><p>A derived class has all the members of the class it extends, including data
members and methods, though it may not be able to access them if they were
declared <code>private</code>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="virtual-methods">Virtual methods<a class="hash-link" href="#virtual-methods" title="Direct link to heading">​</a></h4><p>A base class may define
<a href="https://en.wikipedia.org/wiki/Virtual_function" target="_blank" rel="noopener noreferrer">virtual methods</a>. These are
methods whose implementation may be overridden in a derived class.</p><p>Only methods defined in the scope of the class definition may be virtual, not
any defined in
<a href="/carbon-lang/docs/design/generics/details.md#external-impl">external interface impls</a>.
Interface methods may be implemented using virtual methods when the
<a href="/carbon-lang/docs/design/generics/details.md#implementing-interfaces">impl is internal</a>,
and calls to those methods by way of the interface will do virtual dispatch just
like a direct call to the method does.</p><p><a href="#class-functions">Class functions</a> may not be declared virtual.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="virtual-override-keywords">Virtual override keywords<a class="hash-link" href="#virtual-override-keywords" title="Direct link to heading">​</a></h5><p>A method is declared as virtual by using a <em>virtual override keyword</em> in its
declaration before <code>fn</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">base class MyBaseClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  virtual fn Overridable[me: Self]() -&gt; i32 { return 7; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This matches C++, and makes it relatively easy for authors of derived classes to
find the functions that can be overridden.</p><p>If no keyword is specified, the default for methods is that they are
<em>non-virtual</em>. This means:</p><ul><li>they can&#x27;t override methods in bases of this class;</li><li>they can&#x27;t be overridden in derived classes; and</li><li>they have an implementation in the current class, and that implementation
must work for all derived classes.</li></ul><p>There are three virtual override keywords:</p><ul><li><code>virtual</code> - This marks a method as not present in bases of this class and
having an implementation in this class. That implementation may be
overridden in derived classes.</li><li><code>abstract</code> - This marks a method that must be overridden in a derived class
since it has no implementation in this class. This is short for &quot;abstract
virtual&quot; but is called
<a href="https://en.wikipedia.org/wiki/Virtual_function#Abstract_classes_and_pure_virtual_functions" target="_blank" rel="noopener noreferrer">&quot;pure virtual&quot; in C++</a>.
Only abstract classes may have unimplemented abstract methods.</li><li><code>impl</code> - This marks a method that overrides a method marked <code>virtual</code> or
<code>abstract</code> in the base class with an implementation specific to -- and
defined within -- this class. The method is still virtual and may be
overridden again in subsequent derived classes if this is a base class. See
<a href="https://en.wikipedia.org/wiki/Method_overriding" target="_blank" rel="noopener noreferrer">method overriding in Wikipedia</a>.
Requiring a keyword when overriding allows the compiler to diagnose when the
derived class accidentally uses the wrong signature or spelling and so
doesn&#x27;t match the base class. We intentionally use the same keyword here as
for implementing interfaces, to emphasize that they are similar operations.</li></ul><table><thead><tr><th>Keyword on<br>method in <code>C</code></th><th>Allowed in<br><code>abstract class C</code></th><th>Allowed in<br><code>base class C</code></th><th>Allowed in<br>final <code>class C</code></th><th>in <code>B</code> where<br><code>C extends B</code></th><th>in <code>D</code> where<br><code>D extends C</code></th></tr></thead><tbody><tr><td><code>virtual</code></td><td>✅</td><td>✅</td><td>❌</td><td><em>not present</em></td><td><code>abstract</code><br><code>impl</code><br><em>not mentioned</em></td></tr><tr><td><code>abstract</code></td><td>✅</td><td>❌</td><td>❌</td><td><em>not present</em><br><code>virtual</code><br><code>abstract</code><br><code>impl</code></td><td><code>abstract</code><br><code>impl</code><br><em>may not be<br>mentioned if<br><code>D</code> is not final</em></td></tr><tr><td><code>impl</code></td><td>✅</td><td>✅</td><td>✅</td><td><code>virtual</code><br><code>abstract</code><br><code>impl</code></td><td><code>abstract</code><br><code>impl</code></td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_LWe7" id="subtyping">Subtyping<a class="hash-link" href="#subtyping" title="Direct link to heading">​</a></h4><p>A pointer to a base class, like <code>MyBaseClass*</code> is actually considered to be a
pointer to that type or any derived class, like <code>MiddleDerived</code> or
<code>FinalDerived</code>. This means that a <code>FinalDerived*</code> value may be implicitly cast
to type <code>MiddleDerived*</code> or <code>MyBaseClass*</code>.</p><p>This is accomplished by making the data layout of a type extending <code>MyBaseClass</code>
have <code>MyBaseClass</code> as a prefix. In addition, the first class in the inheritance
chain with a virtual method will include a virtual pointer, or <em>vptr</em>, pointing
to a <a href="https://en.wikipedia.org/wiki/Virtual_method_table" target="_blank" rel="noopener noreferrer">virtual method table</a>,
or <em>vtable</em>. Any calls to virtual methods will perform
<a href="https://en.wikipedia.org/wiki/Dynamic_dispatch" target="_blank" rel="noopener noreferrer">dynamic dispatch</a> by calling
the method using the function pointer in the vtable, to get the overridden
implementation from the most derived class that implements the method.</p><p>Since a final class may not be extended, the compiler can bypass the vtable and
use <a href="https://en.wikipedia.org/wiki/Static_dispatch" target="_blank" rel="noopener noreferrer">static dispatch</a>. In
general, you can use a combination of an abstract base class and a final class
instead of an extensible class if you need to distinguish between exactly a type
and possibly a subtype.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">base class Extensible { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Can be replaced by:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">abstract class ExtensibleBase { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class ExactlyExtensible extends ExtensibleBase { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="constructors">Constructors<a class="hash-link" href="#constructors" title="Direct link to heading">​</a></h4><p>Like for classes without inheritance, constructors for a derived class are
ordinary functions that return an instance of the derived class. Generally
constructor functions should return the constructed value without copying, as in
proposal
<a href="https://github.com/carbon-language/carbon-lang/pull/257" target="_blank" rel="noopener noreferrer">#257: Initialization of memory and variables</a>.
This means either
<a href="/carbon-lang/proposals/p0257.md#function-returns-and-initialization">creating the object in the return statement itself</a>,
or in
<a href="/carbon-lang/proposals/p0257.md#declared-returned-variable">a <code>returned var</code> declaration</a>.
As before, instances can be created using by casting a struct value into the
class type, this time with a <code>.base</code> member to initialize the members of the
immediate base type.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyDerivedType extends MyBaseType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Create() -&gt; MyDerivedType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.base = MyBaseType.Create(), .derived_field = ...};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>There are two cases that aren&#x27;t well supported with this pattern:</p><ul><li>Users cannot create a value of an abstract class, which is necessary when it
has private fields or otherwise requires initialization.</li><li>Users may want to reduce the chance of mistakes from calling a method on a
partially constructed object. Of particular concern is calling a virtual
method prior to forming the derived class and so it uses the base class
implementation.</li></ul><p>While expected to be relatively rarely needed, we will address both of these
concerns with a specialized type just used during construction of base classes,
called the partial facet type for the class.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="partial-facet">Partial facet<a class="hash-link" href="#partial-facet" title="Direct link to heading">​</a></h5><p>The partial facet for a base class type like <code>MyBaseType</code> is written
<code>partial MyBaseType</code>.</p><ul><li>Only methods that take the partial facet type may be called on the partial
facet type, so methods have to opt in to being called on an object that
isn&#x27;t fully constructed.</li><li>No virtual methods may take the partial facet type, so there is no way to
transitively call a virtual method on an object that isn&#x27;t fully
constructed.</li><li><code>partial MyBaseClass</code> and <code>MyBaseClass</code> have the same fields in the same
order with the same data layout. The only difference is that
<code>partial MyBaseClass</code> doesn&#x27;t use (look into) its hidden vptr slot. To
reliably catch any bugs where virtual function calls occur in this state,
both fast and hardened release builds will initialize the hidden vptr slot
to a null pointer. Debug builds will initialize it to an alternate vtable
whose functions will abort the program with a clear diagnostic.</li><li>Since <code>partial MyBaseClass</code> has the same data layout but only uses a subset,
there is a subtyping relationship between these types. A <code>MyBaseClass</code> value
is a <code>partial MyBaseClass</code> value, but not the other way around. So you can
cast <code>MyBaseClass*</code> to <code>partial MyBaseClass*</code>, but the other direction is
not safe.</li><li>When <code>MyBaseClass</code> may be instantiated, there is a conversion from
<code>partial MyBaseClass</code> to <code>MyBaseClass</code>. It changes the value by filling in
the hidden vptr slot. If <code>MyBaseClass</code> is abstract, then attempting that
conversion is an error.</li><li><code>partial MyBaseClass</code> is considered final, even if <code>MyBaseClass</code> is not.
This is despite the fact that from a data layout perspective,
<code>partial MyDerivedClass</code> will have <code>partial MyBaseClass</code> as a prefix if
<code>MyDerivedClass</code> extends <code>MyBaseClass</code>. The type <code>partial MyBaseClass</code>
specifically means &quot;exactly this and no more.&quot; This means we don&#x27;t need to
look at the hidden vptr slot, and we can instantiate it even if it doesn&#x27;t
have a virtual <a href="#destructors">destructor</a>.</li><li>The keyword <code>partial</code> may only be applied to a base class. For final
classes, there is no need for a second type.</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="usage">Usage<a class="hash-link" href="#usage" title="Direct link to heading">​</a></h5><p>The general pattern is that base classes can define constructors returning the
partial facet type.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">base class MyBaseClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Create() -&gt; partial Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.base_field_1 = ..., .base_field_2 = ...};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Extensible classes can be instantiated even from a partial facet value:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var mbc: MyBaseClass = MyBaseClass.Create();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The conversion from <code>partial MyBaseClass</code> to <code>MyBaseClass</code> only fills in the
vptr value and can be done in place. After the conversion, all public methods
may be called, including virtual methods.</p><p>The partial facet is required for abstract classes, since otherwise they may not
be instantiated. Constructor functions for abstract classes should be marked
<a href="#protected-access">protected</a> so they may only be accessed in derived classes.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">abstract class MyAbstractClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  protected fn Create() -&gt; partial Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.base_field_1 = ..., .base_field_2 = ...};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Error: can&#x27;t instantiate abstract class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var abc: MyAbstractClass = ...;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If a base class wants to store a pointer to itself somewhere in the constructor
function, there are two choices:</p><ul><li><p>An extensible class could use the plain type instead of the partial facet.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">base class MyBaseClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Create() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    returned var result: Self = {...};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    StoreMyPointerSomewhere(&amp;result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return var;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>The other choice is to explicitly cast the type of its address. This pointer
should not be used to call any virtual method until the object is finished
being constructed, since the vptr will be null.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">abstract class MyAbstractClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  protected fn Create() -&gt; partial Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    returned var result: partial Self = {...};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Careful! Pointer to object that isn&#x27;t fully constructed!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    StoreMyPointerSomewhere(&amp;result as Self*);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return var;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ul><p>The constructor for a derived class may construct values from a partial facet of
the class&#x27; immediate base type or the full type:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">abstract class MyAbstractClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  protected fn Create() -&gt; partial Self { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Base class returns a partial type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">base class Derived extends MyAbstractClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  protected fn Create() -&gt; partial Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.base = MyAbstractClass.Create(), .derived_field = ...};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">base class MyBaseClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Create() -&gt; Self { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Base class returns a full type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">base class ExtensibleDerived extends MyBaseClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Create() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.base = MyBaseClass.Create(), .derived_field = ...};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>And final classes will return a type that does not use the partial facet:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class FinalDerived extends MiddleDerived {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Create() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.base = MiddleDerived.Create(), .derived_field = ...};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Observe that the vptr is only assigned twice in release builds if you use
partial facets:</p><ul><li>The first class value created, by the factory function creating the base of
the class hierarchy, initialized the vptr field to nullptr. Every derived
type transitively created from that value will leave it alone.</li><li>Only when the value has its most-derived class and is converted from the
partial facet type to its final type is the vptr field set to its final
value.</li></ul><p>In the case that the base class can be instantiated, tooling could optionally
recommend that functions returning <code>Self</code> that are used to initialize a derived
class be changed to return <code>partial Self</code> instead. However, the consequences of
returning <code>Self</code> instead of <code>partial Self</code> when the value will be used to
initialize a derived class are fairly minor:</p><ul><li>The vptr field will be assigned more than necessary.</li><li>The types won&#x27;t protect against calling methods on a value while it is being
constructed, much like the situation in C++ currently.</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="assignment-with-inheritance">Assignment with inheritance<a class="hash-link" href="#assignment-with-inheritance" title="Direct link to heading">​</a></h4><p>Since the assignment operator method should not be virtual, it is only safe to
implement it for final types. However, following the
<a href="/carbon-lang/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write">maxim that Carbon should &quot;focus on encouraging appropriate usage of features rather than restricting misuse&quot;</a>,
we allow users to also implement assignment on extensible classes, even though
it can lead to <a href="https://en.wikipedia.org/wiki/Object_slicing" target="_blank" rel="noopener noreferrer">slicing</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="destructors">Destructors<a class="hash-link" href="#destructors" title="Direct link to heading">​</a></h3><p>Every non-abstract type is <em>destructible</em>, meaning has a defined destructor
function called when the lifetime of a value of that type ends, such as when a
variable goes out of scope. The destructor for a class may be customized using
the <code>destructor</code> keyword:</p><div class="language-carbon codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-carbon codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  destructor [me: Self] { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>or:</p><div class="language-carbon codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-carbon codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Can modify `me` in the body.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  destructor [addr me: Self*] { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If a class has no <code>destructor</code> declaration, it gets the default destructor,
which is equivalent to <code>destructor [me: Self] { }</code>.</p><p>The destructor for a class is run before the destructors of its data members.
The data members are destroyed in reverse order of declaration. Derived classes
are destroyed before their base classes, so the order of operations is:</p><ul><li>derived class&#x27; destructor runs,</li><li>the data members of the derived class are destroyed, in reverse order of
declaration,</li><li>the immediate base class&#x27; destructor runs,</li><li>the data members of the immediate base class are destroyed, in reverse order
of declaration,</li><li>and so on.</li></ul><p>Destructors may be declared in class scope and then defined out-of-line:</p><div class="language-carbon codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-carbon codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  destructor [addr me: Self*];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">destructor MyClass [addr me: Self*] { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It is illegal to delete an instance of a derived class through a pointer to one
of its base classes unless it has a
<a href="https://en.wikipedia.org/wiki/Virtual_function#Virtual_destructors" target="_blank" rel="noopener noreferrer">virtual destructor</a>.
An abstract or base class&#x27; destructor may be declared virtual using the
<code>virtual</code> introducer, in which case any derived class destructor declaration
must be <code>impl</code>:</p><div class="language-carbon codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-carbon codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">base class MyBaseClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  virtual destructor [addr me: Self*] { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class MyDerivedClass extends MyBaseClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl destructor [addr me: Self*] { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The properties of a type, whether type is abstract, base, or final, and whether
the destructor is virtual or non-virtual, determines which
<a href="/carbon-lang/docs/design/generics/terminology.md#type-of-type">type-of-types</a> it satisfies.</p><ul><li>Non-abstract classes are <code>Concrete</code>. This means you can create local and
member variables of this type. <code>Concrete</code> types have destructors that are
called when the local variable goes out of scope or the containing object of
the member variable is destroyed.</li><li>Final classes and classes with a virtual destructor are <code>Deletable</code>. These
may be safely deleted through a pointer.</li><li>Classes that are <code>Concrete</code>, <code>Deletable</code>, or both are <code>Destructible</code>. These
are types that may be deleted through a pointer, but it might not be safe.
The concerning situation is when you have a pointer to a base class without
a virtual destructor. It is unsafe to delete that pointer when it is
actually pointing to a derived class.</li></ul><p><strong>Note:</strong> The names <code>Deletable</code> and <code>Destructible</code> are
<a href="/carbon-lang/proposals/p1154.md#type-of-type-naming"><strong>placeholders</strong></a> since they do not
conform to the decision on
<a href="https://github.com/carbon-language/carbon-lang/issues/1058" target="_blank" rel="noopener noreferrer">question-for-leads issue #1058: &quot;How should interfaces for core functionality be named?&quot;</a>.</p><table><thead><tr><th>Class</th><th>Destructor</th><th><code>Concrete</code></th><th><code>Deletable</code></th><th><code>Destructible</code></th></tr></thead><tbody><tr><td>abstract</td><td>non-virtual</td><td>no</td><td>no</td><td>no</td></tr><tr><td>abstract</td><td>virtual</td><td>no</td><td>yes</td><td>yes</td></tr><tr><td>base</td><td>non-virtual</td><td>yes</td><td>no</td><td>yes</td></tr><tr><td>base</td><td>virtual</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>final</td><td>any</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><p>The compiler automatically determines which of these
<a href="/carbon-lang/docs/design/generics/terminology.md#type-of-type">type-of-types</a> a given type
satisfies. It is illegal to directly implement <code>Concrete</code>, <code>Deletable</code>, or
<code>Destructible</code> directly. For more about these constraints, see
<a href="/carbon-lang/docs/design/generics/details.md#destructor-constraints">&quot;destructor constraints&quot; in the detailed generics design</a>.</p><p>A pointer to <code>Deletable</code> types may be passed to the <code>Delete</code> method of the
<code>Allocator</code> <a href="/carbon-lang/docs/design/generics/terminology.md#interface">interface</a>. To
deallocate a pointer to a base class without a virtual destructor, which may
only be done when it is not actually pointing to a value with a derived type,
call the <code>UnsafeDelete</code> method instead. Note that you may not call
<code>UnsafeDelete</code> on abstract types without virtual destructors, it requires
<code>Destructible</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Allocator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Delete[T:! Deletable, addr me: Self*](p: T*);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn UnsafeDelete[T:! Destructible, addr me: Self*](p: T*);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To pass a pointer to a base class without a virtual destructor to a generic
function expecting a <code>Deletable</code> type, use the <code>UnsafeAllowDelete</code>
<a href="/carbon-lang/docs/design/generics/details.md#adapting-types">type adapter</a>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">adapter UnsafeAllowDelete(T:! Concrete) extends T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Deletable {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Example usage:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn RequiresDeletable[T:! Deletable](p: T*);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var x: MyExtensible;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RequiresDeletable(&amp;x as UnsafeAllowDelete(MyExtensible)*);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If a virtual method is transitively called from inside a destructor, the
implementation from the current class is used, not any overrides from derived
classes. It will abort the execution of the program if that method is abstract
and not implemented in the current class.</p><p><strong>Future work:</strong> Allow or require destructors to be declared as taking
<code>partial Self</code> in order to prove no use of virtual methods.</p><p>Types satisfy the
<a href="/carbon-lang/docs/design/generics/details.md#destructor-constraints"><code>TrivialDestructor</code></a>
type-of-type if:</p><ul><li>the class declaration does not define a destructor or the class defines the
destructor with an empty body <code>{ }</code>,</li><li>all data members implement <code>TrivialDestructor</code>, and</li><li>all base classes implement <code>TrivialDestructor</code>.</li></ul><p>For example, a <a href="#struct-types">struct type</a> implements <code>TrivialDestructor</code> if
all its members do.</p><p><code>TrivialDestructor</code> implies that their destructor does nothing, which may be
used to generate optimized specializations.</p><p>There is no provision for handling failure in a destructor. All operations that
could potentially fail must be performed before the destructor is called.
Unhandled failure during a destructor call will abort the program.</p><p><strong>Future work:</strong> Allow or require destructors to be declared as taking
<code>[var me: Self]</code>.</p><p><strong>Alternatives considered:</strong></p><ul><li><a href="/carbon-lang/proposals/p1154.md#types-implement-destructor-interface">Types implement destructor interface</a></li><li><a href="/carbon-lang/proposals/p1154.md#prevent-virtual-function-calls-in-destructors">Prevent virtual function calls in destructors</a></li><li><a href="/carbon-lang/proposals/p1154.md#allow-functions-to-act-as-destructors">Allow functions to act as destructors</a></li><li><a href="/carbon-lang/proposals/p1154.md#allow-private-destructors">Allow private destructors</a></li><li><a href="/carbon-lang/proposals/p1154.md#allow-multiple-conditional-destructors">Allow multiple conditional destructors</a></li><li><a href="/carbon-lang/proposals/p1154.md#dont-distinguish-safe-and-unsafe-delete-operations">Don&#x27;t distinguish safe and unsafe delete operations</a></li><li><a href="/carbon-lang/proposals/p1154.md#dont-allow-unsafe-delete">Don&#x27;t allow unsafe delete</a></li><li><a href="/carbon-lang/proposals/p1154.md#allow-final-destructors">Allow final destructors</a></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="access-control">Access control<a class="hash-link" href="#access-control" title="Direct link to heading">​</a></h3><p>By default, all members of a class are fully publicly accessible. Access can be
restricted by adding a keyword, called an
<a href="https://en.wikipedia.org/wiki/Access_modifiers" target="_blank" rel="noopener noreferrer">access modifier</a>, prior to the
declaration. Access modifiers are how Carbon supports
<a href="#encapsulated-types">encapsulation</a>.</p><p>The <a href="https://en.wikipedia.org/wiki/Access_modifiers" target="_blank" rel="noopener noreferrer">access modifier</a> is written
before any <a href="#virtual-override-keywords">virtual override keyword</a>.</p><p><strong>Rationale:</strong> Carbon makes members public by default for a few reasons:</p><ul><li>The readability of public members is the most important, since we expect
most readers to be concerned with the public API of a type.</li><li>The members that are most commonly private are the data fields, which have
relatively less complicated definitions that suffer less from the extra
annotation.</li></ul><p>Additionally, there is precedent for this approach in modern object-oriented
languages such as
<a href="https://kotlinlang.org/docs/visibility-modifiers.html" target="_blank" rel="noopener noreferrer">Kotlin</a> and
<a href="https://docs.python.org/3/tutorial/classes.html" target="_blank" rel="noopener noreferrer">Python</a>, both of which are
well regarded for their usability.</p><p>Keywords controlling visibility are attached to individual declarations instead
of C++&#x27;s approach of labels controlling the visibility for all following
declarations to
<a href="/carbon-lang/docs/project/principles/low_context_sensitivity.md">reduce context sensitivity</a>.
This matches
<a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html" target="_blank" rel="noopener noreferrer">Rust</a>,
<a href="https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html" target="_blank" rel="noopener noreferrer">Swift</a>,
<a href="http://rosettacode.org/wiki/Classes#Java" target="_blank" rel="noopener noreferrer">Java</a>,
<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers" target="_blank" rel="noopener noreferrer">C#</a>,
<a href="https://kotlinlang.org/docs/visibility-modifiers.html#classes-and-interfaces" target="_blank" rel="noopener noreferrer">Kotlin</a>,
and <a href="https://wiki.dlang.org/Access_specifiers_and_visibility" target="_blank" rel="noopener noreferrer">D</a>.</p><p><strong>References:</strong> Proposal
<a href="https://github.com/carbon-language/carbon-lang/pull/561" target="_blank" rel="noopener noreferrer">#561: Basic classes</a>
included the decision that
<a href="/carbon-lang/proposals/p0561.md#access-control">members default to publicly accessible</a>
originally asked in issue
<a href="https://github.com/carbon-language/carbon-lang/issues/665" target="_blank" rel="noopener noreferrer">#665</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="private-access">Private access<a class="hash-link" href="#private-access" title="Direct link to heading">​</a></h4><p>As in C++, <code>private</code> means only accessible to members of the class and any
<a href="#friends">friends</a>.</p><div class="language-carbon codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-carbon codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Distance[me: Self]() -&gt; f32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // These are only accessible to members of `Point`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private var x: f32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private var y: f32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A <code>private virtual</code> or <code>private abstract</code> method may be implemented in derived
classes, even though it may not be called. This allows derived classes to
customize the behavior of a function called by a method of the base class, while
still preventing the derived class from calling it. This matches the behavior of
C++ and is more orthogonal.</p><p><strong>Future work:</strong> <code>private</code> will give the member internal linkage unless it needs
to be external because it is used in an inline method or template. We may in the
future
<a href="/carbon-lang/proposals/p0722.md#specifying-linkage-as-part-of-the-access-modifier">add a way to specify internal linkage explicitly</a>.</p><p><strong>Open questions:</strong> Using <code>private</code> to mean &quot;restricted to this class&quot; matches
C++. Other languages support restricting to different scopes:</p><ul><li>Swift supports &quot;restrict to this module&quot; and &quot;restrict to this file&quot;.</li><li>Rust supports &quot;restrict to this module and any children of this module&quot;, as
well as &quot;restrict to this crate&quot;, &quot;restrict to parent module&quot;, and &quot;restrict
to a specific ancestor module&quot;.</li></ul><p><strong>Comparison to other languages:</strong> C++, Rust, and Swift all make class members
private by default. C++ offers the <code>struct</code> keyword that makes members public by
default.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="protected-access">Protected access<a class="hash-link" href="#protected-access" title="Direct link to heading">​</a></h4><p>Protected members may only be accessed by members of this class, members of
derived classes, and any <a href="#friends">friends</a>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">base class MyBaseClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  protected fn HelperClassFunction(x: i32) -&gt; i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  protected fn HelperMethod[me: Self](x: i32) -&gt; i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  protected var data: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class MyDerivedClass extends MyBaseClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn UsesProtected[addr me: Self*]() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Can access protected members in derived class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var x: i32 = HelperClassFunction(3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    me-&gt;data = me-&gt;HelperMethod(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="friends">Friends<a class="hash-link" href="#friends" title="Direct link to heading">​</a></h4><p>Classes may have a <em>friend</em> declaration:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Buddy { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Pal {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private var x: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  friend Buddy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This declares <code>Buddy</code> to be a friend of <code>Pal</code>, which means that <code>Buddy</code> can
access all members of this class, even the ones that are declared <code>private</code> or
<code>protected</code>.</p><p>The <code>friend</code> keyword is followed by the name of an existing function, type, or
parameterized family of types. Unlike C++, it won&#x27;t act as a forward declaration
of that name. The name must be resolvable by the compiler, and so may not be a
member of a template.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="test-friendship">Test friendship<a class="hash-link" href="#test-friendship" title="Direct link to heading">​</a></h4><p><strong>Future work:</strong> There should be a convenient way of allowing tests in the same
library as the class definition to access private members of the class. Ideally
this could be done without changing the class definition itself, since it
doesn&#x27;t affect the class&#x27; public API.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="access-control-for-construction">Access control for construction<a class="hash-link" href="#access-control-for-construction" title="Direct link to heading">​</a></h4><p>A function may construct a class, by casting a struct value to the class type,
if it has access to (write) all of its fields.</p><p><strong>Future work:</strong> There should be a way to limit which code can construct a class
even when it only has public fields. This will be resolved in question-for-leads
issue <a href="https://github.com/carbon-language/carbon-lang/issues/803" target="_blank" rel="noopener noreferrer">#803</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="operator-overloading">Operator overloading<a class="hash-link" href="#operator-overloading" title="Direct link to heading">​</a></h3><p>Developers may define how standard Carbon operators, such as <code>+</code> and <code>/</code>, apply
to custom types by implementing the
<a href="/carbon-lang/design/generics/terminology#interface">interface</a> that corresponds to that operator
for the types of the operands. See the
<a href="/carbon-lang/design/generics/details#operator-overloading">&quot;operator overloading&quot; section</a> of
the <a href="/carbon-lang/design/generics/overview">generics design</a>. The specific interface used for a
given operator may be found in the
<a href="/carbon-lang/docs/design/expressions/README.md">expressions design</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="future-work">Future work<a class="hash-link" href="#future-work" title="Direct link to heading">​</a></h2><p>This includes features that need to be designed, questions to answer, and a
description of the provisional syntax in use until these decisions have been
made.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="struct-literal-shortcut">Struct literal shortcut<a class="hash-link" href="#struct-literal-shortcut" title="Direct link to heading">​</a></h3><p>We could allow you to write <code>{x, y}</code> as a short hand for <code>{.x = x, .y = y}</code>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="optional-named-parameters">Optional named parameters<a class="hash-link" href="#optional-named-parameters" title="Direct link to heading">​</a></h3><p>Structs are being considered as a possible mechanism for implementing optional
named parameters. We have three main candidate approaches: allowing struct types
to have field defaults, having dedicated support for destructuring struct values
in pattern contexts, or having a dedicated optional named parameter syntax.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="field-defaults-for-struct-types">Field defaults for struct types<a class="hash-link" href="#field-defaults-for-struct-types" title="Direct link to heading">​</a></h4><p>If struct types could have field defaults, you could write a function
declaration with all of the optional parameters in an option struct:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn SortIntVector(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v: Vector(i32)*,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    options: {.stable: Bool = false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              .descending: Bool = false} = {}) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Code using `options.stable` and `options.descending`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Uses defaults of `.stable` and `.descending` equal to `false`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SortIntVector(&amp;v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SortIntVector(&amp;v, {});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Sets `.stable` option to `true`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SortIntVector(&amp;v, {.stable = true});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Sets `.descending` option to `true`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SortIntVector(&amp;v, {.descending = true});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Sets both `.stable` and `.descending` options to `true`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SortIntVector(&amp;v, {.stable = true, .descending = true});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Order can be different for arguments as well.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SortIntVector(&amp;v, {.descending = true, .stable = true});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="destructuring-in-pattern-matching">Destructuring in pattern matching<a class="hash-link" href="#destructuring-in-pattern-matching" title="Direct link to heading">​</a></h4><p>We might instead support destructuring struct patterns with defaults:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn SortIntVector(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v: Vector(i32)*,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {stable: Bool = false, descending: Bool = false}) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Code using `stable` and `descending`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This would allow the same syntax at the call site, but avoids
<a href="https://github.com/carbon-language/carbon-lang/pull/561#discussion_r683856715" target="_blank" rel="noopener noreferrer">some concerns with field defaults</a>
and allows some other use cases such as destructuring return values.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="discussion">Discussion<a class="hash-link" href="#discussion" title="Direct link to heading">​</a></h4><p>We might support destructuring directly:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var {key: String, value: i32} = ReturnKeyValue();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>or by way of a mechanism that converts a struct into a tuple:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var (key: String, value: i32) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ReturnKeyValue().extract(.key, .value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// or maybe:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var (key: String, value: i32) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ReturnKeyValue()[(.key, .value)];</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Similarly we might support optional named parameters directly instead of by way
of struct types.</p><p>Some discussion on this topic has occurred in:</p><ul><li><a href="https://github.com/carbon-language/carbon-lang/issues/505" target="_blank" rel="noopener noreferrer">question-for-leads issue #505 on named parameters</a></li><li>labeled params brainstorming docs
<a href="https://docs.google.com/document/d/1a1wI8SHGh3HYV8SUWPIKhg48ZW2glUlAMIIS3aec5dY/edit" target="_blank" rel="noopener noreferrer">1</a>,
<a href="https://docs.google.com/document/d/1u6GORSkcgThMAiYKOqsgALcEviEtcghGb5TTVT-U-N0/edit" target="_blank" rel="noopener noreferrer">2</a></li><li><a href="https://docs.google.com/document/d/1iuytei37LPg_tEd6xe-O6P_bpN7TIbEjNtFMLYW2Nno/edit#heading=h.y566d16ivoy2" target="_blank" rel="noopener noreferrer">&quot;match&quot; in syntax choices doc</a></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="inheritance-1">Inheritance<a class="hash-link" href="#inheritance-1" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="c-abstract-base-classes-interoperating-with-object-safe-interfaces">C++ abstract base classes interoperating with object-safe interfaces<a class="hash-link" href="#c-abstract-base-classes-interoperating-with-object-safe-interfaces" title="Direct link to heading">​</a></h4><p>We want four things so that Carbon&#x27;s object-safe interfaces may interoperate
with C++ abstract base classes without data members, matching the
<a href="#interface-as-base-class">interface as base class use case</a>:</p><ul><li>Ability to convert an object-safe interface (a type-of-type) into an
C++-compatible base class (a base type), maybe using
<code>AsBaseClass(MyInterface)</code>.</li><li>Ability to convert a C++ base class without data members (a base type) into
an object-safe interface (a type-of-type), maybe using <code>AsInterface(MyIBC)</code>.</li><li>Ability to convert a (thin) pointer to an abstract base class to a <code>DynPtr</code>
of the corresponding interface.</li><li>Ability to convert <code>DynPtr(MyInterface)</code> values to a proxy type that extends
the corresponding base class <code>AsBaseType(MyInterface)</code>.</li></ul><p>Note that the proxy type extending <code>AsBaseType(MyInterface)</code> would be a
different type than <code>DynPtr(MyInterface)</code> since the receiver input to the
function members of the vtable for the former does not match those in the
witness table for the latter.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="overloaded-methods">Overloaded methods<a class="hash-link" href="#overloaded-methods" title="Direct link to heading">​</a></h4><p>We allow a derived class to define a <a href="#class-functions">class function</a> with the
same name as a class function in the base class. For example, we expect it to be
pretty common to have a constructor function named <code>Create</code> at all levels of the
type hierarchy.</p><p>Beyond that, we may want some rules or restrictions about defining methods in a
derived class with the same name as a base class method without overriding it.
There are some opportunities to improve on and simplify the C++ story:</p><ul><li>We don&#x27;t want to silently hide methods in the base class because of a method
with the same name in a derived class. There are uses for this in C++, but
it also causes problems and without multiple inheritance there isn&#x27;t the
same need in Carbon.</li><li>Overload resolution should happen before virtual dispatch.</li><li>For evolution purposes, you should be able to add private members to a base
class that have the same name as member of a derived class without affecting
overload resolution on instances of the derived class, in functions that
aren&#x27;t friends of the base class.</li></ul><p><strong>References:</strong> This was discussed in
<a href="https://docs.google.com/document/d/1QCdKQ33rki-kCDrxi8UHy3a36dtW0WdMqpUzluGSrz4/edit?resourcekey=0-bZmNUiueOiH_sysJNqnT9A#heading=h.40jlsrcgp8mr" target="_blank" rel="noopener noreferrer">the open discussion on 2021-07-12</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="interop-with-c-inheritance">Interop with C++ inheritance<a class="hash-link" href="#interop-with-c-inheritance" title="Direct link to heading">​</a></h4><p>This design directly supports Carbon classes inheriting from a single C++ class.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class CarbonClass extends C++.CPlusPlusClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Create() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.base = C++.CPlusPlusClass(...), .other_fields = ...};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To allow C++ classes to extend Carbon classes, there needs to be some way for
C++ constructors to initialize their base class:</p><ul><li><p>There could be some way to export a Carbon class that identifies which
factory functions may be used as constructors.</p></li><li><p>We could explicitly call the Carbon factory function, as in:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// `Base` is a Carbon class which gets converted to a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// C++ class for interop purposes:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Base {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    virtual ~Base() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static auto Create() -&gt; Base;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// In C++</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Derived : public Base {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    virtual ~Derived() override {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // This isn&#x27;t currently a case where C++ guarantees no copy,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // and so it currently still requires a notional copy and</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // there appear to be implementation challenges with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // removing them. This may require an extension to make work</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // reliably without an extraneous copy of the base subobject.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Derived() : Base(Base::Create()) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>However, this doesn&#x27;t work in the case where <code>Base</code> can&#x27;t be instantiated,
or <code>Base</code> does not have a copy constructor, even though it shouldn&#x27;t be
called due to RVO.</p></li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="virtual-base-classes">Virtual base classes<a class="hash-link" href="#virtual-base-classes" title="Direct link to heading">​</a></h5><p>TODO: Ask zygoloid to fill this in.</p><p>Carbon won&#x27;t support declaring virtual base classes, and the C++ interop use
cases Carbon needs to support are limited. This will allow us to simplify the
C++ interop by allowing Carbon to delegate initialization of virtual base
classes to the C++ side.</p><p>This requires that we enforce two rules:</p><ul><li>No multiple inheritance of C++ classes with virtual bases</li><li>No C++ class extending a Carbon class that extends a C++ class with a
virtual base</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="mixins-1">Mixins<a class="hash-link" href="#mixins-1" title="Direct link to heading">​</a></h3><p>We will need some way to declare mixins. This syntax will need a way to
distinguish defining versus requiring member variables. Methods may additionally
be given a default definition but may be overridden. Interface implementations
may only be partially provided by a mixin. Mixin methods will need to be able to
convert between pointers to the mixin type and the main type.</p><p>Open questions include whether a mixin is its own type that is a member of the
containing type, and whether mixins are templated on the containing type. Mixins
also complicate how constructors work.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="memory-layout">Memory layout<a class="hash-link" href="#memory-layout" title="Direct link to heading">​</a></h3><p>Carbon will need some way for users to specify the memory layout of class types
beyond simple ordering of fields, such as controlling the packing and alignment
for the whole type or individual members.</p><p>We may allow members of a derived class like to put data members in the final
padding of its base class prefix. Tail-padding reuse has both advantages and
disadvantages, so we may have some way for a class to explicitly mark that its
tail padding is available for use by a derived class,</p><p>Advantages:</p><ul><li>Tail-padding reuse is sometimes a nice layout optimization (eg, in Clang we
save 8 bytes per <code>Expr</code> by reusing tail padding).</li><li>No class size regressions when migrating from C++.</li><li>Special case of reusing the tail padding of a class that is empty other than
its tail padding is very important, to the extent that we will likely need
to support either zero-sized types or tail-padding reuse in order to have
acceptable class layouts.</li></ul><p>Disadvantages:</p><ul><li>Cannot use <code>memcpy(p, q, sizeof(Base))</code> to copy around base class subobjects
if the destination is an in-lifetime, because they might overlap other
objects&#x27; representations.</li><li>Somewhat more complex model.</li><li>We need some mechanism for disabling tail-padding reuse in &quot;standard layout&quot;
types.</li><li>We may also have to use narrowed loads for the last member of a base class
to avoid accidentally creating a race condition.</li></ul><p>However, we can still use <code>memcpy</code> and <code>memset</code> to initialize a base class
subobject, even if its tail padding might be reused, so long as we guarantee
that no other object lives in the tail padding and is initialized before the
base class. In C++, that happens only due to virtual base classes getting
initialized early and laid out at the end of the object; if we disallow virtual
base classes then we can guarantee that initialization order is address order,
removing most of the downside of tail-padding reuse.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="no-static-variables">No <code>static</code> variables<a class="hash-link" href="#no-static-variables" title="Direct link to heading">​</a></h3><p>At the moment, there is no proposal to support
<a href="https://en.wikipedia.org/wiki/Class_variable#Static_member_variables_and_static_member_functions" target="_blank" rel="noopener noreferrer"><code>static</code> member variables</a>,
in line with avoiding global variables more generally. Carbon may need some
support in this area, though, for parity with and migration from C++.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="computed-properties">Computed properties<a class="hash-link" href="#computed-properties" title="Direct link to heading">​</a></h3><p>Carbon might want to support members of a type that are accessed like a data
member but return a computed value like a function. This has a number of
implications:</p><ul><li>It would be a way of publicly exposing data members for
<a href="#encapsulated-types">encapsulated types</a>, allowing for rules that otherwise
forbid mixing public and private data members.</li><li>It would provide a more graceful evolution path from a
<a href="#data-classes">data class</a> to an <a href="#encapsulated-types">encapsulated type</a>.</li><li>It would give an option to start with a <a href="#data-classes">data class</a> instead
of writing all the boilerplate to create an
<a href="#encapsulated-types">encapsulated type</a> preemptively to allow future
evolution.</li><li>It would let you take a variable away and put a property in its place with
no other code changes. The number one use for this is so you can put a
breakpoint in the property code, then later go back to public variable once
you understand who was misbehaving.</li><li>We should have some guidance for when to use a computed property instead of
a function with no arguments. One possible criteria is when it is a pure
function of the state of the object and executes in an amount of time
similar to ordinary member access.</li></ul><p>However, there are likely to be differences between computed properties and
other data members, such as the ability to take the address of them. We might
want to support &quot;read only&quot; data members, that can be read through the public
api but only modified with private access, for data members which may need to
evolve into a computed property. There are also questions regarding how to
support assigning or modifying computed properties, such as using <code>+=</code>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="interfaces-implemented-for-data-classes">Interfaces implemented for data classes<a class="hash-link" href="#interfaces-implemented-for-data-classes" title="Direct link to heading">​</a></h3><p>We should define a way for defining implementations of interfaces for struct
types. To satisfy coherence, these implementations would have to be defined in
the library with the interface definition. The syntax might look like:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface ConstructWidgetFrom {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Construct(Self) -&gt; Widget;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl {.kind: WidgetKind, .size: i32}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    as ConstructWidgetFrom { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In addition, we should define a way for interfaces to define templated blanket
implementations for <a href="#data-classes">data classes</a> more generally. These
implementations will typically subject to the criteria that all the data fields
of the type must implement the interface. An example use case would be to say
that a data class is serializable if all of its fields were. For this we will
need a type-of-type for capturing that criteria, maybe something like
<code>DataFieldsImplement(MyInterface)</code>. The templated implementation will need some
way of iterating through the fields so it can perform operations fieldwise. This
feature should also implement the interfaces for any tuples whose fields satisfy
the criteria.</p><p>It is an open question how to define implementations for binary operators. For
example, if <code>i32</code> is comparable to <code>f64</code>, then <code>{.x = 3, .y = 2.72}</code> should be
comparable to <code>{.x = 3.14, .y = 2}</code>. The trick is how to declare the criteria
that &quot;<code>T</code> is comparable to <code>U</code> if they have the same field names in the same
order, and for every field <code>x</code>, the type of <code>T.x</code> implements <code>ComparableTo</code> for
the type of <code>U.x</code>.&quot;</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a class="hash-link" href="#references" title="Direct link to heading">​</a></h2><ul><li><a href="https://github.com/carbon-language/carbon-lang/pull/257" target="_blank" rel="noopener noreferrer">#257: Initialization of memory and variables</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/561" target="_blank" rel="noopener noreferrer">#561: Basic classes: use cases, struct literals, struct types, and future wor</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/722" target="_blank" rel="noopener noreferrer">#722: Nominal classes and methods</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/777" target="_blank" rel="noopener noreferrer">#777: Inheritance</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/981" target="_blank" rel="noopener noreferrer">#981: Implicit conversions for aggregates</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/1154" target="_blank" rel="noopener noreferrer">#1154: Destructors</a></li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/carbon-language/carbon-lang/blob/trunk/../docs/design/classes.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/carbon-lang/design/blocks_and_statements"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Blocks and statements</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/carbon-lang/design/code_and_name_organization"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Code and name organization</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#table-of-contents" class="table-of-contents__link toc-highlight">Table of contents</a></li><li><a href="#overview" class="table-of-contents__link toc-highlight">Overview</a></li><li><a href="#use-cases" class="table-of-contents__link toc-highlight">Use cases</a><ul><li><a href="#data-classes" class="table-of-contents__link toc-highlight">Data classes</a></li><li><a href="#encapsulated-types" class="table-of-contents__link toc-highlight">Encapsulated types</a></li><li><a href="#mixins" class="table-of-contents__link toc-highlight">Mixins</a></li></ul></li><li><a href="#background" class="table-of-contents__link toc-highlight">Background</a></li><li><a href="#members" class="table-of-contents__link toc-highlight">Members</a><ul><li><a href="#data-members-have-an-order" class="table-of-contents__link toc-highlight">Data members have an order</a></li></ul></li><li><a href="#struct-types" class="table-of-contents__link toc-highlight">Struct types</a><ul><li><a href="#literals" class="table-of-contents__link toc-highlight">Literals</a></li><li><a href="#type-expression" class="table-of-contents__link toc-highlight">Type expression</a></li><li><a href="#assignment-and-initialization" class="table-of-contents__link toc-highlight">Assignment and initialization</a></li><li><a href="#operations-performed-field-wise" class="table-of-contents__link toc-highlight">Operations performed field-wise</a></li></ul></li><li><a href="#nominal-class-types" class="table-of-contents__link toc-highlight">Nominal class types</a><ul><li><a href="#forward-declaration" class="table-of-contents__link toc-highlight">Forward declaration</a></li><li><a href="#self" class="table-of-contents__link toc-highlight">Self</a></li><li><a href="#construction" class="table-of-contents__link toc-highlight">Construction</a></li><li><a href="#member-functions" class="table-of-contents__link toc-highlight">Member functions</a></li><li><a href="#nominal-data-classes" class="table-of-contents__link toc-highlight">Nominal data classes</a></li><li><a href="#member-type" class="table-of-contents__link toc-highlight">Member type</a></li><li><a href="#let" class="table-of-contents__link toc-highlight">Let</a></li><li><a href="#alias" class="table-of-contents__link toc-highlight">Alias</a></li><li><a href="#inheritance" class="table-of-contents__link toc-highlight">Inheritance</a></li><li><a href="#destructors" class="table-of-contents__link toc-highlight">Destructors</a></li><li><a href="#access-control" class="table-of-contents__link toc-highlight">Access control</a></li><li><a href="#operator-overloading" class="table-of-contents__link toc-highlight">Operator overloading</a></li></ul></li><li><a href="#future-work" class="table-of-contents__link toc-highlight">Future work</a><ul><li><a href="#struct-literal-shortcut" class="table-of-contents__link toc-highlight">Struct literal shortcut</a></li><li><a href="#optional-named-parameters" class="table-of-contents__link toc-highlight">Optional named parameters</a></li><li><a href="#inheritance-1" class="table-of-contents__link toc-highlight">Inheritance</a></li><li><a href="#mixins-1" class="table-of-contents__link toc-highlight">Mixins</a></li><li><a href="#memory-layout" class="table-of-contents__link toc-highlight">Memory layout</a></li><li><a href="#no-static-variables" class="table-of-contents__link toc-highlight">No <code>static</code> variables</a></li><li><a href="#computed-properties" class="table-of-contents__link toc-highlight">Computed properties</a></li><li><a href="#interfaces-implemented-for-data-classes" class="table-of-contents__link toc-highlight">Interfaces implemented for data classes</a></li></ul></li><li><a href="#references" class="table-of-contents__link toc-highlight">References</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/carbon-language/carbon-lang" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discord.gg/ZjVdShJDAs" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/carbon-language/carbon-lang/blob/trunk/CODE_OF_CONDUCT.md" target="_blank" rel="noopener noreferrer" class="footer__link-item">Code of Conduct<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div></div></footer></div>
<script src="/carbon-lang/assets/js/runtime~main.256c0991.js"></script>
<script src="/carbon-lang/assets/js/main.5fcc8113.js"></script>
</body>
</html>