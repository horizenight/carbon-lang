<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-design docs-doc-id-interoperability/philosophy_and_goals">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-rc.1">
<title data-rh="true">Interoperability philosophy and goals | Carbon Language</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://emlai.github.io/carbon-lang/design/interoperability/philosophy_and_goals"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-design-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-design-current"><meta data-rh="true" property="og:title" content="Interoperability philosophy and goals | Carbon Language"><meta data-rh="true" name="description" content="&lt;!--"><meta data-rh="true" property="og:description" content="&lt;!--"><link data-rh="true" rel="icon" href="/carbon-lang/img/carbon-logo.png"><link data-rh="true" rel="canonical" href="https://emlai.github.io/carbon-lang/design/interoperability/philosophy_and_goals"><link data-rh="true" rel="alternate" href="https://emlai.github.io/carbon-lang/design/interoperability/philosophy_and_goals" hreflang="en"><link data-rh="true" rel="alternate" href="https://emlai.github.io/carbon-lang/design/interoperability/philosophy_and_goals" hreflang="x-default"><link rel="stylesheet" href="/carbon-lang/assets/css/styles.0141378e.css">
<link rel="preload" href="/carbon-lang/assets/js/runtime~main.f1d15a26.js" as="script">
<link rel="preload" href="/carbon-lang/assets/js/main.6f04c67b.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/carbon-lang/"><div class="navbar__logo"><img src="/carbon-lang/img/carbon-logo.png" alt="Carbon Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/carbon-lang/img/carbon-logo.png" alt="Carbon Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Carbon Language</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/carbon-lang/design">Design</a><a class="navbar__item navbar__link" href="/carbon-lang/spec">Spec</a><a class="navbar__item navbar__link" href="/carbon-lang/project">Project</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/carbon-language/carbon-lang" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design">Language design</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/aliases">Aliases</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/blocks_and_statements">Blocks and statements</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/classes">Classes</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/code_and_name_organization">Code and name organization</a><button aria-label="Toggle the collapsible sidebar category &#x27;Code and name organization&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/control_flow">Control flow</a><button aria-label="Toggle the collapsible sidebar category &#x27;Control flow&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/expressions">Expressions</a><button aria-label="Toggle the collapsible sidebar category &#x27;Expressions&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/functions">Functions</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/generics">Generics</a><button aria-label="Toggle the collapsible sidebar category &#x27;Generics&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/carbon-lang/design/interoperability">Bidirectional interoperability with C/C++</a><button aria-label="Toggle the collapsible sidebar category &#x27;Bidirectional interoperability with C/C++&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/carbon-lang/design/interoperability/philosophy_and_goals">Interoperability philosophy and goals</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/lexical_conventions">Lexical conventions</a><button aria-label="Toggle the collapsible sidebar category &#x27;Lexical conventions&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/metaprogramming">Metaprogramming</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/name_lookup">Name lookup</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/naming_conventions">Naming conventions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/pattern_matching">Pattern matching</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/primitive_types">Primitive types</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/templates">Templates</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/tuples">Tuples</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/type_inference">Type inference</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/variables">Variables</a></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/carbon-lang/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/carbon-lang/design/interoperability"><span itemprop="name">Bidirectional interoperability with C/C++</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Interoperability philosophy and goals</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Interoperability philosophy and goals</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="table-of-contents">Table of contents<a class="hash-link" href="#table-of-contents" title="Direct link to heading">​</a></h2><ul><li><a href="#background">Background</a><ul><li><a href="#other-interoperability-layers">Other interoperability layers</a></li></ul></li><li><a href="#philosophy">Philosophy</a></li><li><a href="#language-goal-influences">Language goal influences</a><ul><li><a href="#performance-critical-software">Performance-critical software</a></li><li><a href="#software-and-language-evolution">Software and language evolution</a></li><li><a href="#code-that-is-easy-to-read-understand-and-write">Code that is easy to read, understand, and write</a></li><li><a href="#practical-safety-guarantees-and-testing-mechanisms">Practical safety guarantees and testing mechanisms</a></li><li><a href="#fast-and-scalable-development">Fast and scalable development</a></li><li><a href="#modern-os-platforms-hardware-architectures-and-environments">Modern OS platforms, hardware architectures, and environments</a></li><li><a href="#interoperability-with-and-migration-from-existing-c-code">Interoperability with and migration from existing C++ code</a></li></ul></li><li><a href="#goals">Goals</a><ul><li><a href="#support-mixing-carbon-and-c-toolchains">Support mixing Carbon and C++ toolchains</a></li><li><a href="#compatibility-with-the-c-memory-model">Compatibility with the C++ memory model</a></li><li><a href="#minimize-bridge-code">Minimize bridge code</a></li><li><a href="#unsurprising-mappings-between-c-and-carbon-types">Unsurprising mappings between C++ and Carbon types</a></li><li><a href="#allow-c-bridge-code-in-carbon-files">Allow C++ bridge code in Carbon files</a></li><li><a href="#carbon-inheritance-from-c-types">Carbon inheritance from C++ types</a></li><li><a href="#support-use-of-advanced-c-features">Support use of advanced C++ features</a></li><li><a href="#support-basic-c-interoperability">Support basic C interoperability</a></li></ul></li><li><a href="#non-goals">Non-goals</a><ul><li><a href="#full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains">Full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains</a></li><li><a href="#never-require-bridge-code">Never require bridge code</a></li><li><a href="#convert-all-c-types-to-carbon-types">Convert all C++ types to Carbon types</a></li><li><a href="#support-for-c-exceptions-without-bridge-code">Support for C++ exceptions without bridge code</a></li><li><a href="#cross-language-metaprogramming">Cross-language metaprogramming</a></li><li><a href="#offer-equivalent-support-for-languages-other-than-c">Offer equivalent support for languages other than C++</a></li></ul></li><li><a href="#open-questions-to-be-resolved-later">Open questions to be resolved later</a><ul><li><a href="#carbon-type-inheritance-from-non-pure-interface-c-types">Carbon type inheritance from non-pure interface C++ types</a></li><li><a href="#crtp-support">CRTP support</a></li><li><a href="#object-lifetimes">Object lifetimes</a></li></ul></li><li><a href="#references">References</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="background">Background<a class="hash-link" href="#background" title="Direct link to heading">​</a></h2><p>Interoperability with and migration from C++ are a
<a href="/carbon-lang/project/goals#interoperability-with-and-migration-from-existing-c-code">language goal</a>.
However, performance and evolution are
<a href="/carbon-lang/project/goals#language-goals-and-priorities"><em>higher</em> priorities</a>.
This interaction of priorities is important to understanding Carbon&#x27;s
interoperability goals and trade-offs.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="other-interoperability-layers">Other interoperability layers<a class="hash-link" href="#other-interoperability-layers" title="Direct link to heading">​</a></h3><p>Other language interoperability layers that may offer useful examples are:</p><ul><li><p><a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html" target="_blank" rel="noopener noreferrer">Java/Kotlin</a>
should be a comparable interoperability story. The languages are different,
but share an underlying runtime. This may be closest to the model we desire
for Carbon.</p></li><li><p><a href="https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html" target="_blank" rel="noopener noreferrer">JavaScript/TypeScript</a>
is similar to C/C++, where one language is essentially a subset of the
other, allowing high interoperability. This is an interesting reference
point, but we are looking at a different approach with a clearer boundary.</p></li><li><p><a href="https://en.wikipedia.org/wiki/Java_Native_Interface" target="_blank" rel="noopener noreferrer">C++/Java</a> is an
example of requiring specialized code for the bridge layer, making
interoperability more burden on developers. The burden of the approach may
be considered to correspond to the difference in language memory models and
other language design choices. Regardless, the result can be considered
higher maintenance for developers than we want for Carbon.</p></li><li><p><a href="https://golang.org/cmd/cgo/" target="_blank" rel="noopener noreferrer">C++/Go</a> is similar to C++/Java. However, Go
notably allows C++ bridge code to exist in the .go files, which can ease
maintenance of the bridge layer, and is desirable for Carbon.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="philosophy">Philosophy<a class="hash-link" href="#philosophy" title="Direct link to heading">​</a></h2><p>The C++ interoperability layer of Carbon allows a subset of C++ APIs to be
accessed from Carbon code, and similarly a subset of Carbon APIs to be accessed
from C++ code. This requires expressing one language as a subset of the other.
Bridge code may be needed to map some APIs into the relevant subset, but the
constraints on expressivity should be loose enough to keep the amount of such
bridge code sustainable.</p><p>The design for interoperability between Carbon and C++ hinges on:</p><ol><li>The ability to interoperate with a wide variety of code, such as
classes/structs and templates, not just free functions.</li><li>A willingness to expose the idioms of C++ into Carbon code, and the other
way around, when necessary to maximize performance of the interoperability
layer.</li><li>The use of wrappers and generic programming, including templates, to
minimize or eliminate runtime overhead.</li></ol><p>These things come together when looking at how custom data structures in C++ are
exposed into Carbon, and the other way around. In both languages, it is
reasonable and even common to have customized low-level data structures, such as
associative containers. For example, there are numerous data structures for
mapping from a key to a value that might be best for a particular use case,
including hash tables, linked hash tables, sorted vectors, and btrees. Even for
a given data structure, there may be slow but meaningful evolution in
implementations strategies.</p><p>The result is that it will often be reasonable to directly expose a C++ data
structure to Carbon without converting it to a &quot;native&quot; or &quot;idiomatic&quot; Carbon
data structure. Although interfaces may differ, a trivial adapter wrapper should
be sufficient. Many Carbon data structures should also be able to support
multiple implementations with C++ data structures being one such implementation,
allowing for idiomatic use of C++ hidden behind Carbon.</p><p>The reverse is also true. C++ code will often not care, or can be refactored to
not care, what specific data structure is used. Carbon data structures can be
exposed as yet another implementation in C++, and wrapped to match C++ idioms
and even templates.</p><p>For example, a C++ class template like <code>std::vector&lt;T&gt;</code> should be usable without
wrapper code or runtime overhead, and passing a Carbon type as <code>T</code>. The
resulting type should be equally usable from either C++ or Carbon code. It
should also be easy to wrap <code>std::vector&lt;T&gt;</code> with a Carbon interface for
transparent use in idiomatic Carbon code.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="language-goal-influences">Language goal influences<a class="hash-link" href="#language-goal-influences" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="performance-critical-software">Performance-critical software<a class="hash-link" href="#performance-critical-software" title="Direct link to heading">​</a></h3><p>Interoperability with C++ will be frequently used in Carbon, whether it&#x27;s C++
developers trying out Carbon, incrementally migrating a large C++ codebase, or
continuing to use a C++ library long-term. In all cases, it must be possible to
write interoperable code with zero overhead; copies must not be required.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="software-and-language-evolution">Software and language evolution<a class="hash-link" href="#software-and-language-evolution" title="Direct link to heading">​</a></h3><p>Interoperability will require the addition of features to Carbon which exist
primarily to support interoperability use cases. However, these features must
not unduly impinge the overall evolution of Carbon. In particular, only a subset
of Carbon features will support interoperability with C++. To do otherwise would
restrict Carbon&#x27;s feature set.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="code-that-is-easy-to-read-understand-and-write">Code that is easy to read, understand, and write<a class="hash-link" href="#code-that-is-easy-to-read-understand-and-write" title="Direct link to heading">​</a></h3><p>Interoperability-related Carbon code will likely be more difficult to read than
other, more idiomatic Carbon code. This is okay: aiming to make Carbon code
readable doesn&#x27;t mean that it needs to <em>all</em> be trivial to read. At the same
time, the extra costs that interoperability exerts on Carbon developers should
be minimized.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="practical-safety-guarantees-and-testing-mechanisms">Practical safety guarantees and testing mechanisms<a class="hash-link" href="#practical-safety-guarantees-and-testing-mechanisms" title="Direct link to heading">​</a></h3><p>Safety is important to maintain around interoperability code, and mitigations
should be provided where possible. However, safety guarantees will be focused on
native Carbon code. C++ code will not benefit from the same set of safety
mechanisms that Carbon offers, so Carbon code calling into C++ will accept
higher safety risks.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="fast-and-scalable-development">Fast and scalable development<a class="hash-link" href="#fast-and-scalable-development" title="Direct link to heading">​</a></h3><p>The interoperability layer will likely have tooling limitations similar to C++.
For example, Carbon aims to compile quickly. However, C++ interoperability
hinges on compiling C++ code, which is relatively slow. Carbon libraries that
use interoperability will see bottlenecks from C++ compile time. Improving C++
is outside the scope of Carbon.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="modern-os-platforms-hardware-architectures-and-environments">Modern OS platforms, hardware architectures, and environments<a class="hash-link" href="#modern-os-platforms-hardware-architectures-and-environments" title="Direct link to heading">​</a></h3><p>Interoperability will apply to the intersection of environments supported by
both Carbon and C++. Pragmatically, Carbon will likely be the limiting factor
here.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="interoperability-with-and-migration-from-existing-c-code">Interoperability with and migration from existing C++ code<a class="hash-link" href="#interoperability-with-and-migration-from-existing-c-code" title="Direct link to heading">​</a></h3><p>Carbon&#x27;s language goal for interoperability will focus on C++17 compatibility.
The language design must be mindful of the prioritization; trade-offs harming
other goals may still be made so long as they offer greater benefits for
interoperability and Carbon as a whole.</p><p>Although the below interoperability-specific goals will focus on
interoperability, it&#x27;s also important to consider how migration would be
affected. If interoperability requires complex work, particularly to avoid
performance impacts, it could impair the ability to incrementally migrate C++
codebases to Carbon.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="goals">Goals<a class="hash-link" href="#goals" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="support-mixing-carbon-and-c-toolchains">Support mixing Carbon and C++ toolchains<a class="hash-link" href="#support-mixing-carbon-and-c-toolchains" title="Direct link to heading">​</a></h3><p>The Carbon toolchain will support compiling C++ code. It will contain a
customized C++ compiler that enables some more advanced interoperability
features, such as calling Carbon templates from C++.</p><p>Mixing toolchains will also be supported in both directions:</p><ul><li><p>C++ libraries compiled by a non-Carbon toolchain will be usable from Carbon,
so long as they are ABI-compatible with Carbon&#x27;s C++ toolchain.</p></li><li><p>The Carbon toolchain will support, as an option, generating a C++ header and
object file from a Carbon library, with an ABI that&#x27;s suitable for use with
non-Carbon toolchains.</p></li></ul><p>Mixing toolchains restricts functionality to what&#x27;s feasible with the C++ ABI.
For example, developers should expect that Carbon templates will be callable
from C++ when using the Carbon toolchain, and will not be available when mixing
toolchains because it would require a substantially different and more complex
interoperability implementation. This degraded interoperability should still be
sufficient for most developers, albeit with the potential of more bridge code.</p><p>Any C++ interoperability code that works when mixing toolchains must work when
using the native Carbon toolchain. The mixed toolchain support must not have
semantic divergence. The converse is not true, and the native Carbon toolchain
may have additional language support and optimizations.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="compatibility-with-the-c-memory-model">Compatibility with the C++ memory model<a class="hash-link" href="#compatibility-with-the-c-memory-model" title="Direct link to heading">​</a></h3><p>It must be straightforward for any Carbon interoperability code to be compatible
with the C++ memory model. This does not mean that Carbon must exclusively use
the C++ memory model, only that it must be supported.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="minimize-bridge-code">Minimize bridge code<a class="hash-link" href="#minimize-bridge-code" title="Direct link to heading">​</a></h3><p>The majority of simple C++ functions and types should be usable from Carbon
without any custom bridge code and without any runtime overhead. That is, Carbon
code should be able to call most C++ code without any code changes to add
support for interoperability, even if that code was built with a non-Carbon
toolchain. This includes instantiating Carbon templates or generics using C++
types.</p><p>In the other direction, Carbon may need some minimal markup to expose functions
and types to C++. This should help avoid requiring Carbon to generate
C++-compatible endpoints unconditionally, which could have compile and linking
overheads that may in many cases be unnecessary. Also, it should help produce
errors that indicate when a function or type may require additional changes to
make compatible with C++.</p><p>Carbon&#x27;s priority developers should be able to easily reuse the mature ecosystem
of C++ libraries provided by third-parties. A third-party library&#x27;s language
choice should not be a barrier to Carbon adoption.</p><p>Even for first-party libraries, migration of C++ codebases to Carbon will often
be incremental due to human costs of executing and verifying source migrations.
Minimizing the amount of bridge code required should be expected to simplify
such migrations.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="unsurprising-mappings-between-c-and-carbon-types">Unsurprising mappings between C++ and Carbon types<a class="hash-link" href="#unsurprising-mappings-between-c-and-carbon-types" title="Direct link to heading">​</a></h3><p>Carbon will provide unsurprising mappings for common types.</p><p><strong>Primitive types</strong> will have mappings with zero overhead conversions. They are
frequently used, making it important that interoperability code be able to use
them seamlessly.</p><p>The storage and representation will need to be equivalent in both languages. For
example, if a C++ <code>__int64</code> maps to Carbon&#x27;s <code>Int64</code>, the memory layout of both
types must be identical.</p><p>Semantics need to be similar, but edge-case behaviors don&#x27;t need to be
identical, allowing Carbon flexibility to evolve. For example, where C++ would
have modulo wrapping on integers, Carbon could instead have trapping behavior on
the default-mapped primitive types.</p><p>Carbon may have versions of these types with no C++ mapping, such as <code>Int256</code>.</p><p><strong>Non-owning vocabulary types</strong>, such as pointers and references, will have
transparent, automatic translation between C++ and Carbon non-owning vocabulary
types with zero overhead.</p><p><strong>Other vocabulary types</strong> will typically have reasonable, but potentially
non-zero overhead, conversions available to map into Carbon vocabulary types.
Code using these may choose whether to pay the overhead to convert. They may
also use the C++ type directly from Carbon code, and the other way around.</p><p><strong>Incomplete types</strong> must have a mapping with similar semantics, similar to
primitive types.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="allow-c-bridge-code-in-carbon-files">Allow C++ bridge code in Carbon files<a class="hash-link" href="#allow-c-bridge-code-in-carbon-files" title="Direct link to heading">​</a></h3><p>Carbon files should support inline bridge code written in C++. Where bridge code
is necessary, this will allow for maintenance of it directly alongside the code
that uses it.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="carbon-inheritance-from-c-types">Carbon inheritance from C++ types<a class="hash-link" href="#carbon-inheritance-from-c-types" title="Direct link to heading">​</a></h3><p>Carbon will support inheritance from C++ types for interoperability, although
the syntax constructs may look different from C++ inheritance. This is
considered necessary to address cases where a C++ library API expects users to
inherit from a given C++ type.</p><p>This might be restricted to pure interface types; see
<a href="#carbon-type-inheritance-from-non-pure-interface-c-types">the open question</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="support-use-of-advanced-c-features">Support use of advanced C++ features<a class="hash-link" href="#support-use-of-advanced-c-features" title="Direct link to heading">​</a></h3><p>There should be support for most idiomatic usage of advanced C++ features. A few
examples are templates, overload sets,
<a href="https://en.cppreference.com/w/cpp/language/attributes" target="_blank" rel="noopener noreferrer">attributes</a> and
<a href="https://en.wikipedia.org/wiki/Argument-dependent_name_lookup" target="_blank" rel="noopener noreferrer">ADL</a>.</p><p>Although these features can be considered &quot;advanced&quot;, their use is widespread
throughout C++ code, including STL. Support for such features is key to
supporting migration from C++ features.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="support-basic-c-interoperability">Support basic C interoperability<a class="hash-link" href="#support-basic-c-interoperability" title="Direct link to heading">​</a></h3><p>C interoperability support must be sufficient for Carbon code to call popular
APIs that are written in C. The ability of C to call Carbon will be more
restricted, limited to where it echoes C++ interoperability support. Basic C
interoperability will include functions, primitive types, and structs that only
contain member variables.</p><p>Features where interoperability will rely on more advanced C++-specific
features, such as templates, inheritance, and class functions, need not be
supported for C. These would require a C-specific interoperability model that
will not be included.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="non-goals">Non-goals<a class="hash-link" href="#non-goals" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains">Full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains<a class="hash-link" href="#full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains" title="Direct link to heading">​</a></h3><p>Making mixed C++/Carbon toolchain support equivalent to Carbon-only toolchain
support affects all interoperability features. Mixed toolchains will have
degraded support because full parity would be too expensive.</p><p>The feature of calling Carbon templates from C++ code is key when analyzing this
option. Template instantiation during compilation is pervasive in C++.</p><p>With a Carbon toolchain compiling both Carbon and C++ code, the C++ compiler
<em>can</em> be modified to handle Carbon templates differently. Carbon templates can
be handled by exposing the Carbon compiler&#x27;s AST to the C++ compiler directly,
as a compiler extension. While this approach is still complex and may not always
work, it should offer substantial value and ability to migrate C++ code to
Carbon without requiring parallel maintenance of implementations in C++.</p><p>With a mixed toolchain, the C++ compiler <em>cannot</em> be modified to handle Carbon
templates differently. The only way to support template instantiation would be
by having Carbon templates converted into equivalent C++ templates in C++
headers; in other words, template support would require source-to-source
translation. Supporting Carbon to C++ code translations would be a complex and
high cost feature to achieve full parity for mixed toolchains. Requiring bridge
code for mixed toolchains is the likely solution to avoid this cost.</p><p>Note that this issue differs when considering interoperability for Carbon code
instantiating C++ templates. The C++ templates must be in C++ headers for
re-use, which in turn must compile with the Carbon toolchain to re-use the built
C++ code, regardless of whether a separate C++ toolchain is in use. This may
also be considered a constraint on mixed toolchain interoperability, but it&#x27;s
simpler to address and less likely to burden developers.</p><p>To summarize, developers should expect that while <em>most</em> features will work
equivalently for mixed toolchains, there will never be full parity.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="never-require-bridge-code">Never require bridge code<a class="hash-link" href="#never-require-bridge-code" title="Direct link to heading">​</a></h3><p>Corner cases of C++ will not receive equal support to common cases: the
complexity of supporting any given construct must be balanced by the real world
need for that support. For example:</p><ul><li><p>Interoperability will target C++17. Any interoperability support for future
versions of C++, including features such as C++20 modules, will be based on
a cost-benefit analysis. Exhaustive support should not be assumed.</p></li><li><p>Support will be focused on idiomatic code, interfaces, and patterns used in
widespread open source libraries or by other key constituencies. C++ code
will have edge cases where the benefits of limiting Carbon&#x27;s maintenance
costs by avoiding complex interoperability outweighs the value of avoiding
bridge code.</p></li><li><p>Support for low-level C ABIs may be focused on modern 64-bit ABIs, including
Linux, POSIX, and a small subset of Windows&#x27; calling conventions.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="convert-all-c-types-to-carbon-types">Convert all C++ types to Carbon types<a class="hash-link" href="#convert-all-c-types-to-carbon-types" title="Direct link to heading">​</a></h3><p>Non-zero overhead conversions should only be <em>supported</em>, never <em>required</em>, in
order to offer reliable, unsurprising performance behaviors. This does not mean
that conversions will <em>always</em> be supported, as support is a cost-benefit
decision for specific type mappings. For example, consider conversions between
<code>std::vector&lt;T&gt;</code> and an equivalent, idiomatic Carbon type:</p><ul><li><p>Making conversions zero-overhead would require the Carbon type to mirror the
memory layout and implementation semantics of <code>std::vector&lt;T&gt;</code>. However,
doing so would constrain the evolution of the Carbon type to match C++.
Although some constraints are accepted for most primitive types, it would
pose a major burden on Carbon&#x27;s evolution to constrain Carbon&#x27;s types to
match C++ vocabulary type implementations.</p></li><li><p>These conversions may not always be present, but <code>std::vector&lt;T&gt;</code> is a
frequently used type. As a result, it can be expected that there will be
functions supporting a copy-based conversion to the idiomatic Carbon type.</p></li><li><p>An interface which can hide the difference between whether <code>std::vector&lt;T&gt;</code>
or the equivalent, idiomatic Carbon type is in use may also be offered for
common types.</p></li><li><p>It will still be normal to handle C++ types in Carbon code without
conversions. Developers should be given the choice of when to convert.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="support-for-c-exceptions-without-bridge-code">Support for C++ exceptions without bridge code<a class="hash-link" href="#support-for-c-exceptions-without-bridge-code" title="Direct link to heading">​</a></h3><p>Carbon may not provide seamless interoperability support for C++ exceptions. For
example, translating C++ exceptions to or from Carbon errors might require
annotations or bridge code, and those translations may have some performance
overhead or lose information. Furthermore, if Carbon code calls a C++ function
without suitable annotations or bridging, and that function exits with an
exception, the program might terminate.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cross-language-metaprogramming">Cross-language metaprogramming<a class="hash-link" href="#cross-language-metaprogramming" title="Direct link to heading">​</a></h3><p>Carbon&#x27;s metaprogramming design will be more restrictive than C++&#x27;s preprocessor
macros. Although interoperability should handle simple cases, such as
<code>#define STDIN_FILENO 0</code>, complex metaprogramming libraries may require a deep
ability to understand code rewrites. It should be reasonable to have these
instead rewritten to use Carbon&#x27;s metaprogramming model.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="offer-equivalent-support-for-languages-other-than-c">Offer equivalent support for languages other than C++<a class="hash-link" href="#offer-equivalent-support-for-languages-other-than-c" title="Direct link to heading">​</a></h3><p>Long-term, it should be anticipated that Carbon will add interoperability with
non-C++ languages. However, interoperability discussions will be focused on C++
in order to support the
<a href="/carbon-lang/project/goals#interoperability-with-and-migration-from-existing-c-code">language goal</a>.
Although we should work to consider extensibility when building interoperability
facilities, C++ should be expected to have more robust support.</p><p>Many languages do offer interoperability layers with C. Carbon&#x27;s
<a href="#support-basic-c-interoperability">C interoperability</a> will likely offer a
degree of multi-language interoperability using C as an intermediary.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="open-questions-to-be-resolved-later">Open questions to be resolved later<a class="hash-link" href="#open-questions-to-be-resolved-later" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="carbon-type-inheritance-from-non-pure-interface-c-types">Carbon type inheritance from non-pure interface C++ types<a class="hash-link" href="#carbon-type-inheritance-from-non-pure-interface-c-types" title="Direct link to heading">​</a></h3><p>Some C++ APIs will expect that consumers use classes that inherit from a type
provided by the API. It&#x27;s desirable to have Carbon support, in some way,
inheritance from API types in order to use these APIs.</p><p>It may be sufficient to require the parent type be a pure interface, and that
APIs with either use bridge code or switch implementations. That will be
determined later.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="crtp-support">CRTP support<a class="hash-link" href="#crtp-support" title="Direct link to heading">​</a></h3><p>Although
<a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" target="_blank" rel="noopener noreferrer">CRTP</a> is a
common technique in C++, interoperability support may require substantial work.
Libraries based on use of CRTP may require bridge code or a rewrite for Carbon
interoperability.</p><p>More analysis should be done on the cost-benefit of supporting CRTP before
making a support decision.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="object-lifetimes">Object lifetimes<a class="hash-link" href="#object-lifetimes" title="Direct link to heading">​</a></h3><p>Carbon may have a different object lifetime design than C++. For example, Carbon
may choose different rules for determining the lifetime of temporaries. This
could affect idiomatic use of C++ APIs, turning code that would be safe in C++
into unsafe Carbon code, requiring developers to learn new coding patterns.</p><p>More analysis should be done on object lifetimes and potential Carbon designs
for it before deciding how to treat object lifetimes in the scope of
interoperability.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a class="hash-link" href="#references" title="Direct link to heading">​</a></h2><ul><li>Proposal
<a href="https://github.com/carbon-language/carbon-lang/pull/175" target="_blank" rel="noopener noreferrer">#175: C++ interoperability goals</a></li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/interoperability/philosophy_and_goals.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/carbon-lang/design/interoperability"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Bidirectional interoperability with C/C++</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/carbon-lang/design/lexical_conventions"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Lexical conventions</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#table-of-contents" class="table-of-contents__link toc-highlight">Table of contents</a></li><li><a href="#background" class="table-of-contents__link toc-highlight">Background</a><ul><li><a href="#other-interoperability-layers" class="table-of-contents__link toc-highlight">Other interoperability layers</a></li></ul></li><li><a href="#philosophy" class="table-of-contents__link toc-highlight">Philosophy</a></li><li><a href="#language-goal-influences" class="table-of-contents__link toc-highlight">Language goal influences</a><ul><li><a href="#performance-critical-software" class="table-of-contents__link toc-highlight">Performance-critical software</a></li><li><a href="#software-and-language-evolution" class="table-of-contents__link toc-highlight">Software and language evolution</a></li><li><a href="#code-that-is-easy-to-read-understand-and-write" class="table-of-contents__link toc-highlight">Code that is easy to read, understand, and write</a></li><li><a href="#practical-safety-guarantees-and-testing-mechanisms" class="table-of-contents__link toc-highlight">Practical safety guarantees and testing mechanisms</a></li><li><a href="#fast-and-scalable-development" class="table-of-contents__link toc-highlight">Fast and scalable development</a></li><li><a href="#modern-os-platforms-hardware-architectures-and-environments" class="table-of-contents__link toc-highlight">Modern OS platforms, hardware architectures, and environments</a></li><li><a href="#interoperability-with-and-migration-from-existing-c-code" class="table-of-contents__link toc-highlight">Interoperability with and migration from existing C++ code</a></li></ul></li><li><a href="#goals" class="table-of-contents__link toc-highlight">Goals</a><ul><li><a href="#support-mixing-carbon-and-c-toolchains" class="table-of-contents__link toc-highlight">Support mixing Carbon and C++ toolchains</a></li><li><a href="#compatibility-with-the-c-memory-model" class="table-of-contents__link toc-highlight">Compatibility with the C++ memory model</a></li><li><a href="#minimize-bridge-code" class="table-of-contents__link toc-highlight">Minimize bridge code</a></li><li><a href="#unsurprising-mappings-between-c-and-carbon-types" class="table-of-contents__link toc-highlight">Unsurprising mappings between C++ and Carbon types</a></li><li><a href="#allow-c-bridge-code-in-carbon-files" class="table-of-contents__link toc-highlight">Allow C++ bridge code in Carbon files</a></li><li><a href="#carbon-inheritance-from-c-types" class="table-of-contents__link toc-highlight">Carbon inheritance from C++ types</a></li><li><a href="#support-use-of-advanced-c-features" class="table-of-contents__link toc-highlight">Support use of advanced C++ features</a></li><li><a href="#support-basic-c-interoperability" class="table-of-contents__link toc-highlight">Support basic C interoperability</a></li></ul></li><li><a href="#non-goals" class="table-of-contents__link toc-highlight">Non-goals</a><ul><li><a href="#full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains" class="table-of-contents__link toc-highlight">Full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains</a></li><li><a href="#never-require-bridge-code" class="table-of-contents__link toc-highlight">Never require bridge code</a></li><li><a href="#convert-all-c-types-to-carbon-types" class="table-of-contents__link toc-highlight">Convert all C++ types to Carbon types</a></li><li><a href="#support-for-c-exceptions-without-bridge-code" class="table-of-contents__link toc-highlight">Support for C++ exceptions without bridge code</a></li><li><a href="#cross-language-metaprogramming" class="table-of-contents__link toc-highlight">Cross-language metaprogramming</a></li><li><a href="#offer-equivalent-support-for-languages-other-than-c" class="table-of-contents__link toc-highlight">Offer equivalent support for languages other than C++</a></li></ul></li><li><a href="#open-questions-to-be-resolved-later" class="table-of-contents__link toc-highlight">Open questions to be resolved later</a><ul><li><a href="#carbon-type-inheritance-from-non-pure-interface-c-types" class="table-of-contents__link toc-highlight">Carbon type inheritance from non-pure interface C++ types</a></li><li><a href="#crtp-support" class="table-of-contents__link toc-highlight">CRTP support</a></li><li><a href="#object-lifetimes" class="table-of-contents__link toc-highlight">Object lifetimes</a></li></ul></li><li><a href="#references" class="table-of-contents__link toc-highlight">References</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/carbon-language/carbon-lang" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discord.gg/ZjVdShJDAs" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/carbon-language/carbon-lang/blob/trunk/CODE_OF_CONDUCT.md" target="_blank" rel="noopener noreferrer" class="footer__link-item">Code of Conduct<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div></div></footer></div>
<script src="/carbon-lang/assets/js/runtime~main.f1d15a26.js"></script>
<script src="/carbon-lang/assets/js/main.6f04c67b.js"></script>
</body>
</html>