<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-design docs-doc-id-generics/details">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-rc.1">
<title data-rh="true">Generics: Details | Carbon Language</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://emlai.github.io/carbon-lang/design/generics/details"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-design-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-design-current"><meta data-rh="true" property="og:title" content="Generics: Details | Carbon Language"><meta data-rh="true" name="description" content="&lt;!--"><meta data-rh="true" property="og:description" content="&lt;!--"><link data-rh="true" rel="icon" href="/carbon-lang/img/carbon-logo.png"><link data-rh="true" rel="canonical" href="https://emlai.github.io/carbon-lang/design/generics/details"><link data-rh="true" rel="alternate" href="https://emlai.github.io/carbon-lang/design/generics/details" hreflang="en"><link data-rh="true" rel="alternate" href="https://emlai.github.io/carbon-lang/design/generics/details" hreflang="x-default"><link rel="stylesheet" href="/carbon-lang/assets/css/styles.0141378e.css">
<link rel="preload" href="/carbon-lang/assets/js/runtime~main.3ad223b0.js" as="script">
<link rel="preload" href="/carbon-lang/assets/js/main.b824e67a.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/carbon-lang/"><div class="navbar__logo"><img src="/carbon-lang/img/carbon-logo.png" alt="Carbon Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/carbon-lang/img/carbon-logo.png" alt="Carbon Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Carbon Language</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/carbon-lang/design">Design</a><a class="navbar__item navbar__link" href="/carbon-lang/spec">Spec</a><a class="navbar__item navbar__link" href="/carbon-lang/project">Project</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/carbon-language/carbon-lang" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design">Language design</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/aliases">Aliases</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/blocks_and_statements">Blocks and statements</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/classes">Classes</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/code_and_name_organization">Code and name organization</a><button aria-label="Toggle the collapsible sidebar category &#x27;Code and name organization&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/control_flow">Control flow</a><button aria-label="Toggle the collapsible sidebar category &#x27;Control flow&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/expressions">Expressions</a><button aria-label="Toggle the collapsible sidebar category &#x27;Expressions&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/functions">Functions</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/carbon-lang/design/generics">Generics</a><button aria-label="Toggle the collapsible sidebar category &#x27;Generics&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/carbon-lang/design/generics/appendix-coherence">Carbon: alternatives to coherence</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/carbon-lang/design/generics/details">Generics: Details</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/carbon-lang/design/generics/goals">Generics: Goals</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/carbon-lang/design/generics/overview">Generics: Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/carbon-lang/design/generics/terminology">Generics: Terminology</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/interoperability">Bidirectional interoperability with C/C++</a><button aria-label="Toggle the collapsible sidebar category &#x27;Bidirectional interoperability with C/C++&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/carbon-lang/design/lexical_conventions">Lexical conventions</a><button aria-label="Toggle the collapsible sidebar category &#x27;Lexical conventions&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/metaprogramming">Metaprogramming</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/name_lookup">Name lookup</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/naming_conventions">Naming conventions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/pattern_matching">Pattern matching</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/primitive_types">Primitive types</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/templates">Templates</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/tuples">Tuples</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/type_inference">Type inference</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/carbon-lang/design/variables">Variables</a></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/carbon-lang/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/carbon-lang/design/generics"><span itemprop="name">Generics</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Generics: Details</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Generics: Details</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="table-of-contents">Table of contents<a class="hash-link" href="#table-of-contents" title="Direct link to heading">​</a></h2><ul><li><a href="#overview">Overview</a></li><li><a href="#interfaces">Interfaces</a></li><li><a href="#implementing-interfaces">Implementing interfaces</a><ul><li><a href="#implementing-multiple-interfaces">Implementing multiple interfaces</a></li><li><a href="#external-impl">External impl</a></li><li><a href="#qualified-member-names-and-compound-member-access">Qualified member names and compound member access</a></li><li><a href="#access">Access</a></li></ul></li><li><a href="#generics">Generics</a><ul><li><a href="#return-type">Return type</a></li><li><a href="#implementation-model">Implementation model</a></li></ul></li><li><a href="#interfaces-recap">Interfaces recap</a></li><li><a href="#type-of-types">Type-of-types</a></li><li><a href="#named-constraints">Named constraints</a><ul><li><a href="#subtyping-between-type-of-types">Subtyping between type-of-types</a></li></ul></li><li><a href="#combining-interfaces-by-anding-type-of-types">Combining interfaces by anding type-of-types</a></li><li><a href="#interface-requiring-other-interfaces">Interface requiring other interfaces</a><ul><li><a href="#interface-extension">Interface extension</a><ul><li><a href="#extends-and-impl-with-named-constraints"><code>extends</code> and <code>impl</code> with named constraints</a></li><li><a href="#diamond-dependency-issue">Diamond dependency issue</a></li></ul></li><li><a href="#use-case-overload-resolution">Use case: overload resolution</a></li></ul></li><li><a href="#adapting-types">Adapting types</a><ul><li><a href="#adapter-compatibility">Adapter compatibility</a></li><li><a href="#extending-adapter">Extending adapter</a></li><li><a href="#use-case-using-independent-libraries-together">Use case: Using independent libraries together</a></li><li><a href="#use-case-defining-an-impl-for-use-by-other-types">Use case: Defining an impl for use by other types</a></li><li><a href="#use-case-private-impl">Use case: Private impl</a></li><li><a href="#use-case-accessing-external-names">Use case: Accessing external names</a></li><li><a href="#adapter-with-stricter-invariants">Adapter with stricter invariants</a></li></ul></li><li><a href="#associated-constants">Associated constants</a><ul><li><a href="#associated-class-functions">Associated class functions</a></li></ul></li><li><a href="#associated-types">Associated types</a><ul><li><a href="#implementation-model-1">Implementation model</a></li></ul></li><li><a href="#parameterized-interfaces">Parameterized interfaces</a><ul><li><a href="#impl-lookup">Impl lookup</a></li><li><a href="#parameterized-named-constraints">Parameterized named constraints</a></li></ul></li><li><a href="#where-constraints">Where constraints</a><ul><li><a href="#constraint-use-cases">Constraint use cases</a><ul><li><a href="#set-an-associated-constant-to-a-specific-value">Set an associated constant to a specific value</a></li><li><a href="#same-type-constraints">Same type constraints</a><ul><li><a href="#set-an-associated-type-to-a-specific-value">Set an associated type to a specific value</a></li><li><a href="#equal-generic-types">Equal generic types</a><ul><li><a href="#satisfying-both-type-of-types">Satisfying both type-of-types</a></li></ul></li></ul></li><li><a href="#type-bound-for-associated-type">Type bound for associated type</a><ul><li><a href="#type-bounds-on-associated-types-in-declarations">Type bounds on associated types in declarations</a></li><li><a href="#type-bounds-on-associated-types-in-interfaces">Type bounds on associated types in interfaces</a></li></ul></li><li><a href="#combining-constraints">Combining constraints</a></li><li><a href="#recursive-constraints">Recursive constraints</a></li><li><a href="#parameterized-type-implements-interface">Parameterized type implements interface</a></li><li><a href="#another-type-implements-parameterized-interface">Another type implements parameterized interface</a></li></ul></li><li><a href="#implied-constraints">Implied constraints</a><ul><li><a href="#must-be-legal-type-argument-constraints">Must be legal type argument constraints</a></li></ul></li><li><a href="#referencing-names-in-the-interface-being-defined">Referencing names in the interface being defined</a></li><li><a href="#manual-type-equality">Manual type equality</a><ul><li><a href="#observe-declarations"><code>observe</code> declarations</a></li></ul></li></ul></li><li><a href="#other-constraints-as-type-of-types">Other constraints as type-of-types</a><ul><li><a href="#is-a-derived-class">Is a derived class</a></li><li><a href="#type-compatible-with-another-type">Type compatible with another type</a><ul><li><a href="#same-implementation-restriction">Same implementation restriction</a></li><li><a href="#example-multiple-implementations-of-the-same-interface">Example: Multiple implementations of the same interface</a></li><li><a href="#example-creating-an-impl-out-of-other-impls">Example: Creating an impl out of other impls</a></li></ul></li><li><a href="#sized-types-and-type-of-types">Sized types and type-of-types</a><ul><li><a href="#implementation-model-2">Implementation model</a></li></ul></li><li><a href="#typeid"><code>TypeId</code></a></li><li><a href="#destructor-constraints">Destructor constraints</a></li></ul></li><li><a href="#generic-let">Generic <code>let</code></a></li><li><a href="#parameterized-impls">Parameterized impls</a><ul><li><a href="#impl-for-a-parameterized-type">Impl for a parameterized type</a></li><li><a href="#conditional-conformance">Conditional conformance</a><ul><li><a href="#conditional-methods">Conditional methods</a></li></ul></li><li><a href="#blanket-impls">Blanket impls</a><ul><li><a href="#difference-between-blanket-impls-and-named-constraints">Difference between blanket impls and named constraints</a></li></ul></li><li><a href="#wildcard-impls">Wildcard impls</a></li><li><a href="#combinations">Combinations</a></li><li><a href="#lookup-resolution-and-specialization">Lookup resolution and specialization</a><ul><li><a href="#type-structure-of-an-impl-declaration">Type structure of an impl declaration</a></li><li><a href="#orphan-rule">Orphan rule</a></li><li><a href="#overlap-rule">Overlap rule</a></li><li><a href="#prioritization-rule">Prioritization rule</a></li><li><a href="#acyclic-rule">Acyclic rule</a></li><li><a href="#termination-rule">Termination rule</a></li></ul></li><li><a href="#final-impls"><code>final</code> impls</a><ul><li><a href="#libraries-that-can-contain-final-impls">Libraries that can contain <code>final</code> impls</a></li></ul></li><li><a href="#comparison-to-rust">Comparison to Rust</a></li></ul></li><li><a href="#forward-declarations-and-cyclic-references">Forward declarations and cyclic references</a><ul><li><a href="#declaring-interfaces-and-named-constraints">Declaring interfaces and named constraints</a></li><li><a href="#declaring-implementations">Declaring implementations</a></li><li><a href="#matching-and-agreeing">Matching and agreeing</a></li><li><a href="#declaration-examples">Declaration examples</a></li><li><a href="#example-of-declaring-interfaces-with-cyclic-references">Example of declaring interfaces with cyclic references</a></li><li><a href="#interfaces-with-parameters-constrained-by-the-same-interface">Interfaces with parameters constrained by the same interface</a></li></ul></li><li><a href="#interface-members-with-definitions">Interface members with definitions</a><ul><li><a href="#interface-defaults">Interface defaults</a></li><li><a href="#final-members"><code>final</code> members</a></li></ul></li><li><a href="#interface-requiring-other-interfaces-revisited">Interface requiring other interfaces revisited</a><ul><li><a href="#requirements-with-where-constraints">Requirements with <code>where</code> constraints</a></li></ul></li><li><a href="#observing-a-type-implements-an-interface">Observing a type implements an interface</a><ul><li><a href="#observing-interface-requirements">Observing interface requirements</a></li><li><a href="#observing-blanket-impls">Observing blanket impls</a></li></ul></li><li><a href="#operator-overloading">Operator overloading</a><ul><li><a href="#binary-operators">Binary operators</a></li><li><a href="#like-operator-for-implicit-conversions"><code>like</code> operator for implicit conversions</a></li></ul></li><li><a href="#parameterized-types">Parameterized types</a><ul><li><a href="#specialization">Specialization</a></li></ul></li><li><a href="#future-work">Future work</a><ul><li><a href="#dynamic-types">Dynamic types</a><ul><li><a href="#runtime-type-parameters">Runtime type parameters</a></li><li><a href="#runtime-type-fields">Runtime type fields</a></li></ul></li><li><a href="#abstract-return-types">Abstract return types</a></li><li><a href="#evolution">Evolution</a></li><li><a href="#testing">Testing</a></li><li><a href="#impls-with-state">Impls with state</a></li><li><a href="#generic-associated-types-and-higher-ranked-types">Generic associated types and higher-ranked types</a><ul><li><a href="#generic-associated-types">Generic associated types</a></li><li><a href="#higher-ranked-types">Higher-ranked types</a></li></ul></li><li><a href="#field-requirements">Field requirements</a></li><li><a href="#bridge-for-c-customization-points">Bridge for C++ customization points</a></li><li><a href="#variadic-arguments">Variadic arguments</a></li><li><a href="#range-constraints-on-generic-integers">Range constraints on generic integers</a></li></ul></li><li><a href="#references">References</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="overview">Overview<a class="hash-link" href="#overview" title="Direct link to heading">​</a></h2><p>This document goes into the details of the design of generic type parameters.</p><p>Imagine we want to write a function parameterized by a type argument. Maybe our
function is <code>PrintToStdout</code> and let&#x27;s say we want to operate on values that have
a type for which we have an implementation of the <code>ConvertibleToString</code>
interface. The <code>ConvertibleToString</code> interface has a <code>ToString</code> method returning
a string. To do this, we give the <code>PrintToStdout</code> function two parameters: one
is the value to print, let&#x27;s call that <code>val</code>, the other is the type of that
value, let&#x27;s call that <code>T</code>. The type of <code>val</code> is <code>T</code>, what is the type of <code>T</code>?
Well, since we want to let <code>T</code> be any type implementing the
<code>ConvertibleToString</code> interface, we express that in the &quot;interfaces are
type-of-types&quot; model by saying the type of <code>T</code> is <code>ConvertibleToString</code>.</p><p>Since we can figure out <code>T</code> from the type of <code>val</code>, we don&#x27;t need the caller to
pass in <code>T</code> explicitly, so it can be a
<a href="/carbon-lang/design/generics/terminology#deduced-parameter">deduced parameter</a> (also see
<a href="/carbon-lang/design/generics/overview#deduced-parameters">deduced parameters</a> in the Generics overview
doc). Basically, the user passes in a value for <code>val</code>, and the type of <code>val</code>
determines <code>T</code>. <code>T</code> still gets passed into the function though, and it plays an
important role -- it defines the implementation of the interface. We can think
of the interface as defining a struct type whose members are function pointers,
and an implementation of an interface as a value of that struct with actual
function pointer values. So an implementation is a table of function pointers
(one per function defined in the interface) that gets passed into a function as
the type argument. For more on this, see
<a href="#implementation-model">the implementation model section</a> below.</p><p>In addition to function pointer members, interfaces can include any constants
that belong to a type. For example, the
<a href="#sized-types-and-type-of-types">type&#x27;s size</a> (represented by an integer
constant member of the type) could be a member of an interface and its
implementation. There are a few cases why we would include another interface
implementation as a member:</p><ul><li><a href="#associated-types">associated types</a></li><li><a href="#parameterized-interfaces">type parameters</a></li><li><a href="#interface-requiring-other-interfaces">interface requirements</a></li></ul><p>The function expresses that the type argument is passed in
<a href="/carbon-lang/design/generics/terminology#static-dispatch-witness-table">statically</a>, basically generating
a separate function body for every different type passed in, by using the
&quot;generic argument&quot; syntax <code>:!</code>, see <a href="#generics">the generics section</a> below. The
interface contains enough information to
<a href="/carbon-lang/design/generics/terminology#complete-definition-checking">type and definition check</a> the
function body -- you can only call functions defined in the interface in the
function body. Contrast this with making the type a template argument, where you
could just use <code>Type</code> instead of an interface and it will work as long as the
function is only called with types that allow the definition of the function to
compile. The interface bound has other benefits:</p><ul><li>allows the compiler to deliver clearer error messages,</li><li>documents expectations, and</li><li>expresses that a type has certain semantics beyond what is captured in its
member function names and signatures.</li></ul><p>The last piece of the puzzle is calling the function. For a value of type <code>Song</code>
to be printed using the <code>PrintToStdout</code> function, <code>Song</code> needs to implement the
<code>ConvertibleToString</code> interface. Interface implementations will usually be
defined either with the type or with the interface. They may also be defined
somewhere else as long as Carbon can be guaranteed to see the definition when
needed. For more on this, see
<a href="#implementing-interfaces">the implementing interfaces section</a> below.</p><p>Unless the implementation of <code>ConvertibleToString</code> for <code>Song</code> is defined as
<code>external</code>, every member of <code>ConvertibleToString</code> is also a member of <code>Song</code>.
This includes members of <code>ConvertibleToString</code> that are not explicitly named in
the <code>impl</code> definition but have defaults. Whether the implementation is defined
as <a href="/carbon-lang/design/generics/terminology#internal-impl">internal</a> or
<a href="/carbon-lang/design/generics/terminology#external-impl">external</a>, you may access the <code>ToString</code> function
for a <code>Song</code> value <code>s</code> by a writing function call
<a href="/carbon-lang/design/generics/terminology#qualified-member-access-expression">using a qualified member access expression</a>,
like <code>s.(ConvertibleToString.ToString)()</code>.</p><p>If <code>Song</code> doesn&#x27;t implement an interface or we would like to use a different
implementation of that interface, we can define another type that also has the
same data representation as <code>Song</code> that has whatever different interface
implementations we want. However, Carbon won&#x27;t implicitly convert to that other
type, the user will have to explicitly cast to that type in order to select
those alternate implementations. For more on this, see
<a href="#adapting-types">the adapting type section</a> below.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="interfaces">Interfaces<a class="hash-link" href="#interfaces" title="Direct link to heading">​</a></h2><p>An <a href="/carbon-lang/design/generics/terminology#interface">interface</a>, defines an API that a given type can
implement. For example, an interface capturing a linear-algebra vector API might
have two methods:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Vector {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Here `Self` means &quot;the type implementing this interface&quot;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Add[me: Self](b: Self) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Scale[me: Self](v: f64) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The syntax here is to match
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/classes.md#methods" target="_blank" rel="noopener noreferrer">how the same members would be defined in a type</a>.
Each declaration in the interface defines an
<a href="/carbon-lang/design/generics/terminology#associated-entity">associated entity</a>. In this example, <code>Vector</code>
has two associated methods, <code>Add</code> and <code>Scale</code>.</p><p>An interface defines a type-of-type, that is a type whose values are types. The
values of an interface are any types implementing the interface, and so provide
definitions for all the functions (and other members) declared in the interface.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="implementing-interfaces">Implementing interfaces<a class="hash-link" href="#implementing-interfaces" title="Direct link to heading">​</a></h2><p>Carbon interfaces are <a href="/carbon-lang/design/generics/terminology#nominal-interfaces">&quot;nominal&quot;</a>, which
means that types explicitly describe how they implement interfaces. An
<a href="/carbon-lang/design/generics/terminology#impls-implementations-of-interfaces">&quot;impl&quot;</a> defines how one
interface is implemented for a type. Every associated entity is given a
definition. Different types satisfying <code>Vector</code> can have different definitions
for <code>Add</code> and <code>Scale</code>, so we say their definitions are <em>associated</em> with what
type is implementing <code>Vector</code>. The <code>impl</code> defines what is associated with the
type for that interface.</p><p>Impls may be defined inline inside the type definition:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Vector {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // In this scope, &quot;Self&quot; is an alias for &quot;Point&quot;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Add[me: Self](b: Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {.x = a.x + b.x, .y = a.y + b.y};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Scale[me: Self](v: f64) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {.x = a.x * v, .y = a.y * v};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Interfaces that are implemented inline contribute to the type&#x27;s API:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var p1: Point = {.x = 1.0, .y = 2.0};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var p2: Point = {.x = 2.0, .y = 4.0};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(p1.Scale(2.0) == p2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(p1.Add(p1) == p2);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Note:</strong> A type may implement any number of different interfaces, but may
provide at most one implementation of any single interface. This makes the act
of selecting an implementation of an interface for a type unambiguous throughout
the whole program.</p><p><strong>Comparison with other languages:</strong> Rust defines implementations lexically
outside of the <code>class</code> definition. This Carbon approach means that a type&#x27;s API
is described by declarations inside the <code>class</code> definition and doesn&#x27;t change
afterwards.</p><p><strong>References:</strong> This interface implementation syntax was accepted in
<a href="https://github.com/carbon-language/carbon-lang/pull/553" target="_blank" rel="noopener noreferrer">proposal #553</a>. In
particular, see
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//proposals/p0553.md#interface-implementation-syntax" target="_blank" rel="noopener noreferrer">the alternatives considered</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="implementing-multiple-interfaces">Implementing multiple interfaces<a class="hash-link" href="#implementing-multiple-interfaces" title="Direct link to heading">​</a></h3><p>To implement more than one interface when defining a type, simply include an
<code>impl</code> block per interface.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Vector {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Add[me: Self](b: Self) -&gt; Self { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Scale[me: Self](v: f64) -&gt; Self { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Drawable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Draw[me: Self]() { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In this case, all the functions <code>Add</code>, <code>Scale</code>, and <code>Draw</code> end up a part of the
API for <code>Point</code>. This means you can&#x27;t implement two interfaces that have a name
in common (unless you use an <code>external impl</code> for one or both, as described
below).</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class GameBoard {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Drawable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Draw[me: Self]() { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as EndOfGame {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ❌ Error: `GameBoard` has two methods named</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `Draw` with the same signature.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Draw[me: Self]() { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Winner[me: Self](player: i32) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Open question:</strong> Should we have some syntax for the case where you want both
names to be given the same implementation? It seems like that might be a common
case, but we won&#x27;t really know if this is an important case until we get more
experience.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Player {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var name: String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Icon {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Name[me: Self]() -&gt; String { return me.name; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as GameUnit {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Possible syntax options for defining</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `GameUnit.Name` as the same as `Icon.Name`:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    alias Name = Icon.Name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Name[me: Self]() -&gt; String = Icon.Name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="external-impl">External impl<a class="hash-link" href="#external-impl" title="Direct link to heading">​</a></h3><p>Interfaces may also be implemented for a type
<a href="/carbon-lang/design/generics/terminology#external-impl">externally</a>, by using the <code>external impl</code>
construct. An external impl does not add the interface&#x27;s methods to the type.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Point2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  external impl as Vector {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // In this scope, `Self` is an alias for `Point2`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Add[me: Self](b: Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {.x = a.x + b.x, .y = a.y + b.y};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Scale[me: Self](v: f64) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {.x = a.x * v, .y = a.y * v};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var a: Point2 = {.x = 1.0, .y = 2.0};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `a` does *not* have `Add` and `Scale` methods:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Error: a.Add(a.Scale(2.0));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>An external impl may be defined out-of-line, by including the name of the
existing type before <code>as</code>, which is otherwise optional:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Point3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Point3 as Vector {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // In this scope, `Self` is an alias for `Point3`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Add[me: Self](b: Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.x = a.x + b.x, .y = a.y + b.y};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Scale[me: Self](v: f64) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.x = a.x * v, .y = a.y * v};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var a: Point3 = {.x = 1.0, .y = 2.0};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `a` does *not* have `Add` and `Scale` methods:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Error: a.Add(a.Scale(2.0));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>References:</strong> The external interface implementation syntax was decided in
<a href="https://github.com/carbon-language/carbon-lang/pull/553" target="_blank" rel="noopener noreferrer">proposal #553</a>. In
particular, see
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//proposals/p0553.md#interface-implementation-syntax" target="_blank" rel="noopener noreferrer">the alternatives considered</a>.</p><p>The <code>external impl</code> statement is allowed to be defined in a different library
from <code>Point3</code>, restricted by <a href="#impl-lookup">the coherence/orphan rules</a> that
ensure that the implementation of an interface can&#x27;t change based on imports. In
particular, the <code>external impl</code> statement is allowed in the library defining the
interface (<code>Vector</code> in this case) in addition to the library that defines the
type (<code>Point3</code> here). This (at least partially) addresses
<a href="https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions" target="_blank" rel="noopener noreferrer">the expression problem</a>.</p><p>Carbon requires <code>impl</code>s defined in a different library to be <code>external</code> so that
the API of <code>Point3</code> doesn&#x27;t change based on what is imported. It would be
particularly bad if two different libraries implemented interfaces with
conflicting names that both affected the API of a single type. As a consequence
of this restriction, you can find all the names of direct members (those
available by <a href="/carbon-lang/design/generics/terminology#simple-member-access">simple member access</a>) of a
type in the definition of that type. The only thing that may be in another
library is an <code>impl</code> of an interface.</p><p>You might also use <code>external impl</code> to implement an interface for a type to avoid
cluttering the API of that type, for example to avoid a name collision. A syntax
for reusing method implementations allows us to do this selectively when needed.
In this case, the <code>external impl</code> may be declared lexically inside the class
scope.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Point4a {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Add[me: Self](b: Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.x = a.x + b.x, .y = a.y + b.y};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  external impl as Vector {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    alias Add = Point4a.Add;  // Syntax TBD</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Scale[me: Self](v: f64) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {.x = a.x * v, .y = a.y * v};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// OR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Point4b {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  external impl as Vector {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Add[me: Self](b: Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {.x = a.x + b.x, .y = a.y + b.y};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Scale[me: Self](v: f64) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {.x = a.x * v, .y = a.y * v};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Add = Vector.Add;  // Syntax TBD</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// OR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Point4c {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Add[me: Self](b: Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.x = a.x + b.x, .y = a.y + b.y};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Point4c as Vector {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Add = Point4c.Add;  // Syntax TBD</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Scale[me: Self](v: f64) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.x = a.x * v, .y = a.y * v};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Being defined lexically inside the class means that implementation is available
to other members defined in the class. For example, it would allow implementing
another interface or method that requires this interface to be implemented.</p><p><strong>Open question:</strong> Do implementations need to be defined lexically inside the
class to get access to private members, or is it sufficient to be defined in the
same library as the class?</p><p><strong>Rejected alternative:</strong> We could allow types to have different APIs in
different files based on explicit configuration in that file. For example, we
could support a declaration that a given interface or a given method of an
interface is &quot;in scope&quot; for a particular type in this file. With that
declaration, the method could be called using
<a href="/carbon-lang/design/generics/terminology#simple-member-access">simple member access</a>. This avoids most
concerns arising from name collisions between interfaces. It has a few downsides
though:</p><ul><li>It increases variability between files, since the same type will have
different APIs depending on these declarations. This makes it harder to
copy-paste code between files.</li><li>It makes reading code harder, since you have to search the file for these
declarations that affect name lookup.</li></ul><p><strong>Comparison with other languages:</strong> Both Rust and Swift support external
implementation.
<a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID277" target="_blank" rel="noopener noreferrer">Swift&#x27;s syntax</a>
does this as an &quot;extension&quot; of the original type. In Rust, all implementations
are external as in
<a href="https://doc.rust-lang.org/rust-by-example/trait.html" target="_blank" rel="noopener noreferrer">this example</a>. Unlike
Swift and Rust, we don&#x27;t allow a type&#x27;s API to be modified outside its
definition. So in Carbon a type&#x27;s API is consistent no matter what is imported,
unlike Swift and Rust.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="qualified-member-names-and-compound-member-access">Qualified member names and compound member access<a class="hash-link" href="#qualified-member-names-and-compound-member-access" title="Direct link to heading">​</a></h3><p>Given a value of type <code>Point3</code> and an interface <code>Vector</code> implemented for that
type, you can access the methods from that interface using a
<a href="/carbon-lang/design/generics/terminology#qualified-member-access-expression">qualified member access expression</a>
whether or not the implementation is done externally with an <code>external impl</code>
declaration. The qualified member access expression writes the member&#x27;s
<em>qualified name</em> in the parentheses of the
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/expressions/member_access.md" target="_blank" rel="noopener noreferrer">compound member access syntax</a>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var p1: Point3 = {.x = 1.0, .y = 2.0};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var p2: Point3 = {.x = 2.0, .y = 4.0};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(p1.(Vector.Scale)(2.0) == p2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(p1.(Vector.Add)(p1) == p2);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that the name in the parens is looked up in the containing scope, not in
the names of members of <code>Point3</code>. So if there was another interface <code>Drawable</code>
with method <code>Draw</code> defined in the <code>Plot</code> package also implemented for <code>Point3</code>,
as in:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package Plot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import Points;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Drawable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Draw[me: Self]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Points.Point3 as Drawable { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>You could access <code>Draw</code> with a qualified name:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import Plot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import Points;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var p: Points.Point3 = {.x = 1.0, .y = 2.0};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">p.(Plot.Drawable.Draw)();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Comparison with other languages:</strong> This is intended to be analogous to, in
C++, adding <code>ClassName::</code> in front of a member name to disambiguate, such as
<a href="https://stackoverflow.com/questions/357307/how-to-call-a-parent-class-function-from-derived-class-function" target="_blank" rel="noopener noreferrer">names defined in both a parent and child class</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="access">Access<a class="hash-link" href="#access" title="Direct link to heading">​</a></h3><p>An <code>impl</code> must be visible to all code that can see both the type and the
interface being implemented:</p><ul><li>If either the type or interface is private to a single file, then since the
only way to define the <code>impl</code> is to use that private name, the <code>impl</code> must
be defined private to that file as well.</li><li>Otherwise, if the type or interface is private but declared in an API file,
then the <code>impl</code> must be declared in the same file so the existence of that
<code>impl</code> is visible to all files in that library.</li><li>Otherwise, the <code>impl</code> must be defined in the public API file of the library,
so it is visible in all places that might use it.</li></ul><p>No access control modifiers are allowed on <code>impl</code> declarations, an <code>impl</code> is
always visible to the intersection of the visibility of all names used in the
declaration of the <code>impl</code>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="generics">Generics<a class="hash-link" href="#generics" title="Direct link to heading">​</a></h2><p>Here is a function that can accept values of any type that has implemented the
<code>Vector</code> interface:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn AddAndScaleGeneric[T:! Vector](a: T, b: T, s: f64) -&gt; T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return a.Add(b).Scale(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var v: Point = AddAndScaleGeneric(a, w, 2.5);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here <code>T</code> is a type whose type is <code>Vector</code>. The <code>:!</code> syntax means that <code>T</code> is a
<em><a href="/carbon-lang/design/generics/terminology#generic-versus-template-parameters">generic parameter</a></em>. That
means it must be known to the caller, but we will only use the information
present in the signature of the function to type check the body of
<code>AddAndScaleGeneric</code>&#x27;s definition. In this case, we know that any value of type
<code>T</code> implements the <code>Vector</code> interface and so has an <code>Add</code> and a <code>Scale</code> method.</p><p><strong>References:</strong> The <code>:!</code> syntax was accepted in
<a href="https://github.com/carbon-language/carbon-lang/pull/676" target="_blank" rel="noopener noreferrer">proposal #676</a>.</p><p>Names are looked up in the body of <code>AddAndScaleGeneric</code> for values of type <code>T</code>
in <code>Vector</code>. This means that <code>AddAndScaleGeneric</code> is interpreted as equivalent
to adding a <code>Vector</code>
<a href="#qualified-member-names-and-compound-member-access">qualification</a> to replace
all simple member accesses of <code>T</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn AddAndScaleGeneric[T:! Vector](a: T, b: T, s: Double) -&gt; T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return a.(Vector.Add)(b).(Vector.Scale)(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>With these qualifications, the function can be type-checked for any <code>T</code>
implementing <code>Vector</code>. This type checking is equivalent to type checking the
function with <code>T</code> set to an <a href="/carbon-lang/design/generics/terminology#archetype">archetype</a> of <code>Vector</code>.
An archetype is a placeholder type considered to satisfy its constraint, which
is <code>Vector</code> in this case, and no more. It acts as the most general type
satisfying the interface. The effect of this is that an archetype of <code>Vector</code>
acts like a <a href="https://en.wikipedia.org/wiki/Subtyping" target="_blank" rel="noopener noreferrer">supertype</a> of any <code>T</code>
implementing <code>Vector</code>.</p><p>For name lookup purposes, an archetype is considered to have
<a href="/carbon-lang/design/generics/terminology#internal-impl">implemented its constraint internally</a>. The only
oddity is that the archetype may have different names for members than specific
types <code>T</code> that implement interfaces from the constraint
<a href="/carbon-lang/design/generics/terminology#external-impl">externally</a>. This difference in names can also
occur for supertypes in C++, for example members in a derived class can hide
members in the base class with the same name, though it is not that common for
it to come up in practice.</p><p>The behavior of calling <code>AddAndScaleGeneric</code> with a value of a specific type
like <code>Point</code> is to set <code>T</code> to <code>Point</code> after all the names have been qualified.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// AddAndScaleGeneric with T = Point</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn AddAndScaleForPoint(a: Point, b: Point, s: Double) -&gt; Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return a.(Vector.Add)(b).(Vector.Scale)(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This qualification gives a consistent interpretation to the body of the function
even when the type supplied by the caller
<a href="/carbon-lang/design/generics/terminology#external-impl">implements the interface externally</a>, as <code>Point2</code>
does:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// AddAndScaleGeneric with T = Point2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn AddAndScaleForPoint2(a: Point2, b: Point2, s: Double) -&gt; Point2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ This works even though `a.Add(b).Scale(s)` wouldn&#x27;t.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return a.(Vector.Add)(b).(Vector.Scale)(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="return-type">Return type<a class="hash-link" href="#return-type" title="Direct link to heading">​</a></h3><p>From the caller&#x27;s perspective, the return type is the result of substituting the
caller&#x27;s values for the generic parameters into the return type expression. So
<code>AddAndScaleGeneric</code> called with <code>Point</code> values returns a <code>Point</code> and called
with <code>Point2</code> values returns a <code>Point2</code>. So looking up a member on the resulting
value will look in <code>Point</code> or <code>Point2</code> rather than <code>Vector</code>.</p><p>This is part of realizing
<a href="/carbon-lang/design/generics/goals#path-from-regular-functions">the goal that generic functions can be used in place of regular functions without changing the return type that callers see</a>.
In this example, <code>AddAndScaleGeneric</code> can be substituted for
<code>AddAndScaleForPoint</code> and <code>AddAndScaleForPoint2</code> without affecting the return
types. This requires the return value to be converted to the type that the
caller expects instead of the erased type used inside the generic function.</p><p>A generic caller of a generic function performs the same substitution process to
determine the return type, but the result may be generic. In this example of
calling a generic from another generic,</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn DoubleThreeTimes[U:! Vector](a: U) -&gt; U {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return AddAndScaleGeneric(a, a, 2.0).Scale(2.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>the return type of <code>AddAndScaleGeneric</code> is found by substituting in the <code>U</code> from
<code>DoubleThreeTimes</code> for the <code>T</code> from <code>AddAndScaleGeneric</code> in the return type
expression of <code>AddAndScaleGeneric</code>. <code>U</code> is an archetype of <code>Vector</code>, and so
implements <code>Vector</code> internally and therefore has a <code>Scale</code> method.</p><p>If <code>U</code> had a more specific type, the return value would have the additional
capabilities of <code>U</code>. For example, given a parameterized type <code>GeneralPoint</code>
implementing <code>Vector</code>, and a function that takes a <code>GeneralPoint</code> and calls
<code>AddAndScaleGeneric</code> with it:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class GeneralPoint(C:! Numeric) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  external impl as Vector { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Get[me: Self](i: i32) -&gt; C;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn CallWithGeneralPoint[C:! Numeric](p: GeneralPoint(C)) -&gt; C {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `AddAndScaleGeneric` returns `T` and in these calls `T` is</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // deduced to be `GeneralPoint(C)`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ❌ Illegal: AddAndScaleGeneric(p, p, 2.0).Scale(2.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //    `GeneralPoint(C)` implements `Vector` externally, and so</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //    does not have a `Scale` method.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `GeneralPoint(C)` has a `Get` method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  AddAndScaleGeneric(p, p, 2.0).Get(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `GeneralPoint(C)` implements `Vector`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //    externally, and so has a `Vector.Scale` method.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //    `Vector.Scale` returns `Self` which is `GeneralPoint(C)`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //    again, and so has a `Get` method.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return AddAndScaleGeneric(p, p, 2.0).(Vector.Scale)(2.0).Get(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The result of the call to <code>AddAndScaleGeneric</code> from <code>CallWithGeneralPoint</code> has
type <code>GeneralPoint(C)</code> and so has a <code>Get</code> method and a <code>Vector.Scale</code> method.
But, in contrast to how <code>DoubleThreeTimes</code> works, since <code>Vector</code> is implemented
externally the return value in this case does not directly have a <code>Scale</code>
method.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="implementation-model">Implementation model<a class="hash-link" href="#implementation-model" title="Direct link to heading">​</a></h3><p>A possible model for generating code for a generic function is to use a
<a href="/carbon-lang/design/generics/terminology#witness-tables">witness table</a> to represent how a type
implements an interface:</p><ul><li><a href="#interfaces">Interfaces</a> are types of witness tables.</li><li><a href="#implementing-interfaces">Impls</a> are witness table values.</li><li>The compiler rewrites functions with an implicit type argument
(<code>fn Foo[InterfaceName:! T](...)</code>) to have an actual argument with type
determined by the interface, and supplied at the callsite using a value
determined by the impl.</li></ul><p>For the example above, <a href="#interfaces">the Vector interface</a> could be thought of
defining a witness table type like:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Vector {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `Self` is the representation type, which is only</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // known at compile time.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var Self:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `fnty` is **placeholder** syntax for a &quot;function type&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // so `Add` is a function that takes two `Self` parameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // and returns a value of type `Self`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var Add: fnty(a: Self, b: Self) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var Scale: fnty(a: Self, v: f64) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The <a href="#implementing-interfaces">impl of Vector for Point</a> would be a value of
this type:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var VectorForPoint: Vector  = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .Self = Point,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `lambda` is **placeholder** syntax for defining a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // function value.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .Add = lambda(a: Point, b: Point) -&gt; Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {.x = a.x + b.x, .y = a.y + b.y};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .Scale = lambda(a: Point, v: f64) -&gt; Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {.x = a.x * v, .y = a.y * v};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Finally we can define a generic function and call it, like
<a href="#generics"><code>AddAndScaleGeneric</code> from the &quot;Generics&quot; section</a> by making the
witness table an explicit argument to the function:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn AddAndScaleGeneric</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (t:! Vector, a: t.Self, b: t.Self, s: f64) -&gt; t.Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return t.Scale(t.Add(a, b), s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Point implements Vector.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var v: Point = AddAndScaleGeneric(VectorForPoint, a, w, 2.5);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The rule is that generic arguments (declared using <code>:!</code>) are passed at compile
time, so the actual value of the <code>t</code> argument here can be used to generate the
code for <code>AddAndScaleGeneric</code>. So <code>AddAndScaleGeneric</code> is using a
<a href="/carbon-lang/design/generics/terminology#static-dispatch-witness-table">static-dispatch witness table</a>.</p><p>Note that this implementation strategy only works for impls that the caller
knows the callee needs.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="interfaces-recap">Interfaces recap<a class="hash-link" href="#interfaces-recap" title="Direct link to heading">​</a></h2><p>Interfaces have a name and a definition.</p><p>The definition of an interface consists of a set of declarations. Each
declaration defines a requirement for any <code>impl</code> that is in turn a capability
that consumers of that <code>impl</code> can rely on. Typically those declarations also
have names, useful for both saying how the <code>impl</code> satisfies the requirement and
accessing the capability.</p><p>Interfaces are <a href="/carbon-lang/design/generics/terminology#nominal-interfaces">&quot;nominal&quot;</a>, which means their
name is significant. So two interfaces with the same body definition but
different names are different, just like two classes with the same definition
but different names are considered different types. For example, lets say we
define another interface, say <code>LegoFish</code>, with the same <code>Add</code> and <code>Scale</code> method
signatures. Implementing <code>Vector</code> would not imply an implementation of
<code>LegoFish</code>, because the <code>impl</code> definition explicitly refers to the name
<code>Vector</code>.</p><p>An interface&#x27;s name may be used in a few different contexts:</p><ul><li>to define <a href="#implementing-interfaces">an <code>impl</code> for a type</a>,</li><li>as a namespace name in
<a href="#qualified-member-names-and-compound-member-access">a qualified name</a>, and</li><li>as a <a href="/carbon-lang/design/generics/terminology#type-of-type">type-of-type</a> for
<a href="#generics">a generic type parameter</a>.</li></ul><p>While interfaces are examples of type-of-types, type-of-types are a more general
concept, for which interfaces are a building block.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="type-of-types">Type-of-types<a class="hash-link" href="#type-of-types" title="Direct link to heading">​</a></h2><p>A <a href="/carbon-lang/design/generics/terminology#type-of-type">type-of-type</a> consists of a set of requirements
and a set of names. Requirements are typically a set of interfaces that a type
must satisfy, though other kinds of requirements are added below. The names are
aliases for qualified names in those interfaces.</p><p>An interface is one particularly simple example of a type-of-type. For example,
<code>Vector</code> as a type-of-type has a set of requirements consisting of the single
interface <code>Vector</code>. Its set of names consists of <code>Add</code> and <code>Scale</code> which are
aliases for the corresponding qualified names inside <code>Vector</code> as a namespace.</p><p>The requirements determine which types are values of a given type-of-type. The
set of names in a type-of-type determines the API of a generic type value and
define the result of <a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/expressions/member_access.md" target="_blank" rel="noopener noreferrer">member access</a>
into the type-of-type.</p><p>This general structure of type-of-types holds not just for interfaces, but
others described in the rest of this document.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="named-constraints">Named constraints<a class="hash-link" href="#named-constraints" title="Direct link to heading">​</a></h2><p>If the interfaces discussed above are the building blocks for type-of-types,
<a href="/carbon-lang/design/generics/terminology#named-constraints">generic named constraints</a> describe how they
may be composed together. Unlike interfaces which are nominal, the name of a
named constraint is not a part of its value. Two different named constraints
with the same definition are equivalent even if they have different names. This
is because types don&#x27;t explicitly specify which named constraints they
implement, types automatically implement any named constraints they can satisfy.</p><p>A named constraint definition can contain interface requirements using <code>impl</code>
declarations and names using <code>alias</code> declarations. Note that this allows us to
declare the aspects of a type-of-type directly.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">constraint VectorLegoFish {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Interface implementation requirements</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Vector;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as LegoFish;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Names</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Scale = Vector.Scale;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias VAdd = Vector.Add;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias LFAdd = LegoFish.Add;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We don&#x27;t expect developers to directly define many named constraints, but other
constructs we do expect them to use will be defined in terms of them. For
example, we can define the Carbon builtin <code>Type</code> as:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">constraint Type { }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>That is, <code>Type</code> is the type-of-type with no requirements (so matches every
type), and defines no names.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn Identity[T:! Type](x: T) -&gt; T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Can accept values of any type. But, since we know nothing about the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // type, we don&#x27;t know about any operations on `x` inside this function.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var i: i32 = Identity(3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var s: String = Identity(&quot;string&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Aside:</strong> We can define <code>auto</code> as syntactic sugar for <code>(template _:! Type)</code>.
This definition allows you to use <code>auto</code> as the type for a local variable whose
type can be statically determined by the compiler. It also allows you to use
<code>auto</code> as the type of a function parameter, to mean &quot;accepts a value of any
type, and this function will be instantiated separately for every different
type.&quot; This is consistent with the
<a href="https://en.cppreference.com/w/cpp/language/function_template#Abbreviated_function_template" target="_blank" rel="noopener noreferrer">use of <code>auto</code> in the C++20 Abbreviated function template feature</a>.</p><p>In general, the declarations in <code>constraint</code> definition match a subset of the
declarations in an <code>interface</code>. Named constraints used with generics, as opposed
to templates, should only include required interfaces and aliases to named
members of those interfaces.</p><p>To declare a named constraint that includes other declarations for use with
template parameters, use the <code>template</code> keyword before <code>constraint</code>. Method,
associated type, and associated function requirements may only be declared
inside a <code>template constraint</code>. Note that a generic constraint ignores the names
of members defined for a type, but a template constraint can depend on them.</p><p>There is an analogy between declarations used in a <code>constraint</code> and in an
<code>interface</code> definition. If an <code>interface</code> <code>I</code> has (non-<code>alias</code>) declarations
<code>X</code>, <code>Y</code>, and <code>Z</code>, like so:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface I {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  X;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Then a type implementing <code>I</code> would have <code>impl as I</code> with definitions for <code>X</code>,
<code>Y</code>, and <code>Z</code>, as in:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ImplementsI {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as I {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    X { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Y { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Z { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>But the corresponding <code>constraint</code> or <code>template constraint</code>, <code>S</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// or template constraint S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  X;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>would match any type with definitions for <code>X</code>, <code>Y</code>, and <code>Z</code> directly:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ImplementsS {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  X { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Y { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Z { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>TODO:</strong> Move the <code>template constraint</code> and <code>auto</code> content to the template
design document, once it exists.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="subtyping-between-type-of-types">Subtyping between type-of-types<a class="hash-link" href="#subtyping-between-type-of-types" title="Direct link to heading">​</a></h3><p>There is a subtyping relationship between type-of-types that allows calls of one
generic function from another as long as it has a subset of the requirements.</p><p>Given a generic type variable <code>T</code> with type-of-type <code>I1</code>, it satisfies a
type-of-type <code>I2</code> as long as the requirements of <code>I1</code> are a superset of the
requirements of <code>I2</code>. This means a value <code>x</code> of type <code>T</code> may be passed to
functions requiring types to satisfy <code>I2</code>, as in this example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Printable { fn Print[me: Self](); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Renderable { fn Draw[me: Self](); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint PrintAndRender {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Printable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Renderable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint JustPrint {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Printable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn PrintIt[T2:! JustPrint](x2: T2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  x2.(Printable.Print)();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn PrintDrawPrint[T1:! PrintAndRender](x1: T1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // x1 implements `Printable` and `Renderable`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  x1.(Printable.Print)();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  x1.(Renderable.Draw)();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Can call `PrintIt` since `T1` satisfies `JustPrint` since</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // it implements `Printable` (in addition to `Renderable`).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  PrintIt(x1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="combining-interfaces-by-anding-type-of-types">Combining interfaces by anding type-of-types<a class="hash-link" href="#combining-interfaces-by-anding-type-of-types" title="Direct link to heading">​</a></h2><p>In order to support functions that require more than one interface to be
implemented, we provide a combination operator on type-of-types, written <code>&amp;</code>.
This operator gives the type-of-type with the union of all the requirements and
the union of the names minus any conflicts.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Printable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Print[me: Self]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Renderable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Center[me: Self]() -&gt; (i32, i32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Draw[me: Self]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `Printable &amp; Renderable` is syntactic sugar for this type-of-type:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Printable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Renderable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Print = Printable.Print;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Center = Renderable.Center;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Draw = Renderable.Draw;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn PrintThenDraw[T:! Printable &amp; Renderable](x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Can use methods of `Printable` or `Renderable` on `x` here.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  x.Print();  // Same as `x.(Printable.Print)();`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  x.Draw();  // Same as `x.(Renderable.Draw)();`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Sprite {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Printable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Print[me: Self]() { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Renderable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Center[me: Self]() -&gt; (i32, i32) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Draw[me: Self]() { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var s: Sprite = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PrintThenDraw(s);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Any conflicting names between the two types are replaced with a name that is an
error to use.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Renderable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Center[me: Self]() -&gt; (i32, i32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Draw[me: Self]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface EndOfGame {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Draw[me: Self]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Winner[me: Self](player: i32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `Renderable &amp; EndOfGame` is syntactic sugar for this type-of-type:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Renderable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as EndOfGame;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Center = Renderable.Center;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Open question: `forbidden`, `invalid`, or something else?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  forbidden Draw</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    message &quot;Ambiguous, use either `(Renderable.Draw)` or `(EndOfGame.Draw)`.&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Winner = EndOfGame.Winner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Conflicts can be resolved at the call site using a
<a href="#qualified-member-names-and-compound-member-access">qualified member access expression</a>,
or by defining a named constraint explicitly and renaming the methods:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">constraint RenderableAndEndOfGame {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Renderable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as EndOfGame;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Center = Renderable.Center;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias RenderableDraw = Renderable.Draw;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias TieGame = EndOfGame.Draw;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Winner = EndOfGame.Winner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn RenderTieGame[T:! RenderableAndEndOfGame](x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Calls Renderable.Draw()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  x.RenderableDraw();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Calls EndOfGame.Draw()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  x.TieGame();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Reserving the name when there is a conflict is part of resolving what happens
when you combine more than two type-of-types. If <code>x</code> is forbidden in <code>A</code>, it is
forbidden in <code>A &amp; B</code>, whether or not <code>B</code> defines the name <code>x</code>. This makes <code>&amp;</code>
associative and commutative, and so it is well defined on sets of interfaces, or
other type-of-types, independent of order.</p><p>Note that we do <em>not</em> consider two type-of-types using the same name to mean the
same thing to be a conflict. For example, combining a type-of-type with itself
gives itself, <code>MyTypeOfType &amp; MyTypeOfType == MyTypeOfType</code>. Also, given two
<a href="#interface-extension">interface extensions</a> of a common base interface, the sum
should not conflict on any names in the common base.</p><p><strong>Rejected alternative:</strong> Instead of using <code>&amp;</code> as the combining operator, we
considered using <code>+</code>,
<a href="https://rust-lang.github.io/rfcs/0087-trait-bounds-with-plus.html" target="_blank" rel="noopener noreferrer">like Rust</a>.
See <a href="https://github.com/carbon-language/carbon-lang/issues/531" target="_blank" rel="noopener noreferrer">#531</a> for the
discussion.</p><p><strong>Future work:</strong> We may want to define another operator on type-of-types for
adding requirements to a type-of-type without affecting the names, and so avoid
the possibility of name conflicts. Note this means the operation is not
commutative. If we call this operator <code>[&amp;]</code>, then <code>A [&amp;] B</code> has the names of <code>A</code>
and <code>B [&amp;] A</code> has the names of <code>B</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// `Printable [&amp;] Renderable` is syntactic sugar for this type-of-type:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Printable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Renderable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Print = Printable.Print;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `Renderable [&amp;] EndOfGame` is syntactic sugar for this type-of-type:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Renderable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as EndOfGame;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Center = Renderable.Center;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Draw = Renderable.Draw;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that all three expressions <code>A &amp; B</code>, <code>A [&amp;] B</code>, and <code>B [&amp;] A</code> have the same
requirements, and so you would be able to switch a function declaration between
them without affecting callers.</p><p>Nothing in this design depends on the <code>[&amp;]</code> operator, and having both <code>&amp;</code> and
<code>[&amp;]</code> might be confusing for users, so it makes sense to postpone implementing
<code>[&amp;]</code> until we have a demonstrated need. The <code>[&amp;]</code> operator seems most useful
for adding requirements for interfaces used for
<a href="#operator-overloading">operator overloading</a>, where merely implementing the
interface is enough to be able to use the operator to access the functionality.</p><p><strong>Alternatives considered:</strong> See
<a href="https://docs.google.com/document/d/1u_i_s31OMI_apPur7WmVxcYq6MUXsG3oCiKwH893GRI/edit?usp=sharing&amp;resourcekey=0-0lzSNebBMtUBi4lStL825g" target="_blank" rel="noopener noreferrer">Carbon: Access to interface methods</a>.</p><p><strong>Comparison with other languages:</strong> This <code>&amp;</code> operation on interfaces works very
similarly to Rust&#x27;s <code>+</code> operation, with the main difference being how you
<a href="https://doc.rust-lang.org/rust-by-example/trait/disambiguating.html" target="_blank" rel="noopener noreferrer">qualify names when there is a conflict</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="interface-requiring-other-interfaces">Interface requiring other interfaces<a class="hash-link" href="#interface-requiring-other-interfaces" title="Direct link to heading">​</a></h2><p>Some interfaces will depend on other interfaces being implemented for the same
type. For example, in C++,
<a href="https://en.cppreference.com/w/cpp/named_req/Container#Other_requirements" target="_blank" rel="noopener noreferrer">the <code>Container</code> concept</a>
requires all containers to also satisfy the requirements of
<code>DefaultConstructible</code>, <code>CopyConstructible</code>, <code>EqualityComparable</code>, and
<code>Swappable</code>. This is already a capability for
<a href="#type-of-types">type-of-types in general</a>. For consistency we will use the same
semantics and syntax as we do for <a href="#named-constraints">named constraints</a>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Equatable { fn Equals[me: Self](rhs: Self) -&gt; bool; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Iterable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Advance[addr me: Self*]() -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Equatable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def DoAdvanceAndEquals[T:! Iterable](x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `x` has type `T` that implements `Iterable`, and so has `Advance`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  x.Advance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `Iterable` requires an implementation of `Equatable`,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // so `T` also implements `Equatable`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  x.(Equatable.Equals)(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Iota {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Iterable { fn Advance[me: Self]() { ... } }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Equatable { fn Equals[me: Self](rhs: Self) -&gt; bool { ... } }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var x: Iota;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DoAdvanceAndEquals(x);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Like with named constraints, an interface implementation requirement doesn&#x27;t by
itself add any names to the interface, but again those can be added with <code>alias</code>
declarations:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Hashable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Hash[me: Self]() -&gt; u64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Equatable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Equals = Equatable.Equals;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def DoHashAndEquals[T:! Hashable](x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Now both `Hash` and `Equals` are available directly:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  x.Hash();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  x.Equals(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Comparison with other languages:</strong>
<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait" target="_blank" rel="noopener noreferrer">This feature is called &quot;Supertraits&quot; in Rust</a>.</p><p><strong>Note:</strong> The design for this feature is continued in
<a href="#interface-requiring-other-interfaces-revisited">a later section</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="interface-extension">Interface extension<a class="hash-link" href="#interface-extension" title="Direct link to heading">​</a></h3><p>When implementing an interface, we should allow implementing the aliased names
as well. In the case of <code>Hashable</code> above, this includes all the members of
<code>Equatable</code>, obviating the need to implement <code>Equatable</code> itself:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Hashable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Hash[me: Self]() -&gt; u64 { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Equals[me: Self](rhs: Self) -&gt; bool { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var y: Song;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DoHashAndEquals(y);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This allows us to say that <code>Hashable</code>
<a href="/carbon-lang/design/generics/terminology#extending-an-interface">&quot;extends&quot;</a> <code>Equatable</code>, with some
benefits:</p><ul><li>This allows <code>Equatable</code> to be an implementation detail of <code>Hashable</code>.</li><li>This allows types implementing <code>Hashable</code> to implement all of its API in one
place.</li><li>This reduces the boilerplate for types implementing <code>Hashable</code>.</li></ul><p>We expect this concept to be common enough to warrant dedicated syntax:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Equatable { fn Equals[me: Self](rhs: Self) -&gt; bool; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Hashable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Equatable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Hash[me: Self]() -&gt; u64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// is equivalent to the definition of Hashable from before:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// interface Hashable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//   impl as Equatable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//   alias Equals = Equatable.Equals;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//   fn Hash[me: Self]() -&gt; u64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>No names in <code>Hashable</code> are allowed to conflict with names in <code>Equatable</code> (unless
those names are marked as <code>upcoming</code> or <code>deprecated</code> as in
<a href="#evolution">evolution future work</a>). Hopefully this won&#x27;t be a problem in
practice, since interface extension is a very closely coupled relationship, but
this may be something we will have to revisit in the future.</p><p>Examples:</p><ul><li>The C++
<a href="https://www.boost.org/doc/libs/1_74_0/libs/graph/doc/" target="_blank" rel="noopener noreferrer">Boost.Graph library</a><a href="https://www.boost.org/doc/libs/1_74_0/libs/graph/doc/graph_concepts.html#fig:graph-concepts" target="_blank" rel="noopener noreferrer">graph concepts</a>
has many refining relationships between concepts.
<a href="https://docs.google.com/document/d/1xk0GLtpBl2OOnf3F_6Z-A3DtTt-r7wdOZ5wPipYUSO0/edit?usp=sharing&amp;resourcekey=0-mBSmwn6b6jwbLaQw2WG6OA" target="_blank" rel="noopener noreferrer">Carbon generics use case: graph library</a>
shows how those concepts might be translated into Carbon interfaces.</li><li>The <a href="https://en.cppreference.com/w/cpp/named_req" target="_blank" rel="noopener noreferrer">C++ concepts</a> for
containers, iterators, and concurrency include many requirement
relationships.</li><li>Swift protocols, such as
<a href="https://developer.apple.com/documentation/swift/collection" target="_blank" rel="noopener noreferrer">Collection</a>.</li></ul><p>To write an interface extending multiple interfaces, use multiple <code>extends</code>
declarations. For example, the
<a href="https://developer.apple.com/documentation/swift/binaryinteger" target="_blank" rel="noopener noreferrer"><code>BinaryInteger</code> protocol in Swift</a>
inherits from <code>CustomStringConvertible</code>, <code>Hashable</code>, <code>Numeric</code>, and <code>Stridable</code>.
The <a href="https://swiftdoc.org/v5.1/protocol/setalgebra/" target="_blank" rel="noopener noreferrer"><code>SetAlgebra</code> protocol</a>
extends <code>Equatable</code> and <code>ExpressibleByArrayLiteral</code>, which would be declared in
Carbon:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface SetAlgebra {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Equatable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends ExpressibleByArrayLiteral;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Alternative considered:</strong> The <code>extends</code> declarations are in the body of the
<code>interface</code> definition instead of the header so we can use
<a href="#associated-types">associated types (defined below)</a> also defined in the body
in parameters or constraints of the interface being extended.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// A type can implement `ConvertibleTo` many times, using</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// different values of `T`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface ConvertibleTo(T:! Type) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// A type can only implement `PreferredConversion` once.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface PreferredConversion {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let AssociatedType:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends ConvertibleTo(AssociatedType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="extends-and-impl-with-named-constraints"><code>extends</code> and <code>impl</code> with named constraints<a class="hash-link" href="#extends-and-impl-with-named-constraints" title="Direct link to heading">​</a></h4><p>The <code>extends</code> declaration makes sense with the same meaning inside a
<a href="#named-constraints"><code>constraint</code></a> definition, and so is also supported.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Media {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Play[me: Self]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Job {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Run[me: Self]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint Combined {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Media;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Job;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This definition of <code>Combined</code> is equivalent to requiring both the <code>Media</code> and
<code>Job</code> interfaces being implemented, and aliases their methods.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Equivalent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint Combined {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Media;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Play = Media.Play;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Job;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Run = Job.Run;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Notice how <code>Combined</code> has aliases for all the methods in the interfaces it
requires. That condition is sufficient to allow a type to <code>impl</code> the named
constraint:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Combined {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Play[me: Self]() { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Run[me: Self]() { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is equivalent to implementing the required interfaces directly:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Media {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Play[me: Self]() { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Job {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Run[me: Self]() { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is just like when you get an implementation of <code>Equatable</code> by implementing
<code>Hashable</code> when <code>Hashable</code> extends <code>Equatable</code>. This provides a tool useful for
<a href="#evolution">evolution</a>.</p><p>Conversely, an <code>interface</code> can extend a <code>constraint</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface MovieCodec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Combined;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Load[addr me: Self*](filename: String);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This gives <code>MovieCodec</code> the same requirements and names as <code>Combined</code>, and so is
equivalent to:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface MovieCodec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Media;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Play = Media.Play;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Job;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias Run = Job.Run;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Load[addr me: Self*](filename: String);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="diamond-dependency-issue">Diamond dependency issue<a class="hash-link" href="#diamond-dependency-issue" title="Direct link to heading">​</a></h4><p>Consider this set of interfaces, simplified from
<a href="https://docs.google.com/document/d/1xk0GLtpBl2OOnf3F_6Z-A3DtTt-r7wdOZ5wPipYUSO0/edit?resourcekey=0-mBSmwn6b6jwbLaQw2WG6OA#" target="_blank" rel="noopener noreferrer">this example generic graph library doc</a>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Graph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Source[addr me: Self*](e: EdgeDescriptor) -&gt; VertexDescriptor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Target[addr me: Self*](e: EdgeDescriptor) -&gt; VertexDescriptor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface IncidenceGraph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Graph;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn OutEdges[addr me: Self*](u: VertexDescriptor)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt; (EdgeIterator, EdgeIterator);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface EdgeListGraph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Graph;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Edges[addr me: Self*]() -&gt; (EdgeIterator, EdgeIterator);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We need to specify what happens when a graph type implements both
<code>IncidenceGraph</code> and <code>EdgeListGraph</code>, since both interfaces extend the <code>Graph</code>
interface.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyEdgeListIncidenceGraph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as IncidenceGraph { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as EdgeListGraph { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The rule is that we need one definition of each method of <code>Graph</code>. Each method
though could be defined in the <code>impl</code> block of <code>IncidenceGraph</code>,
<code>EdgeListGraph</code>, or <code>Graph</code>. These would all be valid:</p><ul><li><p><code>IncidenceGraph</code> implements all methods of <code>Graph</code>, <code>EdgeListGraph</code>
implements none of them.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyEdgeListIncidenceGraph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as IncidenceGraph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Source[me: Self](e: EdgeDescriptor) -&gt; VertexDescriptor { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Target[me: Self](e: EdgeDescriptor) -&gt; VertexDescriptor { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn OutEdges[addr me: Self*](u: VertexDescriptor)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -&gt; (EdgeIterator, EdgeIterator) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as EdgeListGraph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Edges[addr me: Self*]() -&gt; (EdgeIterator, EdgeIterator) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p><code>IncidenceGraph</code> and <code>EdgeListGraph</code> implement all methods of <code>Graph</code>
between them, but with no overlap.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyEdgeListIncidenceGraph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as IncidenceGraph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Source[me: Self](e: EdgeDescriptor) -&gt; VertexDescriptor { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn OutEdges[addr me: Self*](u: VertexDescriptor)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -&gt; (EdgeIterator, EdgeIterator) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as EdgeListGraph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Target[me: Self](e: EdgeDescriptor) -&gt; VertexDescriptor { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Edges[addr me: Self*]() -&gt; (EdgeIterator, EdgeIterator) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>Explicitly implementing <code>Graph</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyEdgeListIncidenceGraph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Graph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Source[me: Self](e: EdgeDescriptor) -&gt; VertexDescriptor { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Target[me: Self](e: EdgeDescriptor) -&gt; VertexDescriptor { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as IncidenceGraph { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as EdgeListGraph { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>Implementing <code>Graph</code> externally.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyEdgeListIncidenceGraph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as IncidenceGraph { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as EdgeListGraph { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl MyEdgeListIncidenceGraph as Graph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Source[me: Self](e: EdgeDescriptor) -&gt; VertexDescriptor { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Target[me: Self](e: EdgeDescriptor) -&gt; VertexDescriptor { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ul><p>This last point means that there are situations where we can only detect a
missing method definition by the end of the file. This doesn&#x27;t delay other
aspects of semantic checking, which will just assume that these methods will
eventually be provided.</p><p><strong>Open question:</strong> We could require that the <code>external impl</code> of the required
interface be declared lexically in the class scope in this case. That would
allow earlier detection of missing definitions.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="use-case-overload-resolution">Use case: overload resolution<a class="hash-link" href="#use-case-overload-resolution" title="Direct link to heading">​</a></h3><p>Implementing an extended interface is an example of a more specific match for
<a href="#lookup-resolution-and-specialization">lookup resolution</a>. For example, this
could be used to provide different implementations of an algorithm depending on
the capabilities of the iterator being passed in:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface ForwardIntIterator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Advance[addr me: Self*]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Get[me: Self]() -&gt; i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface BidirectionalIntIterator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends ForwardIntIterator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Back[addr me: Self*]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface RandomAccessIntIterator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends BidirectionalIntIterator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Skip[addr me: Self*](offset: i32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Difference[me: Self](rhs: Self) -&gt; i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn SearchInSortedList[IterT:! ForwardIntIterator]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (begin: IterT, end: IterT, needle: i32) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ... // does linear search</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Will prefer the following overload when it matches</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// since it is more specific.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn SearchInSortedList[IterT:! RandomAccessIntIterator]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (begin: IterT, end: IterT, needle: i32) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ... // does binary search</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This would be an example of the more general rule that an interface <code>A</code>
requiring an implementation of interface <code>B</code> means <code>A</code> is more specific than
<code>B</code>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="adapting-types">Adapting types<a class="hash-link" href="#adapting-types" title="Direct link to heading">​</a></h2><p>Since interfaces may only be implemented for a type once, and we limit where
implementations may be added to a type, there is a need to allow the user to
switch the type of a value to access different interface implementations. Carbon
therefore provides a way to create new types
<a href="/carbon-lang/design/generics/terminology#compatible-types">compatible with</a> existing types with different
APIs, in particular with different interface implementations, by
<a href="/carbon-lang/design/generics/terminology#adapting-a-type">adapting</a> them:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Printable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Print[me: Self]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Comparable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Less[me: Self](rhs: Self) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Printable { fn Print[me: Self]() { ... } }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter SongByTitle for Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Comparable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Less[me: Self](rhs: Self) -&gt; bool { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter FormattedSong for Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Printable { fn Print[me: Self]() { ... } }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter FormattedSongByTitle for Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Printable = FormattedSong;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Comparable = SongByTitle;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This allows developers to provide implementations of new interfaces (as in
<code>SongByTitle</code>), provide different implementations of the same interface (as in
<code>FormattedSong</code>), or mix and match implementations from other compatible types
(as in <code>FormattedSongByTitle</code>). The rules are:</p><ul><li>You can add any declaration that you could add to a class except for
declarations that would change the representation of the type. This means
you can add methods, functions, interface implementations, and aliases, but
not fields, base classes, or virtual functions.</li><li>The adapted type is compatible with the original type, and that relationship
is an equivalence class, so all of <code>Song</code>, <code>SongByTitle</code>, <code>FormattedSong</code>,
and <code>FormattedSongByTitle</code> end up compatible with each other.</li><li>Since adapted types are compatible with the original type, you may
explicitly cast between them, but there is no implicit conversion between
these types.</li></ul><p>Inside an adapter, the <code>Self</code> type matches the adapter. Members of the original
type may be accessed either by a cast:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">adapter SongByTitle for Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Comparable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Less[me: Self](rhs: Self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return (me as Song).Title() &lt; (rhs as Song).Title();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>or using a qualified member access expression:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">adapter SongByTitle for Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Comparable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Less[me: Self](rhs: Self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return me.(Song.Title)() &lt; rhs.(Song.Title)();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Comparison with other languages:</strong> This matches the Rust idiom called
&quot;newtype&quot;, which is used to implement traits on types while avoiding coherence
problems, see
<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types" target="_blank" rel="noopener noreferrer">here</a>
and
<a href="https://github.com/Ixrec/rust-orphan-rules#user-content-why-are-the-orphan-rules-controversial" target="_blank" rel="noopener noreferrer">here</a>.
Rust&#x27;s mechanism doesn&#x27;t directly support reusing implementations, though some
of that is provided by macros defined in libraries. Haskell has a
<a href="https://wiki.haskell.org/Newtype" target="_blank" rel="noopener noreferrer"><code>newtype</code> feature</a> as well. Haskell&#x27;s feature
doesn&#x27;t directly support reusing implementations either, but the most popular
compiler provides it as
<a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/newtype_deriving.html" target="_blank" rel="noopener noreferrer">an extension</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="adapter-compatibility">Adapter compatibility<a class="hash-link" href="#adapter-compatibility" title="Direct link to heading">​</a></h3><p>Consider a type with a generic type parameter, like a hash map:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Hashable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class HashMap(KeyT:! Hashable, ValueT:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Find[me:Self](key: KeyT) -&gt; Optional(ValueT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A user of this type will provide specific values for the key and value types:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Hashable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var play_count: HashMap(Song, i32) = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var thriller_count: Optional(i32) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    play_count.Find(Song(&quot;Thriller&quot;));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Since the <code>Find</code> function is generic, it can only use the capabilities that
<code>HashMap</code> requires of <code>KeyT</code> and <code>ValueT</code>. This allows us to evaluate when we
can convert between two different arguments to a parameterized type. Consider
two adapters of <code>Song</code> that implement <code>Hashable</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">adapter PlayableSong for Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Hashable = Song;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Media { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter SongHashedByTitle for Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Hashable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>Song</code> and <code>PlayableSong</code> have the same implementation of <code>Hashable</code> in addition
to using the same data representation. This means that it is safe to convert
between <code>HashMap(Song, i32)</code> and <code>HashMap(PlayableSong, i32)</code>, because the
implementation of all the methods will use the same implementation of the
<code>Hashable</code> interface. Carbon permits this conversion with an explicit cast.</p><p>On the other hand, <code>SongHashedByTitle</code> has a different implementation of
<code>Hashable</code> than <code>Song</code>. So even though <code>Song</code> and <code>SongHashedByTitle</code> are
compatible types, <code>HashMap(Song, i32)</code> and <code>HashMap(SongHashedByTitle, i32)</code> are
incompatible. This is important because we know that in practice the invariants
of a <code>HashMap</code> implementation rely on the hashing function staying the same.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="extending-adapter">Extending adapter<a class="hash-link" href="#extending-adapter" title="Direct link to heading">​</a></h3><p>Frequently we expect that the adapter type will want to preserve most or all of
the API of the original type. The two most common cases expected are adding and
replacing an interface implementation. Users would indicate that an adapter
starts from the original type&#x27;s existing API by using the <code>extends</code> keyword
instead of <code>for</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Hashable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Printable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter SongByArtist extends Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Add an implementation of a new interface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Comparable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Replace an existing implementation of an interface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // with an alternative.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Hashable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The resulting type <code>SongByArtist</code> would:</p><ul><li>implement <code>Comparable</code>, unlike <code>Song</code>,</li><li>implement <code>Hashable</code>, but differently than <code>Song</code>, and</li><li>implement <code>Printable</code>, inherited from <code>Song</code>.</li></ul><p>Unlike the similar <code>class B extends A</code> notation, <code>adapter B extends A</code> is
permitted even if <code>A</code> is a final class. Also, there is no implicit conversion
from <code>B</code> to <code>A</code>, matching <code>adapter</code>...<code>for</code> but unlike class extension.</p><p>To avoid or resolve name conflicts between interfaces, an <code>impl</code> may be declared
<a href="#external-impl"><code>external</code></a>. The names in that interface may then be pulled in
individually or renamed using <code>alias</code> declarations.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">adapter SongRenderToPrintDriver extends Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Add a new `Print()` member function.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Print[me: Self]() { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Avoid name conflict with new `Print` function by making</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // the implementation of the `Printable` interface external.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  external impl as Printable = Song;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Make the `Print` function from `Printable` available</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // under the name `PrintToScreen`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alias PrintToScreen = Printable.Print;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="use-case-using-independent-libraries-together">Use case: Using independent libraries together<a class="hash-link" href="#use-case-using-independent-libraries-together" title="Direct link to heading">​</a></h3><p>Imagine we have two packages that are developed independently. Package
<code>CompareLib</code> defines an interface <code>CompareLib.Comparable</code> and a generic
algorithm <code>CompareLib.Sort</code> that operates on types that implement
<code>CompareLib.Comparable</code>. Package <code>SongLib</code> defines a type <code>SongLib.Song</code>.
Neither has a dependency on the other, so neither package defines an
implementation for <code>CompareLib.Comparable</code> for type <code>SongLib.Song</code>. A user that
wants to pass a value of type <code>SongLib.Song</code> to <code>CompareLib.Sort</code> has to define
an adapter that provides an implementation of <code>CompareLib.Comparable</code> for
<code>SongLib.Song</code>. This adapter will probably use the
<a href="#extending-adapter"><code>extends</code> facility of adapters</a> to preserve the
<code>SongLib.Song</code> API.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import CompareLib;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import SongLib;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter Song extends SongLib.Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as CompareLib.Comparable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Or, to keep the names from CompareLib.Comparable out of Song&#x27;s API:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter Song extends SongLib.Song { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Song as CompareLib.Comparable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Or, equivalently:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter Song extends SongLib.Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  external impl as CompareLib.Comparable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The caller can either convert <code>SongLib.Song</code> values to <code>Song</code> when calling
<code>CompareLib.Sort</code> or just start with <code>Song</code> values in the first place.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var lib_song: SongLib.Song = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CompareLib.Sort((lib_song as Song,));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var song: Song = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CompareLib.Sort((song,));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="use-case-defining-an-impl-for-use-by-other-types">Use case: Defining an impl for use by other types<a class="hash-link" href="#use-case-defining-an-impl-for-use-by-other-types" title="Direct link to heading">​</a></h3><p>Let&#x27;s say we want to provide a possible implementation of an interface for use
by types for which that implementation would be appropriate. We can do that by
defining an adapter implementing the interface that is parameterized on the type
it is adapting. That impl may then be pulled in using the <code>impl as ... = ...;</code>
syntax.</p><p>For example, given an interface <code>Comparable</code> for deciding which value is
smaller:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Comparable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Less[me: Self](rhs: Self) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We might define an adapter that implements <code>Comparable</code> for types that define
another interface <code>Difference</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Difference {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Sub[me:Self](rhs: Self) -&gt; i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter ComparableFromDifference(T:! Difference) for T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Comparable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Less[me: Self](rhs: Self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return (me as T).Sub(rhs) &lt; 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class IntWrapper {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Difference {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Sub[me: Self](rhs: Self) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return left.x - right.x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Comparable = ComparableFromDifferenceFn(IntWrapper);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>TODO:</strong> If we support function types, we could potentially pass a function to
use to the adapter instead:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">adapter ComparableFromDifferenceFn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (T:! Type, Difference:! fnty(T, T)-&gt;i32) for T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Comparable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Less[me: Self](rhs: Self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return Difference(me, rhs) &lt; 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class IntWrapper {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var x: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Difference(left: Self, right: Self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return left.x - right.x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Comparable =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ComparableFromDifferenceFn(IntWrapper, Difference);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="use-case-private-impl">Use case: Private impl<a class="hash-link" href="#use-case-private-impl" title="Direct link to heading">​</a></h3><p>Adapter types can be used when a library publicly exposes a type, but only wants
to say that type implements an interface as a private detail internal to the
implementation of the type. In that case, instead of implementing the interface
for the public type, the library can create a private adapter for that type and
implement the interface on that instead. Any member of the class can cast its
<code>me</code> parameter to the adapter type when it wants to make use of the private
impl.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Public, in API file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Complex64 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn CloserToOrigin[me: Self](them: Self) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Private</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter ByReal extends Complex64 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Complex numbers are not generally comparable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // but this comparison function is useful for some</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // method implementations.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Comparable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Less[me: Self](that: Self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return me.Real() &lt; that.Real();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn Complex64.CloserToOrigin[me: Self](them: Self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var me_mag: ByReal = me * me.Conj() as ByReal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var them_mag: ByReal = them * them.Conj() as ByReal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return me_mag.Less(them_mag);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="use-case-accessing-external-names">Use case: Accessing external names<a class="hash-link" href="#use-case-accessing-external-names" title="Direct link to heading">​</a></h3><p>Consider a case where a function will call several functions from an interface
that is <a href="/carbon-lang/design/generics/terminology#external-impl">implemented externally</a> for a type.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface DrawingContext {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn SetPen[me: Self](...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn SetFill[me: Self](...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn DrawRectangle[me: Self](...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn DrawLine[me: Self](...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Window as DrawingContext { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>An adapter can make that much more convenient by making a compatible type where
the interface is <a href="/carbon-lang/design/generics/terminology#internal-impl">implemented internally</a>. This
avoids having to <a href="/carbon-lang/design/generics/terminology#qualified-member-access-expression">qualify</a>
each call to methods in the interface.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">adapter DrawInWindow for Window {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as DrawingContext = Window;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn Render(w: Window) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let d: DrawInWindow = w as DrawInWindow;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  d.SetPen(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  d.SetFill(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  d.DrawRectangle(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="adapter-with-stricter-invariants">Adapter with stricter invariants<a class="hash-link" href="#adapter-with-stricter-invariants" title="Direct link to heading">​</a></h3><p><strong>Future work:</strong> Rust also uses the newtype idiom to create types with
additional invariants or other information encoded in the type
(<a href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html" target="_blank" rel="noopener noreferrer">1</a>,
<a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction" target="_blank" rel="noopener noreferrer">2</a>,
<a href="https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html" target="_blank" rel="noopener noreferrer">3</a>).
This is used to record in the type system that some data has passed validation
checks, like <code>ValidDate</code> with the same data layout as <code>Date</code>. Or to record the
units associated with a value, such as <code>Seconds</code> versus <code>Milliseconds</code> or <code>Feet</code>
versus <code>Meters</code>. We should have some way of restricting the casts between a type
and an adapter to address this use case.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="associated-constants">Associated constants<a class="hash-link" href="#associated-constants" title="Direct link to heading">​</a></h2><p>In addition to associated methods, we allow other kinds of
<a href="/carbon-lang/design/generics/terminology#associated-entity">associated entities</a>. For consistency, we use
the same syntax to describe a constant in an interface as in a type without
assigning a value. As constants, they are declared using the <code>let</code> introducer.
For example, a fixed-dimensional point type could have the dimension as an
associated constant.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface NSpacePoint {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let N:! i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // The following require: 0 &lt;= i &lt; N.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Get[addr me: Self*](i: i32) -&gt; f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Set[addr me: Self*](i: i32, value: f64);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Associated constants may be used in signatures:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn SetAll[addr me: Self*](value: Array(f64, N));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>An implementation of an interface specifies values for associated constants with
a <a href="#where-constraints"><code>where</code> clause</a>. For example, implementations of
<code>NSpacePoint</code> for different types might have different values for <code>N</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Point2D {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as NSpacePoint where .N = 2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Get[addr me: Self*](i: i32) -&gt; f64 { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Set[addr me: Self*](i: i32, value: f64) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn SetAll[addr me: Self*](value: Array(f64, 2)) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Point3D {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as NSpacePoint where .N = 3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Get[addr me: Self*](i: i32) -&gt; f64 { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Set[addr me: Self*](i: i32, value: f64) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn SetAll[addr me: Self*](value: Array(f64, 3)) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Multiple assignments to associated constants may be joined using the <code>and</code>
keyword. The list of assignments is subject to two restrictions:</p><ul><li>An implementation of an interface cannot specify a value for a
<a href="#final-members"><code>final</code></a> associated constant.</li><li>If an associated constant doesn&#x27;t have a
<a href="#interface-defaults">default value</a>, every implementation must specify its
value.</li></ul><p>These values may be accessed as members of the type:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Assert(Point2D.N == 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(Point3D.N == 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn PrintPoint[PointT:! NSpacePoint](p: PointT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (var i: i32 = 0; i &lt; PointT.N; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (i &gt; 0) { Print(&quot;, &quot;); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Print(p.Get(i));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn ExtractPoint[PointT:! NSpacePoint](</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p: PointT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dest: Array(f64, PointT.N)*) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (var i: i32 = 0; i &lt; PointT.N; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (*dest)[i] = p.Get(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Comparison with other languages:</strong> This feature is also called
<a href="https://doc.rust-lang.org/reference/items/associated-items.html#associated-constants" target="_blank" rel="noopener noreferrer">associated constants in Rust</a>.</p><p><strong>Aside:</strong> In general, the use of <code>:!</code> here means these <code>let</code> declarations will
only have compile-time and not runtime storage associated with them.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="associated-class-functions">Associated class functions<a class="hash-link" href="#associated-class-functions" title="Direct link to heading">​</a></h3><p>To be consistent with normal
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/classes.md#class-functions" target="_blank" rel="noopener noreferrer">class function</a> declaration syntax,
associated class functions are written using a <code>fn</code> declaration:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface DeserializeFromString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Deserialize(serialized: String) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class MySerializableType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var i: i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as DeserializeFromString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Deserialize(serialized: String) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return (.i = StringToInt(serialized));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var x: MySerializableType = MySerializableType.Deserialize(&quot;3&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn Deserialize(T:! DeserializeFromString, serialized: String) -&gt; T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return T.Deserialize(serialized);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var y: MySerializableType = Deserialize(MySerializableType, &quot;4&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is instead of declaring an associated constant using <code>let</code> with a function
type.</p><p>Together associated methods and associated class functions are called
<em>associated functions</em>, much like together methods and class functions are
called <a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/classes.md#member-functions" target="_blank" rel="noopener noreferrer">member functions</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="associated-types">Associated types<a class="hash-link" href="#associated-types" title="Direct link to heading">​</a></h2><p>Associated types are <a href="/carbon-lang/design/generics/terminology#associated-entity">associated entities</a>
that happen to be types. These are particularly interesting since they can be
used in the signatures of associated methods or functions, to allow the
signatures of methods to vary from implementation to implementation. We already
have one example of this: the <code>Self</code> type discussed
<a href="#interfaces">in the &quot;Interfaces&quot; section</a>. For other cases, we can say that the
interface declares that each implementation will provide a type under a specific
name. For example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface StackAssociatedType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let ElementType:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Push[addr me: Self*](value: ElementType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Pop[addr me: Self*]() -&gt; ElementType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn IsEmpty[addr me: Self*]() -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here we have an interface called <code>StackAssociatedType</code> which defines two
methods, <code>Push</code> and <code>Pop</code>. The signatures of those two methods declare them as
accepting or returning values with the type <code>ElementType</code>, which any implementer
of <code>StackAssociatedType</code> must also define. For example, maybe <code>DynamicArray</code>
implements <code>StackAssociatedType</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class DynamicArray(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  class IteratorType { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Begin[addr me: Self*]() -&gt; IteratorType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn End[addr me: Self*]() -&gt; IteratorType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Insert[addr me: Self*](pos: IteratorType, value: T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Remove[addr me: Self*](pos: IteratorType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Set the associated type `ElementType` to `T`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as StackAssociatedType where .ElementType = T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Push[addr me: Self*](value: ElementType) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      me-&gt;Insert(me-&gt;End(), value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Pop[addr me: Self*]() -&gt; ElementType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      var pos: IteratorType = me-&gt;End();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Assert(pos != me-&gt;Begin());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      --pos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      returned var ret: ElementType = *pos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      me-&gt;Remove(pos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return var;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn IsEmpty[addr me: Self*]() -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return me-&gt;Begin() == me-&gt;End();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Alternatives considered:</strong> See
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//proposals/p0731.md#syntax-for-associated-constants" target="_blank" rel="noopener noreferrer">other syntax options considered in #731 for specifying associated types</a>.
In particular, it was deemed that
<a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID190" target="_blank" rel="noopener noreferrer">Swift&#x27;s approach of inferring the associated type from method signatures in the impl</a>
was unneeded complexity.</p><p>The definition of the <code>StackAssociatedType</code> is sufficient for writing a generic
function that operates on anything implementing that interface, for example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn PeekAtTopOfStack[StackType:! StackAssociatedType](s: StackType*)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt; StackType.ElementType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var top: StackType.ElementType = s-&gt;Pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  s-&gt;Push(top);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return top;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Inside the generic function <code>PeekAtTopOfStack</code>, the <code>ElementType</code> associated
type member of <code>StackType</code> is erased. This means <code>StackType.ElementType</code> has the
API dictated by the declaration of <code>ElementType</code> in the interface
<code>StackAssociatedType</code>.</p><p>Outside the generic, associated types have the concrete type values determined
by impl lookup, rather than the erased version of that type used inside a
generic.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var my_array: DynamicArray(i32) = (1, 2, 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// PeekAtTopOfStack&#x27;s `StackType` is set to `DynamicArray(i32)`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// with `StackType.ElementType` set to `i32`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Assert(PeekAtTopOfStack(my_array) == 3);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is another part of achieving
<a href="/carbon-lang/design/generics/goals#path-from-regular-functions">the goal that generic functions can be used in place of regular functions without changing the return type that callers see</a>
discussed in the <a href="#return-type">return type section</a>.</p><p>Associated types can also be implemented using a
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/classes.md#member-type" target="_blank" rel="noopener noreferrer">member type</a>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Container {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let IteratorType:! Iterator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class DynamicArray(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Container {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class IteratorType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      impl Iterator { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>For context, see
<a href="/carbon-lang/design/generics/terminology#interface-type-parameters-and-associated-types">&quot;Interface type parameters and associated types&quot; in the generics terminology document</a>.</p><p><strong>Comparison with other languages:</strong> Both
<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types" target="_blank" rel="noopener noreferrer">Rust</a>
and <a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID189" target="_blank" rel="noopener noreferrer">Swift</a>
support associated types.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="implementation-model-1">Implementation model<a class="hash-link" href="#implementation-model-1" title="Direct link to heading">​</a></h3><p>The associated type can be modeled by a witness table field in the interface&#x27;s
witness table.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Iterator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Advance[addr me: Self*]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Container {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let IteratorType:! Iterator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Begin[addr me: Self*]() -&gt; IteratorType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>is represented by:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Iterator(Self:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var Advance: fnty(this: Self*);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Container(Self:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Representation type for the iterator.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let IteratorType:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Witness that IteratorType implements Iterator.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var iterator_impl: Iterator(IteratorType)*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var Begin: fnty (this: Self*) -&gt; IteratorType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="parameterized-interfaces">Parameterized interfaces<a class="hash-link" href="#parameterized-interfaces" title="Direct link to heading">​</a></h2><p>Associated types don&#x27;t change the fact that a type can only implement an
interface at most once.</p><p>If instead you want a family of related interfaces, one per possible value of a
type parameter, multiple of which could be implemented for a single type, you
would use
<a href="/carbon-lang/design/generics/terminology#interface-type-parameters-and-associated-types">parameterized interfaces</a>.
To write a parameterized version of the stack interface, instead of using
associated types, write a parameter list after the name of the interface instead
of the associated type declaration:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface StackParameterized(ElementType:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Push[addr me: Self*](value: ElementType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Pop[addr me: Self*]() -&gt; ElementType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn IsEmpty[addr me: Self*]() -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Then <code>StackParameterized(Fruit)</code> and <code>StackParameterized(Veggie)</code> would be
considered different interfaces, with distinct implementations.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Produce {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var fruit: DynamicArray(Fruit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var veggie: DynamicArray(Veggie);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as StackParameterized(Fruit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Push[addr me: Self*](value: Fruit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      me-&gt;fruit.Push(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Pop[addr me: Self*]() -&gt; Fruit {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return me-&gt;fruit.Pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn IsEmpty[addr me: Self*]() -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return me-&gt;fruit.IsEmpty();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as StackParameterized(Veggie) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Push[addr me: Self*](value: Veggie) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      me-&gt;veggie.Push(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Pop[addr me: Self*]() -&gt; Veggie {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return me-&gt;veggie.Pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn IsEmpty[addr me: Self*]() -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return me-&gt;veggie.IsEmpty();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Unlike associated types in interfaces and parameters to types, interface
parameters can&#x27;t be deduced. For example, if we were to rewrite
<a href="#associated-types">the <code>PeekAtTopOfStack</code> example in the &quot;associated types&quot; section</a>
for <code>StackParameterized(T)</code> it would generate a compile error:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Error: can&#x27;t deduce interface parameter `T`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn BrokenPeekAtTopOfStackParameterized</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [T:! Type, StackType:! StackParameterized(T)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (s: StackType*) -&gt; T { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This error is because the compiler can not determine if <code>T</code> should be <code>Fruit</code> or
<code>Veggie</code> when passing in argument of type <code>Produce*</code>. The function&#x27;s signature
would have to be changed so that the value for <code>T</code> could be determined from the
explicit parameters.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn PeekAtTopOfStackParameterized</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [T:! Type, StackType:! StackParameterized(T)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (s: StackType*, _:! singleton_type_of(T)) -&gt; T { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var produce: Produce = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var top_fruit: Fruit =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PeekAtTopOfStackParameterized(&amp;produce, Fruit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var top_veggie: Veggie =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PeekAtTopOfStackParameterized(&amp;produce, Veggie);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The pattern <code>_:! singleton_type_of(T)</code> is a placeholder syntax for an expression
that will only match <code>T</code>, until issue
<a href="https://github.com/carbon-language/carbon-lang/issues/578" target="_blank" rel="noopener noreferrer">#578: Value patterns as function parameters</a>
is resolved. Using that pattern in the explicit parameter list allows us to make
<code>T</code> available earlier in the declaration so it can be passed as the argument to
the parameterized interface <code>StackParameterized</code>.</p><p>This approach is useful for the <code>ComparableTo(T)</code> interface, where a type might
be comparable with multiple other types, and in fact interfaces for
<a href="#operator-overloading">operator overloads</a> more generally. Example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface EquatableWith(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Equals[me: Self](rhs: T) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Complex {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var real: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var imag: f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Can implement this interface more than once</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // as long as it has different arguments.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as EquatableWith(Complex) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as EquatableWith(f64) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>All interface parameters must be marked as &quot;generic&quot;, using the <code>:!</code> syntax.
This reflects these two properties of these parameters:</p><ul><li>They must be resolved at compile-time, and so can&#x27;t be passed regular
dynamic values.</li><li>We allow either generic or template values to be passed in.</li></ul><p><strong>Note:</strong> Interface parameters aren&#x27;t required to be types, but that is the vast
majority of cases. As an example, if we had an interface that allowed a type to
define how the tuple-member-read operator would work, the index of the member
could be an interface parameter:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface ReadTupleMember(index:! u32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let T:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Returns me[index]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Get[me: Self]() -&gt; T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This requires that the index be known at compile time, but allows different
indices to be associated with different types.</p><p><strong>Caveat:</strong> When implementing an interface twice for a type, the interface
parameters are required to always be different. For example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Map(FromType:! Type, ToType:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Map[addr me: Self*](needle: FromType) -&gt; Optional(ToType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Bijection(FromType:! Type, ToType:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Map(FromType, ToType) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Map(ToType, FromType) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Error: Bijection has two impls of interface Map(String, String)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var oops: Bijection(String, String) = ...;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In this case, it would be better to have an <a href="#adapting-types">adapting type</a> to
contain the <code>impl</code> for the reverse map lookup, instead of implementing the <code>Map</code>
interface twice:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Bijection(FromType:! Type, ToType:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Map(FromType, ToType) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter ReverseLookup(FromType:! Type, ToType:! Type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for Bijection(FromType, ToType) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Map(ToType, FromType) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Comparison with other languages:</strong> Rust calls
<a href="https://doc.rust-lang.org/reference/items/traits.html#generic-traits" target="_blank" rel="noopener noreferrer">traits with type parameters &quot;generic traits&quot;</a>
and
<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#default-generic-type-parameters-and-operator-overloading" target="_blank" rel="noopener noreferrer">uses them for operator overloading</a>.</p><p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md#clearer-trait-matching" target="_blank" rel="noopener noreferrer">Rust uses the term &quot;type parameters&quot;</a>
for both interface type parameters and associated types. The difference is that
interface parameters are &quot;inputs&quot; since they <em>determine</em> which <code>impl</code> to use,
and associated types are &quot;outputs&quot; since they are determined <em>by</em> the <code>impl</code>,
but play no role in selecting the <code>impl</code>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="impl-lookup">Impl lookup<a class="hash-link" href="#impl-lookup" title="Direct link to heading">​</a></h3><p>Let&#x27;s say you have some interface <code>I(T, U(V))</code> being implemented for some type
<code>A(B(C(D), E))</code>. To satisfy the <a href="#orphan-rule">orphan rule for coherence</a>, that
<code>impl</code> must be defined in some library that must be imported in any code that
looks up whether that interface is implemented for that type. This requires that
<code>impl</code> is defined in the same library that defines the interface or one of the
names needed by the type. That is, the <code>impl</code> must be defined with one of <code>I</code>,
<code>T</code>, <code>U</code>, <code>V</code>, <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, or <code>E</code>. We further require anything looking
up this <code>impl</code> to import the <em>definitions</em> of all of those names. Seeing a
forward declaration of these names is insufficient, since you can presumably see
forward declarations without seeing an <code>impl</code> with the definition. This
accomplishes a few goals:</p><ul><li>The compiler can check that there is only one definition of any <code>impl</code> that
is actually used, avoiding
<a href="https://en.wikipedia.org/wiki/One_Definition_Rule" target="_blank" rel="noopener noreferrer">One Definition Rule (ODR)</a>
problems.</li><li>Every attempt to use an <code>impl</code> will see the exact same <code>impl</code>, making the
interpretation and semantics of code consistent no matter its context, in
accordance with the
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/project/principles/low_context_sensitivity.md" target="_blank" rel="noopener noreferrer">low context-sensitivity principle</a>.</li><li>Allowing the <code>impl</code> to be defined with either the interface or the type
addresses the
<a href="https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions" target="_blank" rel="noopener noreferrer">expression problem</a>.</li></ul><p>Note that <a href="#lookup-resolution-and-specialization">the rules for specialization</a>
do allow there to be more than one <code>impl</code> to be defined for a type, by
unambiguously picking one as most specific.</p><p><strong>References:</strong> Implementation coherence is
<a href="/carbon-lang/design/generics/terminology#coherence">defined in terminology</a>, and is
<a href="/carbon-lang/design/generics/goals#coherence">a goal for Carbon</a>. More detail can be found in
<a href="/carbon-lang/design/generics/appendix-coherence">this appendix with the rationale and alternatives considered</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="parameterized-named-constraints">Parameterized named constraints<a class="hash-link" href="#parameterized-named-constraints" title="Direct link to heading">​</a></h3><p>We should also allow the <a href="#named-constraints">named constraint</a> construct to
support parameters. Parameters would work the same way as for interfaces.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="where-constraints">Where constraints<a class="hash-link" href="#where-constraints" title="Direct link to heading">​</a></h2><p>So far, we have restricted a generic type parameter by saying it has to
implement an interface or a set of interfaces. There are a variety of other
constraints we would like to be able to express, such as applying restrictions
to its associated types and associated constants. This is done using the <code>where</code>
operator that adds constraints to a type-of-type.</p><p>The where operator can be applied to a type-of-type in a declaration context:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Constraints on function parameters:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn F[V:! D where ...](v: V) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Constraints on a class parameter:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class S(T:! B where ...) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Constraints on a method:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn G[me: Self, V:! D where ...](v: V);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Constraints on an interface parameter:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface A(T:! B where ...) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Constraints on an associated type:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let U:! C where ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Constraints on an associated method:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn G[me: Self, V:! D where ...](v: V);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We also allow you to name constraints using a <code>where</code> operator in a <code>let</code> or
<code>constraint</code> definition. The expressions that can follow the <code>where</code> keyword are
described in the <a href="#constraint-use-cases">&quot;constraint use cases&quot;</a> section, but
generally look like boolean expressions that should evaluate to <code>true</code>.</p><p>The result of applying a <code>where</code> operator to a type-of-type is another
type-of-type. Note that this expands the kinds of requirements that
type-of-types can have from just interface requirements to also include the
various kinds of constraints discussed later in this section. In addition, it
can introduce relationships between different type variables, such as that a
member of one is equal to the member of another.</p><p><strong>Comparison with other languages:</strong> Both Swift and Rust use <code>where</code> clauses on
declarations instead of in the expression syntax. These happen after the type
that is being constrained has been given a name and use that name to express the
constraint.</p><p>Rust also supports
<a href="https://rust-lang.github.io/rfcs/0195-associated-items.html#constraining-associated-types" target="_blank" rel="noopener noreferrer">directly passing in the values for associated types</a>
when using a trait as a constraint. This is helpful when specifying concrete
types for all associated types in a trait in order to
<a href="https://rust-lang.github.io/rfcs/0195-associated-items.html#trait-objects" target="_blank" rel="noopener noreferrer">make it object safe so it can be used to define a trait object type</a>.</p><p>Rust is adding trait aliases
(<a href="https://github.com/rust-lang/rfcs/blob/master/text/1733-trait-alias.md" target="_blank" rel="noopener noreferrer">RFC</a>,
<a href="https://github.com/rust-lang/rust/issues/41517" target="_blank" rel="noopener noreferrer">tracking issue</a>) to support
naming some classes of constraints.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="constraint-use-cases">Constraint use cases<a class="hash-link" href="#constraint-use-cases" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="set-an-associated-constant-to-a-specific-value">Set an associated constant to a specific value<a class="hash-link" href="#set-an-associated-constant-to-a-specific-value" title="Direct link to heading">​</a></h4><p>We might need to write a function that only works with a specific value of an
<a href="#associated-constants">associated constant</a> <code>N</code>. In this case, the name of the
associated constant is written first, followed by an <code>=</code>, and then the value:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn PrintPoint2D[PointT:! NSpacePoint where .N = 2](p: PointT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Print(p.Get(0), &quot;, &quot;, p.Get(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Similarly in an interface definition:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Has2DPoint {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let PointT:! NSpacePoint where .N = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To name such a constraint, you may use a <code>let</code> or a <code>constraint</code> declaration:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let Point2DInterface:! auto = NSpacePoint where .N = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint Point2DInterface {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends NSpacePoint where .N = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This syntax is also used to specify the values of
<a href="#associated-constants">associated constants</a> when implementing an interface for
a type.</p><p><strong>Concern:</strong> Using <code>=</code> for this use case is not consistent with other <code>where</code>
clauses that write a boolean expression that evaluates to <code>true</code> when the
constraint is satisfied.</p><p>A constraint to say that two associated constants should have the same value
without specifying what specific value they should have must use <code>==</code> instead of
<code>=</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface PointCloud {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Dim:! i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let PointT:! NSpacePoint where .N == Dim;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="same-type-constraints">Same type constraints<a class="hash-link" href="#same-type-constraints" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="set-an-associated-type-to-a-specific-value">Set an associated type to a specific value<a class="hash-link" href="#set-an-associated-type-to-a-specific-value" title="Direct link to heading">​</a></h5><p>Functions accepting a generic type might also want to constrain one of its
associated types to be a specific, concrete type. For example, we might want to
have a function only accept stacks containing integers:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn SumIntStack[T:! Stack where .ElementType = i32](s: T*) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var sum: i32 = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (!s-&gt;IsEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // s-&gt;Pop() has type `T.ElementType` == i32:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sum += s-&gt;Pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return sum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To name these sorts of constraints, we could use <code>let</code> declarations or
<code>constraint</code> definitions:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let IntStack:! auto = Stack where .ElementType = i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint IntStack {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Stack where .ElementType = i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This syntax is also used to specify the values of
<a href="#associated-types">associated types</a> when implementing an interface for a type.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="equal-generic-types">Equal generic types<a class="hash-link" href="#equal-generic-types" title="Direct link to heading">​</a></h5><p>Alternatively, two generic types could be constrained to be equal to each other,
without specifying what that type is. This uses <code>==</code> instead of <code>=</code>. For
example, we could make the <code>ElementType</code> of an <code>Iterator</code> interface equal to the
<code>ElementType</code> of a <code>Container</code> interface as follows:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Iterator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let ElementType:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Container {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let ElementType:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let IteratorType:! Iterator where .ElementType == ElementType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Given an interface with two associated types</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface PairInterface {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Left:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Right:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>we can constrain them to be equal in a function signature:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn F[MatchedPairType:! PairInterface where .Left == .Right]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (x: MatchedPairType*);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>or in an interface definition:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface HasEqualPair {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let P:! PairInterface where .Left == .Right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This kind of constraint can be named:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let EqualPair:! auto =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PairInterface where .Left == .Right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint EqualPair {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends PairInterface where .Left == .Right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Another example of same type constraints is when associated types of two
different interfaces are constrained to be equal:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn Map[CT:! Container,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       FT:! Function where .InputType == CT.ElementType]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      (c: CT, f: FT) -&gt; Vector(FT.OutputType);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="satisfying-both-type-of-types">Satisfying both type-of-types<a class="hash-link" href="#satisfying-both-type-of-types" title="Direct link to heading">​</a></h6><p>If the two types being constrained to be equal have been declared with different
type-of-types, then the actual type value they are set to will have to satisfy
both constraints. For example, if <code>SortedContainer.ElementType</code> is declared to
be <code>Comparable</code>, then in this declaration:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn Contains</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [SC:! SortedContainer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     CT:! Container where .ElementType == SC.ElementType]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (haystack: SC, needles: CT) -&gt; bool;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>the <code>where</code> constraint means <code>CT.ElementType</code> must satisfy <code>Comparable</code> as well.
However, inside the body of <code>Contains</code>, <code>CT.ElementType</code> will only act like the
implementation of <code>Comparable</code> is <a href="#external-impl">external</a>. That is, items
from the <code>needles</code> container won&#x27;t directly have a <code>Compare</code> method member, but
can still be implicitly converted to <code>Comparable</code> and can still call <code>Compare</code>
using the compound member access syntax, <code>needle.(Comparable.Compare)(elt)</code>. The
rule is that an <code>==</code> <code>where</code> constraint between two type variables does not
modify the set of member names of either type. (If you write
<code>where .ElementType = String</code> with a <code>=</code> and a concrete type, then
<code>.ElementType</code> is actually set to <code>String</code> including the complete <code>String</code> API.)</p><p>Note that <code>==</code> constraints are symmetric, so the previous declaration of
<code>Contains</code> is equivalent to an alternative declaration where <code>CT</code> is declared
first and the <code>where</code> clause is attached to <code>SortedContainer</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn Contains</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [CT:! Container,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     SC:! SortedContainer where .ElementType == CT.ElementType]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (haystack: SC, needles: CT) -&gt; bool;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="type-bound-for-associated-type">Type bound for associated type<a class="hash-link" href="#type-bound-for-associated-type" title="Direct link to heading">​</a></h4><p>A <code>where</code> clause can express that a type must implement an interface. This is
more flexible than the usual approach of including that interface in the type
since it can be applied to associated type members as well.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="type-bounds-on-associated-types-in-declarations">Type bounds on associated types in declarations<a class="hash-link" href="#type-bounds-on-associated-types-in-declarations" title="Direct link to heading">​</a></h5><p>In the following example, normally the <code>ElementType</code> of a <code>Container</code> can be any
type. The <code>SortContainer</code> function, however, takes a pointer to a type
satisfying <code>Container</code> with the additional constraint that its <code>ElementType</code>
must satisfy the <code>Comparable</code> interface.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Container {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let ElementType:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn SortContainer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [ContainerType:! Container where .ElementType is Comparable]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (container_to_sort: ContainerType*);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In contrast to <a href="#same-type-constraints">a same type constraint</a>, this does not
say what type <code>ElementType</code> exactly is, just that it must satisfy some
type-of-type.</p><p><strong>Open question:</strong> How do you spell that? Provisionally we are writing <code>is</code>,
following Swift, but maybe we should have another operator that more clearly
returns a boolean like <code>has_type</code>?</p><p><strong>Note:</strong> <code>Container</code> defines <code>ElementType</code> as having type <code>Type</code>, but
<code>ContainerType.ElementType</code> has type <code>Comparable</code>. This is because
<code>ContainerType</code> has type <code>Container where .ElementType is Comparable</code>, not
<code>Container</code>. This means we need to be a bit careful when talking about the type
of <code>ContainerType</code> when there is a <code>where</code> clause modifying it.</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="type-bounds-on-associated-types-in-interfaces">Type bounds on associated types in interfaces<a class="hash-link" href="#type-bounds-on-associated-types-in-interfaces" title="Direct link to heading">​</a></h5><p>Given these definitions (omitting <code>ElementType</code> for brevity):</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface IteratorInterface { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface ContainerInterface {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let IteratorType:! IteratorInterface;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface RandomAccessIterator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends IteratorInterface;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We can then define a function that only accepts types that implement
<code>ContainerInterface</code> where its <code>IteratorType</code> associated type implements
<code>RandomAccessIterator</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn F[ContainerType:! ContainerInterface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     where .IteratorType is RandomAccessIterator]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (c: ContainerType);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We would like to be able to name this constraint, defining a
<code>RandomAccessContainer</code> to be a type-of-type whose types satisfy
<code>ContainerInterface</code> with an <code>IteratorType</code> satisfying <code>RandomAccessIterator</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let RandomAccessContainer:! auto =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ContainerInterface where .IteratorType is RandomAccessIterator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint RandomAccessContainer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends ContainerInterface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      where .IteratorType is RandomAccessIterator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// With the above definition:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn F[ContainerType:! RandomAccessContainer](c: ContainerType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// is equivalent to:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn F[ContainerType:! ContainerInterface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     where .IteratorType is RandomAccessIterator]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (c: ContainerType);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="combining-constraints">Combining constraints<a class="hash-link" href="#combining-constraints" title="Direct link to heading">​</a></h4><p>Constraints can be combined by separating constraint clauses with the <code>and</code>
keyword. This example expresses a constraint that two associated types are equal
and satisfy an interface:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn EqualContainers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [CT1:! Container,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     CT2:! Container where .ElementType is HasEquality</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       and .ElementType == CT1.ElementType]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (c1: CT1*, c2: CT2*) -&gt; bool;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Comparison with other languages:</strong> Swift and Rust use commas <code>,</code> to separate
constraint clauses, but that only works because they place the <code>where</code> in a
different position in a declaration. In Carbon, the <code>where</code> is attached to a
type in a parameter list that is already using commas to separate parameters.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="recursive-constraints">Recursive constraints<a class="hash-link" href="#recursive-constraints" title="Direct link to heading">​</a></h4><p>We sometimes need to constrain a type to equal one of its associated types. In
this first example, we want to represent the function <code>Abs</code> which will return
<code>Self</code> for some but not all types, so we use an associated type <code>MagnitudeType</code>
to encode the return type:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface HasAbs {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Numeric;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let MagnitudeType:! Numeric;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Abs[me: Self]() -&gt; MagnitudeType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>For types representing subsets of the real numbers, such as <code>i32</code> or <code>f32</code>, the
<code>MagnitudeType</code> will match <code>Self</code>, the type implementing an interface. For types
representing complex numbers, the types will be different. For example, the
<code>Abs()</code> applied to a <code>Complex64</code> value would produce a <code>f32</code> result. The goal is
to write a constraint to restrict to the first case.</p><p>In a second example, when you take the slice of a type implementing <code>Container</code>
you get a type implementing <code>Container</code> which may or may not be the same type as
the original container type. However, taking the slice of a slice always gives
you the same type, and some functions want to only operate on containers whose
slice type is the same as the container type.</p><p>To solve this problem, we think of <code>Self</code> as an actual associated type member of
every interface. We can then address it using <code>.Self</code> in a <code>where</code> clause, like
any other associated type member.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn Relu[T:! HasAbs where .MagnitudeType == .Self](x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // T.MagnitudeType == T so the following is allowed:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return (x.Abs() + x) / 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn UseContainer[T:! Container where .SliceType == .Self](c: T) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // T.SliceType == T so `c` and `c.Slice(...)` can be compared:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return c == c.Slice(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Notice that in an interface definition, <code>Self</code> refers to the type implementing
this interface while <code>.Self</code> refers to the associated type currently being
defined.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Container {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let ElementType:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let SliceType:! Container</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      where .ElementType == ElementType and</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .SliceType == .Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn GetSlice[addr me: Self*]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      (start: IteratorType, end: IteratorType) -&gt; SliceType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>These recursive constraints can be named:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let RealAbs:! auto = HasAbs where .MagnitudeType == .Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint RealAbs {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends HasAbs where .MagnitudeType == Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let ContainerIsSlice:! auto =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Container where .SliceType == .Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint ContainerIsSlice {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Container where .SliceType == Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that using the <code>constraint</code> approach we can name these constraints using
<code>Self</code> instead of <code>.Self</code>, since they refer to the same type.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="parameterized-type-implements-interface">Parameterized type implements interface<a class="hash-link" href="#parameterized-type-implements-interface" title="Direct link to heading">​</a></h4><p>There are times when a function will pass a generic type parameter of the
function as an argument to a parameterized type, as in the previous case, and in
addition the function needs the result to implement a specific interface.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Some parameterized type.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Vector(T:! Type) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Parameterized type implements interface only for some arguments.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Vector(String) as Printable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Constraint: `T` such that `Vector(T)` implements `Printable`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn PrintThree</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [T:! Type where Vector(.Self) is Printable]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (a: T, b: T, c: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var v: Vector(T) = (a, b, c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Print(v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Comparison with other languages:</strong> This use case was part of the
<a href="https://rust-lang.github.io/rfcs/0135-where.html#motivation" target="_blank" rel="noopener noreferrer">Rust rationale for adding support for <code>where</code> clauses</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="another-type-implements-parameterized-interface">Another type implements parameterized interface<a class="hash-link" href="#another-type-implements-parameterized-interface" title="Direct link to heading">​</a></h4><p>In this case, we need some other type to implement an interface parameterized by
a generic type parameter. The syntax for this case follows the previous case,
except now the <code>.Self</code> parameter is on the interface to the right of the <code>is</code>.
For example, we might need a type parameter <code>T</code> to support explicit conversion
from an integer type like <code>i32</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface As(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Convert[me: Self]() -&gt; T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn Double[T:! Mul where i32 is As(.Self)](x: T) -&gt; T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return x * (2 as T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="implied-constraints">Implied constraints<a class="hash-link" href="#implied-constraints" title="Direct link to heading">​</a></h3><p>Imagine we have a generic function that accepts an arbitrary <code>HashMap</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn LookUp[KeyType:! Type](hm: HashMap(KeyType, i32)*,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          k: KeyType) -&gt; i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn PrintValueOrDefault[KeyType:! Printable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       ValueT:! Printable &amp; HasDefault]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (map: HashMap(KeyType, ValueT), key: KeyT);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The <code>KeyType</code> in these declarations does not visibly satisfy the requirements of
<code>HashMap</code>, which requires the type implement <code>Hashable</code> and other interfaces:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class HashMap(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    KeyType:! Hashable &amp; EqualityComparable &amp; Movable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...) { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In this case, <code>KeyType</code> gets <code>Hashable</code> and so on as <em>implied constraints</em>.
Effectively that means that these functions are automatically rewritten to add a
<code>where</code> constraint on <code>KeyType</code> attached to the <code>HashMap</code> type:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn LookUp[KeyType:! Type]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (hm: HashMap(KeyType, i32)*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        where KeyType is Hashable &amp; EqualityComparable &amp; Movable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     k: KeyType) -&gt; i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn PrintValueOrDefault[KeyType:! Printable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       ValueT:! Printable &amp; HasDefault]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (map: HashMap(KeyType, ValueT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        where KeyType is Hashable &amp; EqualityComparable &amp; Movable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     key: KeyT);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In this case, Carbon will accept the definition and infer the needed constraints
on the generic type parameter. This is both more concise for the author of the
code and follows the
<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener noreferrer">&quot;don&#x27;t repeat yourself&quot; principle</a>.
This redundancy is undesirable since it means if the needed constraints for
<code>HashMap</code> are changed, then the code has to be updated in more locations.
Further it can add noise that obscures relevant information. In practice, any
user of these functions will have to pass in a valid <code>HashMap</code> instance, and so
will have already satisfied these constraints.</p><p>This implied constraint is equivalent to the explicit constraint that each
parameter and return type <a href="#must-be-legal-type-argument-constraints">is legal</a>.</p><p><strong>Note:</strong> These implied constraints affect the <em>requirements</em> of a generic type
parameter, but not its <em>member names</em>. This way you can always look at the
declaration to see how name resolution works, without having to look up the
definitions of everything it is used as an argument to.</p><p><strong>Limitation:</strong> To limit readability concerns and ambiguity, this feature is
limited to a single signature. Consider this interface declaration:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface GraphNode {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Edge:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn EdgesFrom[me: Self]() -&gt; HashSet(Edge);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>One approach would be to say the use of <code>HashSet(Edge)</code> in the signature of the
<code>EdgesFrom</code> function would imply that <code>Edge</code> satisfies the requirements of an
argument to <code>HashSet</code>, such as being <code>Hashable</code>. Another approach would be to
say that the <code>EdgesFrom</code> would only be conditionally available when <code>Edge</code> does
satisfy the constraints on <code>HashSet</code> arguments. Instead, Carbon will reject this
definition, requiring the user to include all the constraints required for the
other declarations in the interface in the declaration of the <code>Edge</code> associated
type. Similarly, a parameter to a class must be declared with all the
constraints needed to declare the members of the class that depend on that
parameter.</p><p><strong>Comparison with other languages:</strong> Both Swift
(<a href="https://www.swiftbysundell.com/tips/inferred-generic-type-constraints/" target="_blank" rel="noopener noreferrer">1</a>,
<a href="https://github.com/apple/swift/blob/main/docs/Generics.rst#constraint-inference" target="_blank" rel="noopener noreferrer">2</a>)
and
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0b2d645bd205f24a7a6e2330d652c32e" target="_blank" rel="noopener noreferrer">Rust</a>
support some form of this feature as part of their type inference (and
<a href="http://smallcultfollowing.com/babysteps//blog/2022/04/12/implied-bounds-and-perfect-derive/#expanded-implied-bounds" target="_blank" rel="noopener noreferrer">the Rust community is considering expanding support</a>).</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="must-be-legal-type-argument-constraints">Must be legal type argument constraints<a class="hash-link" href="#must-be-legal-type-argument-constraints" title="Direct link to heading">​</a></h4><p>Now consider the case that the generic type parameter is going to be used as an
argument to a parameterized type in a function body, not in the signature. If
the parameterized type was explicitly mentioned in the signature, the implied
constraint feature would ensure all of its requirements were met. The developer
can create a trivial
<a href="#parameterized-type-implements-interface">parameterized type implements interface</a>
<code>where</code> constraint to just say the type is a legal with this argument, by saying
that the parameterized type implements <code>Type</code>, which all types do.</p><p>For example, a function that adds its parameters to a <code>HashSet</code> to deduplicate
them, needs them to be <code>Hashable</code> and so on. To say &quot;<code>T</code> is a type where
<code>HashSet(T)</code> is legal,&quot; we can write:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn NumDistinct[T:! Type where HashSet(.Self) is Type]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (a: T, b: T, c: T) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var set: HashSet(T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  set.Add(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  set.Add(b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  set.Add(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return set.Size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This has the same advantages over repeating the constraints on <code>HashSet</code>
arguments in the type of <code>T</code> as the general implied constraints above.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="referencing-names-in-the-interface-being-defined">Referencing names in the interface being defined<a class="hash-link" href="#referencing-names-in-the-interface-being-defined" title="Direct link to heading">​</a></h3><p>The constraint in a <code>where</code> clause is required to only reference earlier names
from this scope, as in this example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Graph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let E: Edge;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let V: Vert where .E == E and .Self == E.V;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="manual-type-equality">Manual type equality<a class="hash-link" href="#manual-type-equality" title="Direct link to heading">​</a></h3><p>Imagine we have some function with generic parameters:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn F[T:! SomeInterface](x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  x.G(x.H());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We want to know if the return type of method <code>T.H</code> is the same as the parameter
type of <code>T.G</code> in order to typecheck the function. However, determining whether
two type expressions are transitively equal is in general undecidable, as
<a href="https://forums.swift.org/t/swift-type-checking-is-undecidable/39024" target="_blank" rel="noopener noreferrer">has been shown in Swift</a>.</p><p>Carbon&#x27;s approach is to only allow implicit conversions between two type
expressions that are constrained to be equal in a single where clause. This
means that if two type expressions are only transitively equal, the user will
need to include a sequence of casts or use an
<a href="#observe-declarations"><code>observe</code> declaration</a> to convert between them.</p><p>Given this interface <code>Transitive</code> that has associated types that are constrained
to all be equal, with interfaces <code>P</code>, <code>Q</code>, and <code>R</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface P { fn InP[me:Self](); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Q { fn InQ[me:Self](); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface R { fn InR[me:Self](); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Transitive {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let A:! P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let B:! Q where .Self == A;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let C:! R where .Self == B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn GetA[me: Self]() -&gt; A;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn TakesC[me:Self](c: C);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A cast to <code>B</code> is needed to call <code>TakesC</code> with a value of type <code>A</code>, so each step
only relies on one equality:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn F[T:! Transitive](t: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  t.TakesC(t.GetA() as T.B);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let b: T.B = t.GetA();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  t.TakesC(b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ❌ Not allowed: t.TakesC(t.GetA());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A value of type <code>A</code>, such as the return value of <code>GetA()</code>, has the API of <code>P</code>.
Any such value also implements <code>Q</code>, and since the compiler can see that by way
of a single <code>where</code> equality, values of type <code>A</code> are treated as if they
implement <code>Q</code> <a href="/carbon-lang/design/generics/terminology#external-impl">externally</a>. However, the compiler
will require a cast to <code>B</code> or <code>C</code> to see that the type implements <code>R</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn TakesPQR[U:! P &amp; Q &amp; R](u: U);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn G[T:! Transitive](t: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var a: T.A = t.GetA();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `T.A` implements `P`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  a.InP();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `T.A` implements `Q` externally.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  a.(Q.InQ)();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ❌ Not allowed: a.InQ();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: values of type `T.A` may be cast</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // to `T.B`, which implements `Q` internally.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (a as T.B).InQ();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `T.B` implements `R` externally.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  (a as T.B).(R.InR)();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ❌ Not allowed: TakesPQR(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `T.B` implements `P`, `Q`, and</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `R`, though the implementations of `P`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // and `R` are external.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  TakesPQR(a as T.B);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The compiler may have several different <code>where</code> clauses to consider,
particularly when an interface has associated types that recursively satisfy the
same interface. For example, given this interface <code>Commute</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Commute {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let X:! Commute;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Y:! Commute where .X == X.Y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn GetX[me: Self]() -&gt; X;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn GetY[me: Self]() -&gt; Y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn TakesXXY[me:Self](xxy: X.X.Y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>and a function <code>H</code> taking a value with some type implementing this interface,
then the following would be legal statements in <code>H</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn H[C: Commute](c: C) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Legal: argument has type `C.X.X.Y`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  c.TakesXXY(c.GetX().GetX().GetY());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Legal: argument has type `C.X.Y.X` which is equal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // to `C.X.X.Y` following only one `where` clause.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  c.TakesXXY(c.GetX().GetY().GetX());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Legal: cast is legal since it matches a `where`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // clause, and produces an argument that has type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `C.X.Y.X`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  c.TakesXXY(c.GetY().GetX().GetX() as C.X.Y.X);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>That last call would not be legal without the cast, though.</p><p><strong>Comparison with other languages:</strong> Other languages such as Swift and Rust
instead perform automatic type equality. In practice this means that their
compiler can reject some legal programs based on heuristics simply to avoid
running for an unbounded length of time.</p><p>The benefits of the manual approach include:</p><ul><li>fast compilation, since the compiler does not need to explore a potentially
large set of combinations of equality restrictions, supporting
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/project/goals.md#fast-and-scalable-development" target="_blank" rel="noopener noreferrer">Carbon&#x27;s goal of fast and scalable development</a>;</li><li>expressive and predictable semantics, since there are no limitations on how
complex a set of constraints can be supported; and</li><li>simplicity.</li></ul><p>The main downsides are:</p><ul><li>manual work for the source code author to prove to the compiler that types
are equal; and</li><li>verbosity.</li></ul><p>We expect that rich error messages and IDE tooling will be able to suggest
changes to the source code when a single equality constraint is not sufficient
to show two type expressions are equal, but a more extensive automated search
can find a sequence that prove they are equal.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="observe-declarations"><code>observe</code> declarations<a class="hash-link" href="#observe-declarations" title="Direct link to heading">​</a></h4><p>An <code>observe</code> declaration lists a sequence of type expressions that are equal by
some same-type <code>where</code> constraints. These <code>observe</code> declarations may be included
in an <code>interface</code> definition or a function body, as in:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Commute {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let X:! Commute;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Y:! Commute where .X == X.Y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  observe X.X.Y == X.Y.X == Y.X.X;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn H[C: Commute](c: C) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  observe C.X.Y.Y == C.Y.X.Y == C.Y.Y.X;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Every type expression after the first must be equal to some earlier type
expression in the sequence by a single <code>where</code> equality constraint. In this
example,</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Commute {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let X:! Commute;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Y:! Commute where .X == X.Y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Legal:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  observe X.X.Y.Y == X.Y.X.Y == Y.X.X.Y == X.Y.Y.X;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>the expression <code>X.Y.Y.X</code> is one equality away from <code>X.Y.X.Y</code> and so it is
allowed. This is even though <code>X.Y.X.Y</code> isn&#x27;t the type expression immediately
prior to <code>X.Y.Y.X</code>.</p><p>After an <code>observe</code> declaration, all of the listed type expressions are
considered equal to each other using a single <code>where</code> equality. In this example,
the <code>observe</code> declaration in the <code>Transitive</code> interface definition provides the
link between associated types <code>A</code> and <code>C</code> that allows function <code>F</code> to type
check.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface P { fn InP[me:Self](); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Q { fn InQ[me:Self](); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface R { fn InR[me:Self](); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Transitive {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let A:! P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let B:! Q where .Self == A;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let C:! R where .Self == B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn GetA[me: Self]() -&gt; A;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn TakesC[me:Self](c: C);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Without this `observe` declaration, the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // calls in `F` below would not be allowed.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  observe A == B == C;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn TakesPQR[U:! P &amp; Q &amp; R](u: U);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn F[T:! Transitive](t: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var a: T.A = t.GetA();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `T.A` == `T.C`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  t.TakesC(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  a.(R.InR());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `T.A` implements `P`,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `T.A` == `T.B` that implements `Q`, and</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `T.A` == `T.C` that implements `R`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  TakesPQR(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Since adding an <code>observe</code> declaration only adds external implementations of
interfaces to generic types, they may be added without breaking existing code.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="other-constraints-as-type-of-types">Other constraints as type-of-types<a class="hash-link" href="#other-constraints-as-type-of-types" title="Direct link to heading">​</a></h2><p>There are some constraints that we will naturally represent as named
type-of-types. These can either be used directly to constrain a generic type
parameter, or in a <code>where ... is ...</code> clause to constrain an associated type.</p><p>The compiler determines which types implement these interfaces, developers can
not explicitly implement these interfaces for their own types.</p><p><strong>Open question:</strong> Are these names part of the prelude or in a standard library?</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="is-a-derived-class">Is a derived class<a class="hash-link" href="#is-a-derived-class" title="Direct link to heading">​</a></h3><p>Given a type <code>T</code>, <code>Extends(T)</code> is a type-of-type whose values are types that are
derived from <code>T</code>. That is, <code>Extends(T)</code> is the set of all types <code>U</code> that are
subtypes of <code>T</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn F[T:! Extends(BaseType)](p: T*);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn UpCast[T:! Type](p: T*, U:! Type where T is Extends(.Self)) -&gt; U*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn DownCast[T:! Type](p: T*, U:! Extends(T)) -&gt; U*;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Open question:</strong> Alternatively, we could define a new <code>extends</code> operator:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn F[T:! Type where .Self extends BaseType](p: T*);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn UpCast[T:! Type](p: T*, U:! Type where T extends .Self) -&gt; U*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn DownCast[T:! Type](p: T*, U:! Type where .Self extends T) -&gt; U*;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Comparison to other languages:</strong> In Swift, you can
<a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID282" target="_blank" rel="noopener noreferrer">add a required superclass to a type bound using <code>&amp;</code></a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="type-compatible-with-another-type">Type compatible with another type<a class="hash-link" href="#type-compatible-with-another-type" title="Direct link to heading">​</a></h3><p>Given a type <code>U</code>, define the type-of-type <code>CompatibleWith(U)</code> as follows:</p><blockquote><p><code>CompatibleWith(U)</code> is a type whose values are types <code>T</code> such that <code>T</code> and <code>U</code>
are <a href="/carbon-lang/design/generics/terminology#compatible-types">compatible</a>. That is values of types <code>T</code>
and <code>U</code> can be cast back and forth without any change in representation (for
example <code>T</code> is an <a href="#adapting-types">adapter</a> for <code>U</code>).</p></blockquote><p>To support this, we extend the requirements that type-of-types are allowed to
have to include a &quot;data representation requirement&quot; option.</p><p><code>CompatibleWith</code> determines an equivalence relationship between types.
Specifically, given two types <code>T1</code> and <code>T2</code>, they are equivalent if
<code>T1 is CompatibleWith(T2)</code>. That is, if <code>T1</code> has the type <code>CompatibleWith(T2)</code>.</p><p><strong>Note:</strong> Just like interface parameters, we require the user to supply <code>U</code>,
they may not be deduced. Specifically, this code would be illegal:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn Illegal[U:! Type, T:! CompatibleWith(U)](x: T*) ...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In general there would be multiple choices for <code>U</code> given a specific <code>T</code> here,
and no good way of picking one. However, similar code is allowed if there is
another way of determining <code>U</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn Allowed[U:! Type, T:! CompatibleWith(U)](x: U*, y: T*) ...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="same-implementation-restriction">Same implementation restriction<a class="hash-link" href="#same-implementation-restriction" title="Direct link to heading">​</a></h4><p>In some cases, we need to restrict to types that implement certain interfaces
the same way as the type <code>U</code>.</p><blockquote><p>The values of type <code>CompatibleWith(U, TT)</code> are types satisfying
<code>CompatibleWith(U)</code> that have the same implementation of <code>TT</code> as <code>U</code>.</p></blockquote><p>For example, if we have a type <code>HashSet(T)</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class HashSet(T:! Hashable) { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Then <code>HashSet(T)</code> may be cast to <code>HashSet(U)</code> if
<code>T is CompatibleWith(U, Hashable)</code>. The one-parameter interpretation of
<code>CompatibleWith(U)</code> is recovered by letting the default for the second <code>TT</code>
parameter be <code>Type</code>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="example-multiple-implementations-of-the-same-interface">Example: Multiple implementations of the same interface<a class="hash-link" href="#example-multiple-implementations-of-the-same-interface" title="Direct link to heading">​</a></h4><p>This allows us to represent functions that accept multiple implementations of
the same interface for a type.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">enum CompareResult { Less, Equal, Greater }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Comparable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Compare[me: Self](rhs: Self) -&gt; CompareResult;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn CombinedLess[T:! Type](a: T, b: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          U:! CompatibleWith(T) &amp; Comparable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          V:! CompatibleWith(T) &amp; Comparable) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  match ((a as U).Compare(b as U)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case CompareResult.Less =&gt; { return True; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case CompareResult.Greater =&gt; { return False; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case CompareResult.Equal =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return (a as V).Compare(b as V) == CompareResult.Less;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Used as:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Song { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter SongByArtist for Song { impl as Comparable { ... } }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter SongByTitle for Song { impl as Comparable { ... } }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var s1: Song = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var s2: Song = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">assert(CombinedLess(s1, s2, SongByArtist, SongByTitle) == True);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We might generalize this to a list of implementations:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn CombinedCompare[T:! Type]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (a: T, b: T, CompareList:! List(CompatibleWith(T) &amp; Comparable))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt; CompareResult {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (let U:! auto in CompareList) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var result: CompareResult = (a as U).Compare(b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (result != CompareResult.Equal) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return CompareResult.Equal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">assert(CombinedCompare(Song(...), Song(...), (SongByArtist, SongByTitle)) ==</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       CompareResult.Less);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Open question:</strong> How are compile-time lists of types declared and iterated
through? They will also be needed for
<a href="#variadic-arguments">variadic argument support</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="example-creating-an-impl-out-of-other-impls">Example: Creating an impl out of other impls<a class="hash-link" href="#example-creating-an-impl-out-of-other-impls" title="Direct link to heading">​</a></h4><p>And then to package this functionality as an implementation of <code>Comparable</code>, we
combine <code>CompatibleWith</code> with <a href="#adapting-types">type adaptation</a>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">adapter ThenCompare(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      T:! Type,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      CompareList:! List(CompatibleWith(T) &amp; Comparable))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Comparable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Compare[me: Self](rhs: Self) -&gt; CompareResult {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      for (let U:! auto in CompareList) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        var result: CompareResult = (me as U).Compare(rhs as U);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (result != CompareResult.Equal) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return CompareResult.Equal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let SongByArtistThenTitle: auto =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ThenCompare(Song, (SongByArtist, SongByTitle));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var s1: Song = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var s2: SongByArtistThenTitle =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Song(...) as SongByArtistThenTitle;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">assert((s1 as SongByArtistThenTitle).Compare(s2) ==</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       CompareResult.Less);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="sized-types-and-type-of-types">Sized types and type-of-types<a class="hash-link" href="#sized-types-and-type-of-types" title="Direct link to heading">​</a></h3><p>What is the size of a type?</p><ul><li>It could be fully known and fixed at compile time -- this is true of
primitive types (<code>i32</code>, <code>f64</code>, and so on), most
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/classes.md" target="_blank" rel="noopener noreferrer">classes</a>, and most other concrete types.</li><li>It could be known generically. This means that it will be known at codegen
time, but not at type-checking time.</li><li>It could be dynamic. For example, it could be a
<a href="#runtime-type-fields">dynamic type</a>, a slice, variable-sized type (such as
<a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#dynamically-sized-types-dsts" target="_blank" rel="noopener noreferrer">found in Rust</a>),
or you could dereference a pointer to a base class that could actually point
to a <a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/classes.md#inheritance" target="_blank" rel="noopener noreferrer">derived class</a>.</li><li>It could be unknown which category the type is in. In practice this will be
essentially equivalent to having dynamic size.</li></ul><p>A type is called <em>sized</em> if it is in the first two categories, and <em>unsized</em>
otherwise. Note: something with size 0 is still considered &quot;sized&quot;. The
type-of-type <code>Sized</code> is defined as follows:</p><blockquote><p><code>Sized</code> is a type whose values are types <code>T</code> that are &quot;sized&quot; -- that is the
size of <code>T</code> is known, though possibly only generically.</p></blockquote><p>Knowing a type is sized is a precondition to declaring variables of that type,
taking values of that type as parameters, returning values of that type, and
defining arrays of that type. Users will not typically need to express the
<code>Sized</code> constraint explicitly, though, since it will usually be a dependency of
some other constraint the type will need such as <code>Movable</code> or <code>Concrete</code>.</p><p><strong>Note:</strong> The compiler will determine which types are &quot;sized&quot;, this is not
something types will implement explicitly like ordinary interfaces.</p><p>Example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// In the Carbon standard library</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface DefaultConstructible {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Types must be sized to be default constructible.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Sized;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Default() -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Classes are &quot;sized&quot; by default.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Name {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as DefaultConstructible {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Default() -&gt; Self { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn F[T:! Type](x: T*) {  // T is unsized.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: may access unsized values through a pointer.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: T* = x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ❌ Illegal: T is unsized.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var z: T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// T is sized, but its size is only known generically.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn G[T: DefaultConstructible](x: T*) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: T is default constructible, which means sized.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var y: T = T.Default();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var z: Name = Name.Default();;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ✅ Allowed: `Name` is sized and implements `DefaultConstructible`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">G(&amp;z);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Open question:</strong> Even if the size is fixed, it won&#x27;t be known at the time of
compiling the generic function if we are using the dynamic strategy. Should we
automatically
<a href="https://en.wikipedia.org/wiki/Object_type_(object-oriented_programming)#Boxing" target="_blank" rel="noopener noreferrer">box</a>
local variables when using the dynamic strategy? Or should we only allow
<code>MaybeBox</code> values to be instantiated locally? Or should this just be a case
where the compiler won&#x27;t necessarily use the dynamic strategy?</p><p><strong>Open question:</strong> Should the <code>Sized</code> type-of-type expose an associated constant
with the size? So you could say <code>T.ByteSize</code> in the above example to get a
generic int value with the size of <code>T</code>. Similarly you might say <code>T.ByteStride</code>
to get the number of bytes used for each element of an array of <code>T</code>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="implementation-model-2">Implementation model<a class="hash-link" href="#implementation-model-2" title="Direct link to heading">​</a></h4><p>This requires a special integer field be included in the witness table type to
hold the size of the type. This field will only be known generically, so if its
value is used for type checking, we need some way of evaluating those type tests
symbolically.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="typeid"><code>TypeId</code><a class="hash-link" href="#typeid" title="Direct link to heading">​</a></h3><p>There are some capabilities every type can provide. For example, every type
should be able to return its name or identify whether it is equal to another
type. It is rare, however, for code to need to access these capabilities, so we
relegate these capabilities to an interface called <code>TypeId</code> that all types
automatically implement. This way generic code can indicate that it needs those
capabilities by including <code>TypeId</code> in the list of requirements. In the case
where no type capabilities are needed, for example the code is only manipulating
pointers to the type, you would write <code>T:! Type</code> and get the efficiency of
<code>void*</code> but without giving up type safety.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn SortByAddress[T:! Type](v: Vector(T*)*) { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In particular, the compiler should in general avoid monomorphizing to generate
multiple instantiations of the function in this case.</p><p><strong>Open question:</strong> Should <code>TypeId</code> be
<a href="/carbon-lang/design/generics/terminology#external-impl">implemented externally</a> for types to avoid name
pollution (<code>.TypeName</code>, <code>.TypeHash</code>, etc.) unless the function specifically
requests those capabilities?</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="destructor-constraints">Destructor constraints<a class="hash-link" href="#destructor-constraints" title="Direct link to heading">​</a></h3><p>There are four type-of-types related to
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/classes.md#destructors" target="_blank" rel="noopener noreferrer">the destructors of types</a>:</p><ul><li><code>Concrete</code> types may be local or member variables.</li><li><code>Deletable</code> types may be safely deallocated by pointer using the <code>Delete</code>
method on the <code>Allocator</code> used to allocate it.</li><li><code>Destructible</code> types have a destructor and may be deallocated by pointer
using the <code>UnsafeDelete</code> method on the correct <code>Allocator</code>, but it may be
unsafe. The concerning case is deleting a pointer to a derived class through
a pointer to its base class without a virtual destructor.</li><li><code>TrivialDestructor</code> types have empty destructors. This type-of-type may be
used with <a href="#lookup-resolution-and-specialization">specialization</a> to unlock
specific optimizations.</li></ul><p><strong>Note:</strong> The names <code>Deletable</code> and <code>Destructible</code> are
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//proposals/p1154.md#type-of-type-naming" target="_blank" rel="noopener noreferrer"><strong>placeholders</strong></a> since they do not
conform to the decision on
<a href="https://github.com/carbon-language/carbon-lang/issues/1058" target="_blank" rel="noopener noreferrer">question-for-leads issue #1058: &quot;How should interfaces for core functionality be named?&quot;</a>.</p><p>The type-of-types <code>Concrete</code>, <code>Deletable</code>, and <code>TrivialDestructor</code> all extend
<code>Destructible</code>. Combinations of them may be formed using
<a href="#combining-interfaces-by-anding-type-of-types">the <code>&amp;</code> operator</a>. For example,
a generic function that both instantiates and deletes values of a type <code>T</code> would
require <code>T</code> implement <code>Concrete &amp; Deletable</code>.</p><p>Types are forbidden from explicitly implementing these type-of-types directly.
Instead they use
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/classes.md#destructors" target="_blank" rel="noopener noreferrer"><code>destructor</code> declarations in their class definition</a>
and the compiler uses them to determine which of these type-of-types are
implemented.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="generic-let">Generic <code>let</code><a class="hash-link" href="#generic-let" title="Direct link to heading">​</a></h2><p>A <code>let</code> statement inside a function body may be used to get the change in type
behavior of calling a generic function without having to introduce a function
call.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn F(...) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let T:! C = U;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  X;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>gets rewritten to:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn F(...) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Closure(T:! C where .Self == U) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    X;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Closure(U);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The <code>where .Self == U</code> modifier allows values to implicitly convert between type
<code>T</code>, the erased type, and type <code>U</code>, the concrete type. Note that implicit
conversion is
<a href="#manual-type-equality">only performed across a single <code>where</code> equality</a>. This
can be used to switch to the API of <code>C</code> when it is external, as an alternative
to <a href="#use-case-accessing-external-names">using an adapter</a>, or to simplify
inlining of a generic function while preserving semantics.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="parameterized-impls">Parameterized impls<a class="hash-link" href="#parameterized-impls" title="Direct link to heading">​</a></h2><p>There are cases where an impl definition should apply to more than a single type
and interface combination. The solution is to parameterize the impl definition,
so it applies to a family of types, interfaces, or both. This includes:</p><ul><li>Declare an impl for a parameterized type, which may be external or declared
out-of-line.</li><li>&quot;Conditional conformance&quot; where a parameterized type implements some
interface if the parameter to the type satisfies some criteria, like
implementing the same interface.</li><li>&quot;Blanket&quot; impls where an interface is implemented for all types that
implement another interface, or some other criteria beyond being a specific
type.</li><li>&quot;Wildcard&quot; impls where a family of interfaces are implemented for single
type.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="impl-for-a-parameterized-type">Impl for a parameterized type<a class="hash-link" href="#impl-for-a-parameterized-type" title="Direct link to heading">​</a></h3><p>Interfaces may be implemented for a parameterized type. This can be done
lexically in the class&#x27; scope:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Vector(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Iterable where .ElementType = T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is equivalent to naming the type between <code>impl</code> and <code>as</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Vector(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl Vector(T) as Iterable where .ElementType = T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>An impl may be declared <a href="#external-impl">external</a> by adding an <code>external</code>
keyword before <code>impl</code>. External impls may also be declared out-of-line, but all
parameters must be declared in a <code>forall</code> clause:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! Type] Vector(T) as Iterable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where .ElementType = T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The parameter for the type can be used as an argument to the interface being
implemented:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class HashMap(Key:! Hashable, Value:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Has(Key) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Contains(HashSet(Key)) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>or externally out-of-line:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class HashMap(Key:! Hashable, Value:! Type) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [Key:! Hashable, Value:! Type]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashMap(Key, Value) as Has(Key) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [Key:! Hashable, Value:! Type]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashMap(Key, Value) as Contains(HashSet(Key)) { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="conditional-conformance">Conditional conformance<a class="hash-link" href="#conditional-conformance" title="Direct link to heading">​</a></h3><p><a href="/carbon-lang/design/generics/terminology#conditional-conformance">Conditional conformance</a> is expressing
that we have an <code>impl</code> of some interface for some type, but only if some
additional type restrictions are met. Examples where this would be useful
include being able to say that a container type, like <code>Vector</code>, implements some
interface when its element type satisfies the same interface:</p><ul><li>A container is printable if its elements are.</li><li>A container could be compared to another container with the same element
type using a
<a href="https://en.wikipedia.org/wiki/Lexicographic_order" target="_blank" rel="noopener noreferrer">lexicographic comparison</a>
if the element type is comparable.</li><li>A container is copyable if its elements are.</li></ul><p>To do this with an <a href="#external-impl"><code>external impl</code></a>, specify a more-specific
<code>Self</code> type to the left of the <code>as</code> in the declaration:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Printable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Print[me: Self]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Vector(T:! Type) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// By saying &quot;T:! Printable&quot; instead of &quot;T:! Type&quot; here,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// we constrain T to be Printable for this impl.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! Printable] Vector(T) as Printable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Print[me: Self]() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (let a: T in me) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // Can call `Print` on `a` since the constraint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // on `T` ensures it implements `Printable`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      a.Print();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To define these <code>impl</code>s inline in a <code>class</code> definition, include a <code>forall</code>
clause with a more-specific type between the <code>impl</code> and <code>as</code> keywords.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Array(T:! Type, template N:! Int) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl forall [P:! Printable] Array(P, N) as Printable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It is legal to add the keyword <code>external</code> before the <code>impl</code> keyword to switch to
an external impl defined lexically within the class scope. Inside the scope,
both <code>P</code> and <code>T</code> refer to the same type, but <code>P</code> has the type-of-type of
<code>Printable</code> and so has a <code>Print</code> member. The relationship between <code>T</code> and <code>P</code> is
as if there was a <code>where P == T</code> clause.</p><p><strong>TODO:</strong> Need to resolve whether the <code>T</code> name can be reused, or if we require
that you need to use new names, like <code>P</code>, when creating new type variables.</p><p><strong>Example:</strong> Consider a type with two parameters, like <code>Pair(T, U)</code>. In this
example, the interface <code>Foo(T)</code> is only implemented when the two types are
equal.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Foo(T:! Type) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Pair(T:! Type, U:! Type) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! Type] Pair(T, T) as Foo(T) { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>You may also define the <code>impl</code> inline, in which case it can be internal:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Pair(T:! Type, U:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl Pair(T, T) as Foo(T) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Clarification:</strong> Method lookup will look at all internal implementations,
whether or not the conditions on those implementations hold for the <code>Self</code> type.
If the conditions don&#x27;t hold, then the call will be rejected because <code>Self</code> has
the wrong type, just like any other argument/parameter type mismatch. This means
types may not implement two different interfaces internally if they share a
member name, even if their conditions are mutually exclusive:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class X(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl X(i32) as Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn F[me: Self]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl X(i64) as Bar {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ❌ Illegal: name conflict between `Foo.F` and `Bar.F`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn F[me: Self](n: i64);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>However, the same interface may be implemented multiple times as long as there
is no overlap in the conditions:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class X(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl X(i32) as Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn F[me: Self]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl X(i64) as Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ✅ Allowed: `X(T).F` consistently means `X(T).(Foo.F)`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn F[me: Self]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This allows a type to express that it implements an interface for a list of
types, possibly with different implementations.</p><p>In general, <code>X(T).F</code> can only mean one thing, regardless of <code>T</code>.</p><p><strong>Comparison with other languages:</strong>
<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md" target="_blank" rel="noopener noreferrer">Swift supports conditional conformance</a>,
but bans cases where there could be ambiguity from overlap.
<a href="https://doc.rust-lang.org/rust-by-example/generics/where.html" target="_blank" rel="noopener noreferrer">Rust also supports conditional conformance</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="conditional-methods">Conditional methods<a class="hash-link" href="#conditional-methods" title="Direct link to heading">​</a></h4><p>A method could be defined conditionally for a type by using a more specific type
in place of <code>Self</code> in the method declaration. For example, this is how to define
a vector type that only has a <code>Sort</code> method if its elements implement the
<code>Comparable</code> interface:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Vector(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `Vector(T)` has a `Sort()` method if `T` is `Comparable`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Sort[C:! Comparable, addr me: Vector(C)*]();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Comparison with other languages:</strong> In
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods" target="_blank" rel="noopener noreferrer">Rust</a>
this feature is part of conditional conformance. Swift supports conditional
methods using
<a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID553" target="_blank" rel="noopener noreferrer">conditional extensions</a>
or
<a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID628" target="_blank" rel="noopener noreferrer">contextual where clauses</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="blanket-impls">Blanket impls<a class="hash-link" href="#blanket-impls" title="Direct link to heading">​</a></h3><p>A <em>blanket impl</em> is an <code>impl</code> that could apply to more than one root type, so
the <code>impl</code> will use a type variable for the <code>Self</code> type. Here are some examples
where blanket impls arise:</p><ul><li><p>Any type implementing <code>Ordered</code> should get an implementation of
<code>PartiallyOrdered</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! Ordered] T as PartiallyOrdered { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p><code>T</code> implements <code>CommonType(T)</code> for all <code>T</code></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! Type] T as CommonType(T)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where .Result = T { }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This means that every type is the common type with itself.</p></li></ul><p>Blanket impls must always be <a href="#external-impl">external</a> and defined lexically
out-of-line.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="difference-between-blanket-impls-and-named-constraints">Difference between blanket impls and named constraints<a class="hash-link" href="#difference-between-blanket-impls-and-named-constraints" title="Direct link to heading">​</a></h4><p>A blanket interface can be used to say &quot;any type implementing <code>interface I</code> also
implements <code>interface B</code>.&quot; Compare this with defining a <code>constraint C</code> that
requires <code>I</code>. In that case, <code>C</code> will also be implemented any time <code>I</code> is. There
are differences though:</p><ul><li>There can be other implementations of <code>interface B</code> without a corresponding
implementation of <code>I</code>, unless <code>B</code> has a requirement on <code>I</code>. However, the
types implementing <code>C</code> will be the same as the types implementing <code>I</code>.</li><li>More specialized implementations of <code>B</code> can override the blanket
implementation.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="wildcard-impls">Wildcard impls<a class="hash-link" href="#wildcard-impls" title="Direct link to heading">​</a></h3><p>A <em>wildcard impl</em> is an impl that defines a family of interfaces for a single
<code>Self</code> type. For example, the <code>BigInt</code> type might implement <code>AddTo(T)</code> for all
<code>T</code> that implement <code>ImplicitAs(i32)</code>. The implementation would first convert <code>T</code>
to <code>i32</code> and then add the <code>i32</code> to the <code>BigInt</code> value.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class BigInt {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  external impl forall [T:! ImplicitAs(i32)] as AddTo(T) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Or out-of-line:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! ImplicitAs(i32)] BigInt as AddTo(T) { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Wildcard impls must always be <a href="#external-impl">external</a>, to avoid having the
names in the interface defined for the type multiple times.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="combinations">Combinations<a class="hash-link" href="#combinations" title="Direct link to heading">​</a></h3><p>The different kinds of parameters to impls may be combined. For example, if <code>T</code>
implements <code>As(U)</code>, then this implements <code>As(Optional(U))</code> for <code>Optional(T)</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [U:! Type, T:! As(U)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Optional(T) as As(Optional(U)) { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This has a wildcard parameter <code>U</code>, and a condition on parameter <code>T</code>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="lookup-resolution-and-specialization">Lookup resolution and specialization<a class="hash-link" href="#lookup-resolution-and-specialization" title="Direct link to heading">​</a></h3><p>As much as possible, we want rules for where an impl is allowed to be defined
and for selecting which impl to use that achieve these three goals:</p><ul><li>Implementations have coherence, as
<a href="/carbon-lang/design/generics/terminology#coherence">defined in terminology</a>. This is
<a href="/carbon-lang/design/generics/goals#coherence">a goal for Carbon</a>. More detail can be found in
<a href="/carbon-lang/design/generics/appendix-coherence">this appendix with the rationale and alternatives considered</a>.</li><li>Libraries will work together as long as they pass their separate checks.</li><li>A generic function can assume that some impl will be successfully selected
if it can see an impl that applies, even though another more specific impl
may be selected.</li></ul><p>For this to work, we need a rule that picks a single <code>impl</code> in the case where
there are multiple <code>impl</code> definitions that match a particular type and interface
combination. This is called <em>specialization</em> when the rule is that most specific
implementation is chosen, for some definition of specific.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="type-structure-of-an-impl-declaration">Type structure of an impl declaration<a class="hash-link" href="#type-structure-of-an-impl-declaration" title="Direct link to heading">​</a></h4><p>Given an impl declaration, find the type structure by deleting deduced
parameters and replacing type parameters by a <code>?</code>. The type structure of this
declaration:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl forall [T:! ..., U:! ...] Foo(T, i32) as Bar(String, U) { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>is:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Foo(?, i32) as Bar(String, ?)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To get a uniform representation across different <code>impl</code> definitions, before type
parameters are replaced the declarations are normalized as follows:</p><ul><li>For impls declared lexically inline in a class definition, the type is added
between the <code>impl</code> and <code>as</code> keywords if the type is left out.</li><li>Pointer types <code>T*</code> are replaced with <code>Ptr(T)</code>.</li><li>The <code>external</code> keyword is removed, if present.</li><li>The <code>forall</code> clause introducing type parameters is removed, if present.</li><li>Any <code>where</code> clauses that are setting associated constants or types are
removed.</li></ul><p>The type structure will always contain a single interface name, which is the
name of the interface being implemented, and some number of type names. Type
names can be in the <code>Self</code> type to the left of the <code>as</code> keyword, or as
parameters to other types or the interface. These names must always be defined
either in the current library or be publicly defined in some library this
library depends on.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="orphan-rule">Orphan rule<a class="hash-link" href="#orphan-rule" title="Direct link to heading">​</a></h4><p>To achieve coherence, we need to ensure that any given impl can only be defined
in a library that must be imported for it to apply. Specifically, given a
specific type and specific interface, impls that can match can only be in
libraries that must have been imported to name that type or interface. This is
achieved with the <em>orphan rule</em>.</p><p><strong>Orphan rule:</strong> Some name from the type structure of an <code>impl</code> declaration must
be defined in the same library as the <code>impl</code>, that is some name must be <em>local</em>.</p><p>Only the implementing interface and types (self type and type parameters) in the
type structure are relevant here; an interface mentioned in a constraint is not
sufficient since it
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//proposals/p0920.md#orphan-rule-could-consider-interface-requirements-in-blanket-impls" target="_blank" rel="noopener noreferrer">need not be imported</a>.</p><p>Since Carbon in addition requires there be no cyclic library dependencies, we
conclude that there is at most one library that can define impls with a
particular type structure.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="overlap-rule">Overlap rule<a class="hash-link" href="#overlap-rule" title="Direct link to heading">​</a></h4><p>Given a specific concrete type, say <code>Foo(bool, i32)</code>, and an interface, say
<code>Bar(String, f32)</code>, the overlap rule picks, among all the matching impls, which
type structure is considered &quot;most specific&quot; to use as the implementation of
that type for that interface.</p><p>Given two different type structures of impls matching a query, for example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Foo(?, i32) as Bar(String, ?)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Foo(?, ?) as Bar(String, f32)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We pick the type structure with a non-<code>?</code> at the first difference as most
specific. Here we see a difference between <code>Foo(?, i32)</code> and <code>Foo(?, ?)</code>, so we
select the one with <code>Foo(?, i32)</code>, ignoring the fact that it has another <code>?</code>
later in its type structure</p><p>This rule corresponds to a depth-first traversal of the type tree to identify
the first difference, and then picking the most specific choice at that
difference.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="prioritization-rule">Prioritization rule<a class="hash-link" href="#prioritization-rule" title="Direct link to heading">​</a></h4><p>Since at most one library can define impls with a given type structure, all
impls with a given type structure must be in the same library. Furthermore by
the <a href="#access">impl declaration access rules</a>, they will be defined in the API
file for the library if they could match any query from outside the library. If
there is more than one impl with that type structure, they must be
<a href="#implementing-interfaces">defined</a> or <a href="#declaring-implementations">declared</a>
together in a prioritization block. Once a type structure is selected for a
query, the first impl in the prioritization block that matches is selected.</p><p><strong>Open question:</strong> How are prioritization blocks written? A block starts with a
keyword like <code>match_first</code> or <code>impl_priority</code> and then a sequence of impl
declarations inside matching curly braces <code>{</code> ... <code>}</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match_first {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // If T is Foo prioritized ahead of T is Bar</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl forall [T:! Foo] T as Bar { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl forall [T:! Baz] T as Bar { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Open question:</strong> How do we pick between two different prioritization blocks
when they contain a mixture of type structures? There are three options:</p><ul><li>Prioritization blocks implicitly define all non-empty intersections of
contained impls, which are then selected by their type structure.</li><li>The compiler first picks the impl with the type pattern most favored for the
query, and then picks the definition of the highest priority matching impl
in the same prioritization block.</li><li>All the impls in a prioritization block are required to have the same type
structure, at a cost in expressivity.</li></ul><p>To see the difference between the first two options, consider two libraries with
type structures as follows:</p><ul><li>Library B has <code>impl (A, ?, ?, D) as I</code> and <code>impl (?, B, ?, D) as I</code> in the
same prioritization block.</li><li>Library C has <code>impl (A, ?, C, ?) as I</code>.</li></ul><p>For the query <code>(A, B, C, D) as I</code>, using the intersection rule, library B is
considered to have the intersection impl with type structure
<code>impl (A, B, ?, D) as I</code> which is the most specific. If we instead just
considered the rules mentioned explicitly, then <code>impl (A, ?, C, ?) as I</code> from
library C is the most specific. The advantage of the implicit intersection rule
is that if library B is changed to add an impl with type structure
<code>impl (A, B, ?, D) as I</code>, it won&#x27;t shift which library is serving that query.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="acyclic-rule">Acyclic rule<a class="hash-link" href="#acyclic-rule" title="Direct link to heading">​</a></h4><p>A cycle is when a query, such as &quot;does type <code>T</code> implement interface <code>I</code>?&quot;,
considers an impl that might match, and whether that impl matches is ultimately
dependent on whether that query is true. These are cycles in the graph of (type,
interface) pairs where there is an edge from pair A to pair B if whether type A
implements interface A determines whether type B implements interface B.</p><p>The test for whether something forms a cycle needs to be precise enough, and not
erase too much information when considering this graph, that these impls are not
considered to form cycles with themselves:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl forall [T:! Printable] Optional(T) as Printable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl forall [T:! Type, U:! ComparableTo(T)] U as ComparableTo(Optional(T));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Example:</strong> If <code>T</code> implements <code>ComparableWith(U)</code>, then <code>U</code> should implement
<code>ComparableWith(T)</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [U:! Type, T:! ComparableWith(U)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    U as ComparableWith(T);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is a cycle where which types implement <code>ComparableWith</code> determines which
types implement the same interface.</p><p><strong>Example:</strong> Cycles can create situations where there are multiple ways of
selecting impls that are inconsistent with each other. Consider an interface
with two blanket <code>impl</code> declarations:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Y {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class N {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface True {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Y as True {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Z(T:! Type) { let Cond:! Type; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">match_first {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl forall [T:! Type, U:! Z(T) where .Cond is True] T as Z(U)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      where .Cond = N { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl forall [T:! Type, U:! Type] T as Z(U)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      where .Cond = Y { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>What is <code>i8.(Z(i16).Cond)</code>? It depends on which of the two blanket impls are
selected.</p><ul><li>An implementation of <code>Z(i16)</code> for <code>i8</code> could come from the first blanket
impl with <code>T == i8</code> and <code>U == i16</code> if <code>i16 is Z(i8)</code> and
<code>i16.(Z(i8).Cond) == Y</code>. This condition is satisfied if <code>i16</code> implements
<code>Z(i8)</code> using the second blanket impl. In this case,
<code>i8.(Z(i16).Cond) == N</code>.</li><li>Equally well <code>Z(i8)</code> could be implemented for <code>i16</code> using the first blanket
impl and <code>Z(i16)</code> for <code>i8</code> using the second. In this case,
<code>i8.(Z(i16).Cond) == Y</code>.</li></ul><p>There is no reason to to prefer one of these outcomes over the other.</p><p><strong>Example:</strong> Further, cycles can create contradictions in the type system:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class A {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class B {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class C {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface D(T:! Type) { let Cond:! Type; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">match_first {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl forall [T:! Type, U:! D(T) where .Cond = B] T as D(U)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      where .Cond = C { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl forall [T:! Type, U:! D(T) where .Cond = A] T as D(U)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      where .Cond = B { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl forall [T:! Type, U:! Type] T as D(U)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      where .Cond = A { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>What is <code>i8.(D(i16).Cond)</code>? The answer is determined by which blanket impl is
selected to implement <code>D(i16)</code> for <code>i8</code>:</p><ul><li>If the third blanket impl is selected, then <code>i8.(D(i16).Cond) == A</code>. This
implies that <code>i16.(D(i8).Cond) == B</code> using the second blanket impl. If that
is true, though, then our first impl choice was incorrect, since the first
blanket impl applies and is higher priority. So <code>i8.(D(i16).Cond) == C</code>. But
that means that <code>i16 as D(i8)</code> can&#x27;t use the second blanket impl.</li><li>For the second blanket impl to be selected, so <code>i8.(D(i16).Cond) == B</code>,
<code>i16.(D(i8).Cond)</code> would have to be <code>A</code>. This happens when <code>i16</code> implements
<code>D(i8)</code> using the third blanket impl. However, <code>i8.(D(i16).Cond) == B</code> means
that there is a higher priority implementation of <code>D(i8).Cond</code> for <code>i16</code>.</li></ul><p>In either case, we arrive at a contradiction.</p><p>The workaround for this problem is to either split an interface in the cycle in
two, with a blanket implementation of one from the other, or move some of the
criteria into a <a href="#named-constraints">named constraint</a>.</p><p><strong>Concern:</strong> Cycles could be spread out across libraries with no dependencies
between them. This means there can be problems created by a library that are
only detected by its users.</p><p><strong>Open question:</strong> Should Carbon reject cycles in the absence of a query? The
two options here are:</p><ul><li>Combining impls gives you an immediate error if there exists queries using
those impls that have cycles.</li><li>Only when a query reveals a cyclic dependency is an error reported.</li></ul><p><strong>Open question:</strong> In the second case, should we ignore cycles if they don&#x27;t
affect the result of the query? For example, the cycle might be among
implementations that are lower priority.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="termination-rule">Termination rule<a class="hash-link" href="#termination-rule" title="Direct link to heading">​</a></h4><p>It is possible to define a set of impls where there isn&#x27;t a cycle, but the graph
is infinite. Without some rule to prevent exhaustive exploration of the graph,
determining whether a type implements an interface could run forever.</p><p><strong>Example:</strong> It could be that <code>A</code> implements <code>B</code>, so <code>A is B</code> if
<code>Optional(A) is B</code>, if <code>Optional(Optional(A)) is B</code>, and so on. This could be
the result of a single impl:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl forall [A:! Type where Optional(.Self) is B] A as B { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This problem can also result from a chain of impls, as in <code>A is B</code> if <code>A* is C</code>,
if <code>Optional(A) is B</code>, and so on.</p><p>Rust solves this problem by imposing a recursion limit, much like C++ compilers
use to terminate template recursion. This goes against
<a href="/carbon-lang/design/generics/goals#predictability">Carbon&#x27;s goal of predictability in generics</a>, but at
this time there are no known alternatives. Unfortunately, the approach Carbon
uses to avoid undecidability for type equality,
<a href="#manual-type-equality">providing an explicit proof in the source</a>, can&#x27;t be
used here. The code triggering the query asking whether some type implements an
interface will typically be generic code with know specific knowledge about the
types involved, and won&#x27;t be in a position to provide a manual proof that the
implementation should exist.</p><p><strong>Open question:</strong> Is there some restriction on <code>impl</code> declarations that would
allow our desired use cases, but allow the compiler to detect non-terminating
cases? Perhaps there is some sort of complexity measure Carbon can require
doesn&#x27;t increase when recursing?</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="final-impls"><code>final</code> impls<a class="hash-link" href="#final-impls" title="Direct link to heading">​</a></h3><p>There are cases where knowing that a parameterized impl won&#x27;t be specialized is
particularly valuable. This could let the compiler know the return type of a
generic function call, such as using an operator:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Interface defining the behavior of the prefix-* operator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Deref {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Result:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn DoDeref[me: Self]() -&gt; Result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Types implementing `Deref`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Ptr(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  external impl as Deref where .Result = T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn DoDeref[me: Self]() -&gt; Result { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Optional(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  external impl as Deref where .Result = T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn DoDeref[me: Self]() -&gt; Result { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn F[T:! Type](x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // uses Ptr(T) and Optional(T) in implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The concern is the possibility of specializing <code>Optional(T) as Deref</code> or
<code>Ptr(T) as Deref</code> for a more specific <code>T</code> means that the compiler can&#x27;t assume
anything about the return type of <code>Deref.DoDeref</code> calls. This means <code>F</code> would in
practice have to add a constraint, which is both verbose and exposes what should
be implementation details:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn F[T:! Type where Optional(T).(Deref.Result) == .Self</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                and Ptr(T).(Deref.Result) == .Self](x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // uses Ptr(T) and Optional(T) in implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To mark an impl as not able to be specialized, prefix it with the keyword
<code>final</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Ptr(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Note: added `final`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  final external impl as Deref where .Result = T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn DoDeref[me: Self]() -&gt; Result { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Optional(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Note: added `final`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  final external impl as Deref where .Result = T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn DoDeref[me: Self]() -&gt; Result { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Illegal: external impl Ptr(i32) as Deref { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Illegal: external impl Optional(i32) as Deref { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This prevents any higher-priority impl that overlaps a final impl from being
defined. Further, if the Carbon compiler sees a matching final impl, it can
assume it won&#x27;t be specialized so it can use the assignments of the associated
types in that impl definition.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn F[T:! Type](x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var p: Ptr(T) = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // *p has type `T`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var o: Optional(T) = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // *o has type `T`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="libraries-that-can-contain-final-impls">Libraries that can contain <code>final</code> impls<a class="hash-link" href="#libraries-that-can-contain-final-impls" title="Direct link to heading">​</a></h4><p>To prevent the possibility of two unrelated libraries defining conflicting
impls, Carbon restricts which libraries may declare an impl as <code>final</code> to only:</p><ul><li>the library declaring the impl&#x27;s interface and</li><li>the library declaring the root of the <code>Self</code> type.</li></ul><p>This means:</p><ul><li>A blanket impl with type structure <code>impl ? as MyInterface(...)</code> may only be
defined in the same library as <code>MyInterface</code>.</li><li>An impl with type structure <code>impl MyType(...) as MyInterface(...)</code> may be
defined in the library with <code>MyType</code> or <code>MyInterface</code>.</li></ul><p>These restrictions ensure that the Carbon compiler can locally check that no
higher-priority impl is defined superseding a <code>final</code> impl.</p><ul><li>An impl with type structure <code>impl MyType(...) as MyInterface(...)</code> defined
in the library with <code>MyType</code> must import the library defining <code>MyInterface</code>,
and so will be able to see any final blanket impls.</li><li>A blanket impl with type structure
<code>impl ? as MyInterface(...ParameterType(...)...)</code> may be defined in the
library with <code>ParameterType</code>, but that library must import the library
defining <code>MyInterface</code>, and so will be able to see any <code>final</code> blanket impls
that might overlap. A final impl with type structure
<code>impl MyType(...) as MyInterface(...)</code> would be given priority over any
overlapping blanket impl defined in the <code>ParameterType</code> library.</li><li>An impl with type structure
<code>impl MyType(...ParameterType(...)...) as MyInterface(...)</code> may be defined
in the library with <code>ParameterType</code>, but that library must import the
libraries defining <code>MyType</code> and <code>MyInterface</code>, and so will be able to see
any <code>final</code> impls that might overlap.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="comparison-to-rust">Comparison to Rust<a class="hash-link" href="#comparison-to-rust" title="Direct link to heading">​</a></h3><p>Rust has been designing a specialization feature, but it has not been completed.
Luckily, Rust team members have done a lot of blogging during their design
process, so Carbon can benefit from the work they have done. However, getting
specialization to work for Rust is complicated by the need to maintain
compatibility with existing Rust code. This motivates a number of Rust rules
where Carbon can be simpler. As a result there are both similarities and
differences between the Carbon and Rust plans:</p><ul><li>A Rust impl defaults to not being able to be specialized, with a <code>default</code>
keyword used to opt-in to allowing specialization, reflecting the existing
code base developed without specialization. Carbon impls default to allowing
specialization, with restrictions on which may be declared <code>final</code>.</li><li>Since Rust impls are not specializable by default, generic functions can
assume that if a matching blanket impl is found, the associated types from
that impl will be used. In Carbon, if a generic function requires an
associated type to have a particular value, the function commonly will need
to state that using an explicit constraint.</li><li>Carbon will not have the &quot;fundamental&quot; attribute used by Rust on types or
traits, as described in
<a href="https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html" target="_blank" rel="noopener noreferrer">Rust RFC 1023: &quot;Rebalancing Coherence&quot;</a>.</li><li>Carbon will not use &quot;covering&quot; rules, as described in
<a href="https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html" target="_blank" rel="noopener noreferrer">Rust RFC 2451: &quot;Re-Rebalancing Coherence&quot;</a>
and
<a href="http://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/#the-covered-rule" target="_blank" rel="noopener noreferrer">Little Orphan Impls: The covered rule</a>.</li><li>Like Rust, Carbon does use ordering, favoring the <code>Self</code> type and then the
parameters to the interface in left-to-right order, see
<a href="https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html" target="_blank" rel="noopener noreferrer">Rust RFC 1023: &quot;Rebalancing Coherence&quot;</a>
and
<a href="http://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/#the-ordered-rule" target="_blank" rel="noopener noreferrer">Little Orphan Impls: The ordered rule</a>,
but the specifics are different.</li><li>Carbon is not planning to support any inheritance of implementation between
impls. This is more important to Rust since Rust does not support class
inheritance for implementation reuse. Rust has considered multiple
approaches here, see
<a href="http://aturon.github.io/tech/2015/09/18/reuse/" target="_blank" rel="noopener noreferrer">Aaron Turon: &quot;Specialize to Reuse&quot;</a>
and
<a href="http://smallcultfollowing.com/babysteps/blog/2016/10/24/supporting-blanket-impls-in-specialization/" target="_blank" rel="noopener noreferrer">Supporting blanket impls in specialization</a>.</li><li><a href="http://smallcultfollowing.com/babysteps/blog/2016/10/24/supporting-blanket-impls-in-specialization/" target="_blank" rel="noopener noreferrer">Supporting blanket impls in specialization</a>
proposes a specialization rule for Rust that considers type structure before
other constraints, as in Carbon, though the details differ.</li><li>Rust has more orphan restrictions to avoid there being cases where it is
ambiguous which impl should be selected. Carbon instead has picked a total
ordering on type structures, picking one as higher priority even without one
being more specific in the sense of only applying to a subset of types.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="forward-declarations-and-cyclic-references">Forward declarations and cyclic references<a class="hash-link" href="#forward-declarations-and-cyclic-references" title="Direct link to heading">​</a></h2><p>Interfaces, named constraints, and their implementations may be forward declared
and then later defined. This is needed to allow cyclic references, for example
when declaring the edges and nodes of a graph. It is also a tool that may be
used to make code more readable.</p><p>The <a href="#interfaces">interface</a>, <a href="#named-constraints">named constraint</a>, and
<a href="#implementing-interfaces">implementation</a> sections describe the syntax for
their <em>definition</em>, which consists of a declaration followed by a body contained
in curly braces <code>{</code> ... <code>}</code>. A <em>forward declaration</em> is a declaration followed
by a semicolon <code>;</code>. A forward declaration is a promise that the entity being
declared will be defined later. Between the first declaration of an entity,
which may be in a forward declaration or the first part of a definition, and the
end of the definition the interface or implementation is called <em>incomplete</em>.
There are additional restrictions on how the name of an incomplete entity may be
used.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="declaring-interfaces-and-named-constraints">Declaring interfaces and named constraints<a class="hash-link" href="#declaring-interfaces-and-named-constraints" title="Direct link to heading">​</a></h3><p>The declaration for an interface or named constraint consists of:</p><ul><li>an optional access-control keyword like <code>private</code>,</li><li>the keyword introducer <code>interface</code>, <code>constraint</code>, or <code>template constraint</code>,</li><li>the name of the interface or constraint, and</li><li>the parameter list, if any.</li></ul><p>The name of an interface or constraint can not be used until its first
declaration is complete. In particular, it is illegal to use the name of the
interface in its parameter list. There is a
<a href="#interfaces-with-parameters-constrained-by-the-same-interface">workaround</a> for
the use cases when this would come up.</p><p>An expression forming a constraint, such as <code>C &amp; D</code>, is incomplete if any of the
interfaces or constraints used in the expression are incomplete. A constraint
expression using a <a href="#where-constraints"><code>where</code> clause</a>, like <code>C where ...</code>, is
invalid if <code>C</code> is incomplete, since there is no way to look up member names of
<code>C</code> that appear after <code>where</code>.</p><p>An interface or named constraint may be forward declared subject to these rules:</p><ul><li>The definition must be in the same file as the declaration.</li><li>Only the first declaration may have an access-control keyword.</li><li>An incomplete interface or named constraint may be used as constraints in
declarations of types, functions, interfaces, or named constraints. This
includes an <code>impl as</code> or <code>extends</code> declaration inside an interface or named
constraint, but excludes specifying the values for associated constants
because that would involve name lookup into the incomplete constraint.</li><li>An attempt to define the body of a generic function using an incomplete
interface or named constraint is illegal.</li><li>An attempt to call a generic function using an incomplete interface or named
constraint in its signature is illegal.</li><li>Any name lookup into an incomplete interface or named constraint is an
error. For example, it is illegal to attempt to access a member of an
interface using <code>MyInterface.MemberName</code> or constrain a member using a
<code>where</code> clause.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="declaring-implementations">Declaring implementations<a class="hash-link" href="#declaring-implementations" title="Direct link to heading">​</a></h3><p>The declaration of an interface implementation consists of:</p><ul><li>optional modifier keywords <code>final</code>, <code>external</code>,</li><li>the keyword introducer <code>impl</code>,</li><li>an optional deduced parameter list in square brackets <code>[</code>...<code>]</code>,</li><li>a type, including an optional parameter pattern,</li><li>the keyword <code>as</code>, and</li><li>a <a href="#type-of-types">type-of-type</a>, including an optional
<a href="#parameterized-interfaces">parameter pattern</a> and
<a href="#where-constraints"><code>where</code> clause</a> assigning
<a href="#associated-constants">associated constants</a> and
<a href="#associated-types">associated types</a>.</li></ul><p>An implementation of an interface for a type may be forward declared subject to
these rules:</p><ul><li>The definition must be in the same library as the declaration. They must
either be in the same file, or the declaration can be in the API file and
the definition in an impl file. <strong>Future work:</strong> Carbon may require the
definition of <a href="#parameterized-impls">parameterized impls</a> to be in the API
file, to support separate compilation.</li><li>If there is both a forward declaration and a definition, only the first
declaration must specify the assignment of associated constants with a
<code>where</code> clause. Later declarations may omit the <code>where</code> clause by writing
<code>where _</code> instead.</li><li>You may forward declare an implementation of a defined interface but not an
incomplete interface. This allows the assignment of associated constants in
the <code>impl</code> declaration to be verified. An impl forward declaration may be
for any declared type, whether it is incomplete or defined. Note that this
does not apply to <code>impl as</code> declarations in an interface or named constraint
definition, as those are considered interface requirements not forward
declarations.</li><li>Every internal implementation must be declared (or defined) inside the scope
of the class definition. It may also be declared before the class definition
or defined afterwards. Note that the class itself is incomplete in the scope
of the class definition, but member function bodies defined inline are
processed
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/project/principles/information_accumulation.md#exceptions" target="_blank" rel="noopener noreferrer">as if they appeared immediately after the end of the outermost enclosing class</a>.</li><li>For <a href="/carbon-lang/design/generics/goals#coherence">coherence</a>, we require that any impl that matches
an <a href="#impl-lookup">impl lookup</a> query in the same file, must be declared
before the query. This can be done with a definition or a forward
declaration.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="matching-and-agreeing">Matching and agreeing<a class="hash-link" href="#matching-and-agreeing" title="Direct link to heading">​</a></h3><p>Carbon needs to determine if two declarations match in order to say which
definition a forward declaration corresponds to and to verify that nothing is
defined twice. Declarations that match must also agree, meaning they are
consistent with each other.</p><p>Interface and named constraint declarations match if their names are the same
after name and alias resolution. To agree:</p><ul><li>The introducer keyword or keywords much be the same.</li><li>The types and order of parameters in the parameter list, if any, must match.
The parameter names may be omitted, but if they are included in both
declarations, they must match.</li><li>Types agree if they correspond to the same expression tree, after name and
alias resolution and canonicalization of parentheses. Note that no other
evaluation of type expressions is performed.</li></ul><p>Interface implementation declarations match if the type and interface
expressions match:</p><ul><li>If the type part is omitted, it is rewritten to <code>Self</code> in the context of the
declaration.</li><li><code>Self</code> is rewritten to its meaning in the scope it is used. In a class
scope, this should match the type name and optional parameter expression
after <code>class</code>. So in <code>class MyClass extends MyBase { ... }</code>, <code>Self</code> is
rewritten to <code>MyClass</code>. In <code>class Vector(T:! Movable) { ... }</code>, <code>Self</code> is
rewritten to <code>Vector(T:! Movable)</code>.</li><li>Types match if they have the same name after name and alias resolution and
the same parameters, or are the same type parameter.</li><li>Interfaces match if they have the same name after name and alias resolution
and the same parameters. Note that a named constraint that is equivalent to
an interface, as in <code>constraint Equivalent { extends MyInterface; }</code>, is not
considered to match.</li></ul><p>For implementations to agree:</p><ul><li>The presence of modifier keywords such as <code>external</code> before <code>impl</code> must
match between a forward declaration and definition.</li><li>If either declaration includes a <code>where</code> clause, they must both include one.
If neither uses <code>where _</code>, they must match in that they produce the
associated constants with the same values considered separately.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="declaration-examples">Declaration examples<a class="hash-link" href="#declaration-examples" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Forward declaration of interfaces</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Interface1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Interface2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Interface3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Interface4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Interface5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Interface6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Forward declaration of class type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class MyClass;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Illegal: Can&#x27;t declare implementation of incomplete</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//             interface.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// external impl MyClass as Interface1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Definition of interfaces that were previously declared</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Interface1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let T1:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Interface2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let T2:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Interface3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let T3:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Interface4 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let T4:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Forward declaration of external implementations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl MyClass as Interface1 where .T1 = i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl MyClass as Interface2 where .T2 = bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Forward declaration of an internal implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl MyClass as Interface3 where .T3 = f32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl MyClass as Interface4 where .T4 = String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Interface5 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let T5:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Interface6 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let T6:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Definition of the previously declared class type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class MyClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Definition of previously declared external impl.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Note: no need to repeat assignments to associated</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // constants.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  external impl as Interface1 where _ { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Definition of previously declared internal impl.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Note: allowed even though `MyClass` is incomplete.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Note: allowed but not required to repeat `where`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // clause.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Interface3 where .T3 = f32 { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Redeclaration of previously declared internal impl.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Every internal implementation must be declared in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // the class definition.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Interface4 where _;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Forward declaration of external implementation.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  external impl MyClass as Interface5 where .T5 = u64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Forward declaration of internal implementation.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl MyClass as Interface6 where .T6 = u8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// It would be legal to move the following definitions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// from the API file to the implementation file for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// this library.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Definition of previously declared external impls.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl MyClass as Interface2 where _ { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl MyClass as Interface5 where _ { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Definition of previously declared internal impls.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl MyClass as Interface4 where _ { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl MyClass as Interface6 where _ { }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="example-of-declaring-interfaces-with-cyclic-references">Example of declaring interfaces with cyclic references<a class="hash-link" href="#example-of-declaring-interfaces-with-cyclic-references" title="Direct link to heading">​</a></h3><p>In this example, <code>Node</code> has an <code>EdgeType</code> associated type that is constrained to
implement <code>Edge</code>, and <code>Edge</code> has a <code>NodeType</code> associated type that is
constrained to implement <code>Node</code>. Furthermore, the <code>NodeType</code> of an <code>EdgeType</code> is
the original type, and the other way around. This is accomplished by naming and
then forward declaring the constraints that can&#x27;t be stated directly:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Forward declare interfaces used in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// parameter lists of constraints.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Edge;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Forward declare named constraints used in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// interface definitions.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private constraint EdgeFor(N:! Node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private constraint NodeFor(E:! Edge);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Define interfaces using named constraints.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Edge {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let NodeType:! NodeFor(Self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Head[me: Self]() -&gt; NodeType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Node {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let EdgeType:! EdgeFor(Self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Edges[me: Self]() -&gt; Vector(EdgeType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Now that the interfaces are defined, can</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// refer to members of the interface, so it is</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// now legal to define the named constraints.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint EdgeFor(N:! Node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Edge where .NodeType == N;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint NodeFor(E:! Edge) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Node where .EdgeType == E;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="interfaces-with-parameters-constrained-by-the-same-interface">Interfaces with parameters constrained by the same interface<a class="hash-link" href="#interfaces-with-parameters-constrained-by-the-same-interface" title="Direct link to heading">​</a></h3><p>To work around
<a href="#declaring-interfaces-and-named-constraints">the restriction about not being able to name an interface in its parameter list</a>,
instead include that requirement in the body of the interface.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Want to require that `T` satisfies `CommonType(Self)`,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// but that can&#x27;t be done in the parameter list.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface CommonType(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Result:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Instead add the requirement inside the definition.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl T as CommonType(Self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note however that <code>CommonType</code> is still incomplete inside its definition, so no
constraints on members of <code>CommonType</code> are allowed.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface CommonType(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Result:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ❌ Illegal: `CommonType` is incomplete</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl T as CommonType(Self) where .Result == Result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Instead, a forward-declared named constraint can be used in place of the
constraint that can only be defined later. This is
<a href="#example-of-declaring-interfaces-with-cyclic-references">the same strategy used to work around cyclic references</a>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private constraint CommonTypeResult(T:! Type, R:! Type);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface CommonType(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Result:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `CommonTypeResult` is incomplete, but</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //             no members are accessed.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl T as CommonTypeResult(Self, Result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint CommonTypeResult(T:! Type, R:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends CommonType(T) where .Result == R;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="interface-members-with-definitions">Interface members with definitions<a class="hash-link" href="#interface-members-with-definitions" title="Direct link to heading">​</a></h2><p>Interfaces may provide definitions for members, such as a function body for an
associated function or method or a value for an associated constant. If these
definitions may be overridden in implementations, they are called &quot;defaults&quot; and
prefixed with the <code>default</code> keyword. Otherwise they are called &quot;final members&quot;
and prefixed with the <code>final</code> keyword.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="interface-defaults">Interface defaults<a class="hash-link" href="#interface-defaults" title="Direct link to heading">​</a></h3><p>An interface may provide a default implementation of methods in terms of other
methods in the interface.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Vector {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Add[me: Self](b: Self) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Scale[me: Self](v: f64) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Default definition of `Invert` calls `Scale`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  default fn Invert[me: Self]() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return me.Scale(-1.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A default function or method may also be defined out of line, later in the same
file as the interface definition:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Vector {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Add[me: Self](b: Self) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Scale[me: Self](v: f64) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  default fn Invert[me: Self]() -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `Vector` is considered complete at this point,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// even though `Vector.Invert` is still incomplete.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn Vector.Invert[me: Self]() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return me.Scale(-1.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>An impl of that interface for a type may omit a definition of <code>Invert</code> to use
the default, or provide a definition to override the default.</p><p>Interface defaults are helpful for <a href="#evolution">evolution</a>, as well as reducing
boilerplate. Defaults address the gap between the minimum necessary for a type
to provide the desired functionality of an interface and the breadth of API that
developers desire. As an example, in Rust the
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html" target="_blank" rel="noopener noreferrer">iterator trait</a> only
has one required method but dozens of &quot;provided methods&quot; with defaults.</p><p>Defaults may also be provided for associated constants, such as associated
types, and interface parameters, using the <code>= &lt;default value&gt;</code> syntax.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Add(Right:! Type = Self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  default let Result:! Type = Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn DoAdd[me: Self](right: Right) -&gt; Result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl String as Add() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Right == Result == Self == String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn DoAdd[me: Self](right: Self) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that <code>Self</code> is a legal default value for an associated type or type
parameter. In this case the value of those names is not determined until <code>Self</code>
is, so <code>Add()</code> is equivalent to the constraint:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Equivalent to Add()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constraint AddDefault {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extends Add(Self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note also that the parenthesis are required after <code>Add</code>, even when all
parameters are left as their default values.</p><p>More generally, default expressions may reference other associated types or
<code>Self</code> as parameters to type constructors. For example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Iterator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Element:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  default let Pointer:! Type = Element*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Carbon does <strong>not</strong> support providing a default implementation of a required
interface.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface TotalOrder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn TotalLess[me: Self](right: Self) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ❌ Illegal: May not provide definition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //             for required interface.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as PartialOrder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn PartialLess[me: Self](right: Self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return me.TotalLess(right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The workaround for this restriction is to use a <a href="#blanket-impls">blanket impl</a>
instead:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface TotalOrder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn TotalLess[me: Self](right: Self) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as PartialOrder;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! TotalOrder] T as PartialOrder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn PartialLess[me: Self](right: Self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return me.TotalLess(right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that by the <a href="#orphan-rule">orphan rule</a>, this blanket impl must be defined
in the same library as <code>PartialOrder</code>.</p><p><strong>Comparison with other languages:</strong> Rust supports specifying defaults for
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html#default-implementations" target="_blank" rel="noopener noreferrer">methods</a>,
<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#default-generic-type-parameters-and-operator-overloading" target="_blank" rel="noopener noreferrer">interface parameters</a>,
and
<a href="https://doc.rust-lang.org/reference/items/associated-items.html#associated-constants-examples" target="_blank" rel="noopener noreferrer">associated constants</a>.
Rust has found them valuable.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="final-members"><code>final</code> members<a class="hash-link" href="#final-members" title="Direct link to heading">​</a></h3><p>As an alternative to providing a definition of an interface member as a default,
members marked with the <code>final</code> keyword will not allow that definition to be
overridden in impls.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface TotalOrder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn TotalLess[me: Self](right: Self) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  final fn TotalGreater[me: Self](right: Self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return right.TotalLess(me);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as TotalOrder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn TotalLess[me: Self](right: Self) -&gt; bool { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ❌ Illegal: May not provide definition of final</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //             method `TotalGreater`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn TotalGreater[me: Self](right: Self) -&gt; bool { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Add(T:! Type = Self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `AddWith` *always* equals `T`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  final let AddWith:! Type = T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Has a *default* of `Self`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Result:! Type = Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn DoAdd[me: Self](right: AddWith) -&gt; Result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Final members may also be defined out-of-line:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface TotalOrder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn TotalLess[me: Self](right: Self) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  final fn TotalGreater[me: Self](right: Self) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `TotalOrder` is considered complete at this point, even</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// though `TotalOrder.TotalGreater` is not yet defined.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn TotalOrder.TotalGreater[me: Self](right: Self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> return right.TotalLess(me);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>There are a few reasons for this feature:</p><ul><li>When overriding would be inappropriate.</li><li>Matching the functionality of non-virtual methods in base classes, so
interfaces can be a replacement for inheritance.</li><li>Potentially reduce dynamic dispatch when using the interface in a
<a href="#dynamic-types"><code>DynPtr</code></a>.</li></ul><p>Note that this applies to associated entities, not interface parameters.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="interface-requiring-other-interfaces-revisited">Interface requiring other interfaces revisited<a class="hash-link" href="#interface-requiring-other-interfaces-revisited" title="Direct link to heading">​</a></h2><p>Recall that an
<a href="#interface-requiring-other-interfaces">interface can require another interface be implemented for the type</a>,
as in:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Iterable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Equatable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This states that the type implementing the interface <code>Iterable</code>, which in this
context is called <code>Self</code>, must also implement the interface <code>Equatable</code>. As is
done with <a href="#conditional-conformance">conditional conformance</a>, we allow another
type to be specified between <code>impl</code> and <code>as</code> to say some type other than <code>Self</code>
must implement an interface. For example,</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface IntLike {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl i32 as As(Self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>says that if <code>Self</code> implements <code>IntLike</code>, then <code>i32</code> must implement <code>As(Self)</code>.
Similarly,</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface CommonTypeWith(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl T as CommonTypeWith(Self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>says that if <code>Self</code> implements <code>CommonTypeWith(T)</code>, then <code>T</code> must implement
<code>CommonTypeWith(Self)</code>.</p><p>The previous description of <code>impl as</code> in an interface definition matches the
behavior of using a default of <code>Self</code> when the type between <code>impl</code> and <code>as</code> is
omitted. So the previous definition of <code>interface Iterable</code> is equivalent to:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Iterable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl Self as Equatable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Equivalent to: impl as Equatable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>When implementing an interface with an <code>impl as</code> requirement, that requirement
must be satisfied by an implementation in an imported library, an implementation
somewhere in the same file, or a constraint in the impl declaration.
Implementing the requiring interface is a promise that the requirement will be
implemented. This is like a
<a href="#declaring-implementations">forward declaration of an impl</a> except that the
definition can be broader instead of being required to match exactly.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// `Iterable` requires `Equatable`, so there must be some</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// impl of `Equatable` for `Vector(i32)` in this file.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Vector(i32) as Iterable { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn RequiresEquatable[T:! Equatable](x: T) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn ProcessVector(v: Vector(i32)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed since `Vector(i32)` is known to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // implement `Equatable`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  RequiresEquatable(v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Satisfies the requirement that `Vector(i32)` must</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// implement `Equatable` since `i32` is `Equatable`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! Equatable] Vector(T) as Equatable { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In some cases, the interface&#x27;s requirement can be trivially satisfied by the
implementation itself, as in:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl forall [T:! Type] T as CommonTypeWith(T) { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here is an example where the requirement of interface <code>Iterable</code> that the type
implements interface <code>Equatable</code> is satisfied by a constraint in the <code>impl</code>
declaration:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Foo(T:! Type) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// This is allowed because we know that an `impl Foo(T) as Equatable`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// will exist for all types `T` for which this impl is used, even</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// though there&#x27;s neither an imported impl nor an impl in this file.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! Type where Foo(T) is Equatable]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Foo(T) as Iterable {}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This might be used to provide an implementation of <code>Equatable</code> for types that
already satisfy the requirement of implementing <code>Iterable</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Bar {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Foo(Bar) as Equatable {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Gives `Foo(Bar) is Iterable` using the blanket impl of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `Iterable` for `Foo(T)`.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="requirements-with-where-constraints">Requirements with <code>where</code> constraints<a class="hash-link" href="#requirements-with-where-constraints" title="Direct link to heading">​</a></h3><p>An interface implementation requirement with a <code>where</code> clause is harder to
satisfy. Consider an interface <code>B</code> that has a requirement that interface <code>A</code> is
also implemented.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface A(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Result:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface B(T:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as A(T) where .Result == i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>An implementation of <code>B</code> for a set of types can only be valid if there is a
visible implementation of <code>A</code> with the same <code>T</code> parameter for those types with
the <code>.Result</code> associated type set to <code>i32</code>. That is
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//proposals/p1088.md#less-strict-about-requirements-with-where-clauses" target="_blank" rel="noopener noreferrer">not sufficient</a>,
though, unless the implementation of <code>A</code> can&#x27;t be specialized, either because it
is <a href="#final-impls">marked <code>final</code></a> or is not
<a href="#parameterized-impls">parameterized</a>. Implementations in other libraries can&#x27;t
make <code>A</code> be implemented for fewer types, but can cause <code>.Result</code> to have a
different assignment.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="observing-a-type-implements-an-interface">Observing a type implements an interface<a class="hash-link" href="#observing-a-type-implements-an-interface" title="Direct link to heading">​</a></h2><p>An <a href="#observe-declarations"><code>observe</code> declaration</a> can be used to show that two
types are equal so code can pass type checking without explicitly writing casts,
without requiring the compiler to do a unbounded search that may not terminate.
An <code>observe</code> declaration can also be used to show that a type implements an
interface, in cases where the compiler will not work this out for itself.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="observing-interface-requirements">Observing interface requirements<a class="hash-link" href="#observing-interface-requirements" title="Direct link to heading">​</a></h3><p>One situation where this occurs is when there is a chain of
<a href="#interface-requiring-other-interfaces-revisited">interfaces requiring other interfaces</a>.
During the <code>impl</code> validation done during type checking, Carbon will only
consider the interfaces that are direct requirements of the interfaces the type
is known to implement. An <code>observe...is</code> declaration can be used to add an
interface that is a direct requirement to the set of interfaces whose direct
requirements will be considered for that type. This allows a developer to
provide a proof that there is a sequence of requirements that demonstrate that a
type implements an interface, as in this example:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface A { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface B { impl as A; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface C { impl as B; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface D { impl as C; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn RequiresA[T:! A](x: T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn RequiresC[T:! C](x: T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn RequiresD[T:! D](x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `D` directly requires `C` to be implemented.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  RequiresC(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ❌ Illegal: No direct connection between `D` and `A`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // RequiresA(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `T` is `D` and `D` directly requires `C` to be</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // implemented.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  observe T is C;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `T` is `C` and `C` directly requires `B` to be</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // implemented.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  observe T is B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: `T` is `B` and `B` directly requires</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //             `A` to be implemented.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  RequiresA(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that <code>observe</code> statements do not affect the selection of impls during code
generation. For coherence, the impl used for a (type, interface) pair must
always be the same, independent of context. The
<a href="#termination-rule">termination rule</a> governs when compilation may fail when the
compiler can&#x27;t determine the impl to select.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="observing-blanket-impls">Observing blanket impls<a class="hash-link" href="#observing-blanket-impls" title="Direct link to heading">​</a></h3><p>An <code>observe...is</code> declaration can also be used to observe that a type implements
an interface because there is a <a href="#blanket-impls">blanket impl</a> in terms of
requirements a type is already known to satisfy. Without an <code>observe</code>
declaration, Carbon will only use blanket impls that are directly satisfied.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface A { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface B { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface C { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface D { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl forall [T:! A] T as B { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl forall [T:! B] T as C { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl forall [T:! C] T as D { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn RequiresD(T:! D)(x: T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn RequiresB(T:! B)(x: T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn RequiresA(T:! A)(x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: There is a blanket implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //             of `B` for types implementing `A`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  RequiresB(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ❌ Illegal: No implementation of `D` for type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //             `T` implementing `A`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // RequiresD(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // There is a blanket implementation of `B` for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // types implementing `A`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  observe T is B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // There is a blanket implementation of `C` for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // types implementing `B`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  observe T is C;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Allowed: There is a blanket implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //             of `D` for types implementing `C`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  RequiresD(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In the case of an error, a quality Carbon implementation will do a deeper search
for chains of requirements and blanket impls and suggest <code>observe</code> declarations
that would make the code compile if any solution is found.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="operator-overloading">Operator overloading<a class="hash-link" href="#operator-overloading" title="Direct link to heading">​</a></h2><p>Operations are overloaded for a type by implementing an interface specific to
that interface for that type. For example, types implement the <code>Negatable</code>
interface to overload the unary <code>-</code> operator:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Unary `-`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Negatable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Result:! Type = Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Negate[me: Self]() -&gt; Result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Expressions using operators are rewritten into calls to these interface methods.
For example, <code>-x</code> would be rewritten to <code>x.(Negatable.Negate)()</code>.</p><p>The interfaces and rewrites used for a given operator may be found in the
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/expressions/README.md" target="_blank" rel="noopener noreferrer">expressions design</a>.
<a href="https://github.com/carbon-language/carbon-lang/issues/1058" target="_blank" rel="noopener noreferrer">Question-for-leads issue #1058</a>
defines the naming scheme for these interfaces.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="binary-operators">Binary operators<a class="hash-link" href="#binary-operators" title="Direct link to heading">​</a></h3><p>Binary operators will have an interface that is
<a href="#parameterized-interfaces">parameterized</a> based on the second operand. For
example, to say a type may be converted to another type using an <code>as</code>
expression, implement the
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/expressions/as_expressions.md#extensibility" target="_blank" rel="noopener noreferrer"><code>As</code> interface</a>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface As(Dest:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Convert[me: Self]() -&gt; Dest;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The expression <code>x as U</code> is rewritten to <code>x.(As(U).Convert)()</code>. Note that the
parameterization of the interface means it can be implemented multiple times to
support multiple operand types.</p><p>Unlike <code>as</code>, for most binary operators the interface&#x27;s argument will be the
<em>type</em> of the right-hand operand instead of its <em>value</em>. Consider an interface
for a binary operator like <code>*</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Binary `*`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface MultipliableWith(U:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Result:! Type = Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Multiply[me: Self](other: U) -&gt; Result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A use of binary <code>*</code> in source code will be rewritten to use this interface:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var left: Meters = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var right: f64 = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var result: auto = left * right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Equivalent to:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var equivalent: left.(MultipliableWith(f64).Result)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    = left.(MultipliableWith(f64).Multiply)(right);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that if the types of the two operands are different, then swapping the
order of the operands will result in a different implementation being selected.
It is up to the developer to make those consistent when that is appropriate. The
standard library will provide <a href="#adapting-types">adapters</a> for defining the
second implementation from the first, as in:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface ComparableWith(RHS:! Type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Compare[me: Self](right: RHS) -&gt; CompareResult;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adapter ReverseComparison</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (T:! Type, U:! ComparableWith(RHS)) for T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as ComparableWith(U) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn Compare[me: Self](right: RHS) -&gt; CompareResult {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return ReverseCompareResult(right.Compare(me));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl SongByTitle as ComparableWith(SongTitle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl SongTitle as ComparableWith(SongByTitle)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    = ReverseComparison(SongTitle, SongByTitle);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In some cases the reverse operation may not be defined. For example, a library
might support subtracting a vector from a point, but not the other way around.</p><p>Further note that even if the reverse implementation exists,
<a href="#prioritization-rule">the impl prioritization rule</a> might not pick it. For
example, if we have two types that support comparison with anything implementing
an interface that the other implements:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface IntLike {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn AsInt[me: Self]() -&gt; i64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class EvenInt { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl EvenInt as IntLike;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl EvenInt as ComparableWith(EvenInt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Allow `EvenInt` to be compared with anything that</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// implements `IntLike`, in either order.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! IntLike] EvenInt as ComparableWith(T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! IntLike] T as ComparableWith(EvenInt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class PositiveInt { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl PositiveInt as IntLike;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl PositiveInt as ComparableWith(PositiveInt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Allow `PositiveInt` to be compared with anything that</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// implements `IntLike`, in either order.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! IntLike] PositiveInt as ComparableWith(T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! IntLike] T as ComparableWith(PositiveInt);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Then it will favor selecting the implementation based on the type of the
left-hand operand:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var even: EvenInt = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var positive: PositiveInt = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Uses `EvenInt as ComparableWith(T)` impl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (even &lt; positive) { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Uses `PositiveInt as ComparableWith(T)` impl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (positive &gt; even) { ... }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="like-operator-for-implicit-conversions"><code>like</code> operator for implicit conversions<a class="hash-link" href="#like-operator-for-implicit-conversions" title="Direct link to heading">​</a></h3><p>Because the type of the operands is directly used to select the implementation
to use, there are no automatic implicit conversions, unlike with function or
method calls. Given both a method and an interface implementation for
multiplying by a value of type <code>f64</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Meters {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Scale[me: Self](s: f64) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// &quot;Implementation One&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Meters as MultipliableWith(f64)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where .Result = Meters {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Multiply[me: Self](other: f64) -&gt; Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return me.Scale(other);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>the method will work with any argument that can be implicitly converted to <code>f64</code>
but the operator overload will only work with values that have the specific type
of <code>f64</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var height: Meters = ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var scale: f32 = 1.25;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ✅ Allowed: `scale` implicitly converted</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//             from `f32` to `f64`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var allowed: Meters = height.Scale(scale);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Illegal: `Meters` doesn&#x27;t implement</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//             `MultipliableWith(f32)`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var illegal: Meters = height * scale;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The workaround is to define a parameterized implementation that performs the
conversion. The implementation is for types that implement the
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/expressions/implicit_conversions.md#extensibility" target="_blank" rel="noopener noreferrer"><code>ImplicitAs</code> interface</a>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// &quot;Implementation Two&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! ImplicitAs(f64)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Meters as MultipliableWith(T) where .Result = Meters {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Multiply[me: Self](other: T) -&gt; Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Carbon will implicitly convert `other` from type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `T` to `f64` to perform this call.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return me.(Meters.(MultipliableWith(f64).Multiply))(other);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ✅ Allowed: uses `Meters as MultipliableWith(T)` impl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//             with `T == f32` since `f32 is ImplicitAs(f64)`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var now_allowed: Meters = height * scale;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Observe that the <a href="#prioritization-rule">prioritization rule</a> will still prefer
the unparameterized impl when there is an exact match.</p><p>To reduce the boilerplate needed to support these implicit conversions when
defining operator overloads, Carbon has the <code>like</code> operator. This operator can
only be used in the type or type-of-type part of an <code>impl</code> declaration, as part
of a forward declaration or definition, in a place of a type.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Notice `f64` has been replaced by `like f64`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// compared to &quot;implementation one&quot; above.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Meters as MultipliableWith(like f64)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where .Result = Meters {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Multiply[me: Self](other: f64) -&gt; Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return me.Scale(other);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This <code>impl</code> definition actually defines two implementations. The first is the
same as this definition with <code>like f64</code> replaced by <code>f64</code>, giving something
equivalent to &quot;implementation one&quot;. The second implementation replaces the
<code>like f64</code> with a parameter that ranges over types that can be implicitly
converted to <code>f64</code>, equivalent to &quot;implementation two&quot;.</p><p>In general, each <code>like</code> adds one additional impl. There is always the impl with
all of the <code>like</code> expressions replaced by their arguments with the definition
supplied in the source code. In addition, for each <code>like</code> expression, there is
an impl with it replaced by a new parameter. These additional impls will
delegate to the main impl, which will trigger implicit conversions according to
<a href="https://github.com/carbon-language/carbon-lang/blob/trunk//docs/design/expressions/implicit_conversions.md" target="_blank" rel="noopener noreferrer">Carbon&#x27;s ordinary implicit conversion rules</a>.
In this example, there are two uses of <code>like</code>, producing three implementations</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">external impl like Meters as MultipliableWith(like f64)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where .Result = Meters {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Multiply[me: Self](other: f64) -&gt; Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return me.Scale(other);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>is equivalent to &quot;implementation one&quot;, &quot;implementation two&quot;, and:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! ImplicitAs(Meters)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    T as MultipliableWith(f64) where .Result = Meters {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Multiply[me: Self](other: f64) -&gt; Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Will implicitly convert `me` to `Meters` in order to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // match the signature of this `Multiply` method.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return me.(Meters.(MultipliableWith(f64).Multiply))(other);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>like</code> may be used in forward declarations in a way analogous to impl
definitions.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">external impl like Meters as MultipliableWith(like f64)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where .Result = Meters;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>is equivalent to:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// All `like`s removed. Same as the declaration part of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// &quot;implementation one&quot;, without the body of the definition.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Meters as MultipliableWith(f64)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where .Result = Meters;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// First `like` replaced with a wildcard.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! ImplicitAs(Meters)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    T as MultipliableWith(f64) where .Result = Meters;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Second `like` replaced with a wildcard. Same as the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// declaration part of &quot;implementation two&quot;, without the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// body of the definition.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! ImplicitAs(f64)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Meters as MultipliableWith(T) where .Result = Meters;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In addition, the generated impl definition for a <code>like</code> is implicitly injected
at the end of the (unique) source file in which the impl is first declared. That
is, it is injected in the API file if the impl is declared in an API file, and
in the sole impl file declaring the impl otherwise. This means an <code>impl</code>
declaration using <code>like</code> in an API file also makes the parameterized definition</p><p>If one <code>impl</code> declaration uses <code>like</code>, other declarations must use <code>like</code> in the
same way to match.</p><p>The <code>like</code> operator may be nested, as in:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">external impl like Vector(like String) as Printable;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Which will generate implementations with declarations:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">external impl Vector(String) as Printable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! ImplicitAs(Vector(String))] T as Printable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! ImplicitAs(String)] Vector(T) as Printable;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The generated implementations must be legal or the <code>like</code> is illegal. For
example, it must be legal to define those impls in this library by the
<a href="#orphan-rule">orphan rule</a>. In addition, the generated <code>impl</code> definitions must
only require implicit conversions that are guaranteed to exist. For example,
there existing an implicit conversion from <code>T</code> to <code>String</code> does not imply that
there is one from <code>Vector(T)</code> to <code>Vector(String)</code>, so the following use of
<code>like</code> is illegal:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Illegal: Can&#x27;t convert a value with type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//             `Vector(T:! ImplicitAs(String))`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//             to `Vector(String)` for `me`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//             parameter of `Printable.Print`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Vector(like String) as Printable;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Since the additional implementation definitions are generated eagerly, these
errors will be reported in the file with the first declaration.</p><p>The argument to <code>like</code> must either not mention any type parameters, or those
parameters must be able to be determined due to being repeated outside of the
<code>like</code> expression.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// ✅ Allowed: no parameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl like Meters as Printable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Illegal: No other way to determine `T`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! IntLike] like T as Printable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Illegal: `T` being used in a `where` clause</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//             is insufficient.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! IntLike] like T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    as MultipliableWith(i64) where .Result = T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ❌ Illegal: `like` can&#x27;t be used in a `where`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//             clause.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl Meters as MultipliableWith(f64)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where .Result = like Meters;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ✅ Allowed: `T` can be determined by another</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//             part of the query.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! IntLike] like T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    as MultipliableWith(T) where .Result = T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! IntLike] T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    as MultipliableWith(like T) where .Result = T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ✅ Allowed: Only one `like` used at a time, so this</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//             is equivalent to the above two examples.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external impl forall [T:! IntLike] like T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    as MultipliableWith(like T) where .Result = T;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="parameterized-types">Parameterized types<a class="hash-link" href="#parameterized-types" title="Direct link to heading">​</a></h2><p>Types may have generic parameters. Those parameters may be used to specify types
in the declarations of its members, such as data fields, member functions, and
even interfaces being implemented. For example, a container type might be
parameterized by the type of its elements:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class HashMap(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    KeyType:! Hashable &amp; EqualityComparable &amp; Movable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ValueType:! Movable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // `Self` is `HashMap(KeyType, ValueType)`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Parameters may be used in function signatures.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Insert[addr me: Self*](k: KeyType, v: ValueType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Parameters may be used in field types.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private var buckets: Vector((KeyType, ValueType));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Parameters may be used in interfaces implemented.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as Container where .ElementType = (KeyType, ValueType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  impl as ComparableWith(HashMap(KeyType, ValueType));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that, unlike functions, every parameter to a type must either be generic or
template, using <code>:!</code> or <code>template...:!</code>, not dynamic, with a plain <code>:</code>.</p><p>Two types are the same if they have the same name and the same arguments.
Carbon&#x27;s <a href="#manual-type-equality">manual type equality</a> approach means that the
compiler may not always be able to tell when two type expressions are equal
without help from the user, in the form of
<a href="#observe-declarations"><code>observe</code> declarations</a>. This means Carbon will not in
general be able to determine when types are unequal.</p><p>Unlike an <a href="#parameterized-interfaces">interface&#x27;s parameters</a>, a type&#x27;s
parameters may be <a href="/carbon-lang/design/generics/terminology#deduced-parameter">deduced</a>, as in:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn ContainsKey[KeyType:! Movable, ValueType:! Movable]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (haystack: HashMap(KeyType, ValueType), needle: KeyType)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt; bool { ... }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn MyMapContains(s: String) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var map: HashMap(String, i32) = ((&quot;foo&quot;, 3), (&quot;bar&quot;, 5));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ✅ Deduces `KeyType` = `String` from the types of both arguments.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Deduces `ValueType` = `i32` from the type of the first argument.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return ContainsKey(map, s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that restrictions on the type&#x27;s parameters from the type&#x27;s declaration can
be <a href="#implied-constraints">implied constraints</a> on the function&#x27;s parameters.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="specialization">Specialization<a class="hash-link" href="#specialization" title="Direct link to heading">​</a></h3><p><a href="/carbon-lang/design/generics/terminology#generic-specialization">Specialization</a> is used to improve
performance in specific cases when a general strategy would be inefficient. For
example, you might use
<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" target="_blank" rel="noopener noreferrer">binary search</a> for
containers that support random access and keep their contents in sorted order
but <a href="https://en.wikipedia.org/wiki/Linear_search" target="_blank" rel="noopener noreferrer">linear search</a> in other cases.
Types, like functions, may not be specialized directly in Carbon. This effect
can be achieved, however, through delegation.</p><p>For example, imagine we have a parameterized class <code>Optional(T)</code> that has a
default storage strategy that works for all <code>T</code>, but for some types we have a
more efficient approach. For pointers we can use a
<a href="https://en.wikipedia.org/wiki/Null_pointer" target="_blank" rel="noopener noreferrer">null value</a> to represent &quot;no
pointer&quot;, and for booleans we can support <code>True</code>, <code>False</code>, and <code>None</code> in a
single byte. Clients of the optional library may want to add additional
specializations for their own types. We make an interface that represents &quot;the
storage of <code>Optional(T)</code> for type <code>T</code>,&quot; written here as <code>OptionalStorage</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface OptionalStorage {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let Storage:! Type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn MakeNone() -&gt; Storage;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Make(x: Self) -&gt; Storage;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn IsNone(x: Storage) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Unwrap(x: Storage) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The default implementation of this interface is provided by a
<a href="#blanket-impls">blanket implementation</a>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Default blanket implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl forall [T:! Movable] T as OptionalStorage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where .Storage = (bool, T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This implementation can then be
<a href="#lookup-resolution-and-specialization">specialized</a> for more specific type
patterns:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Specialization for pointers, using nullptr == None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final external impl forall [T:! Type] T* as OptionalStorage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where .Storage = Array(Byte, sizeof(T*)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Specialization for type `bool`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final external impl bool as OptionalStorage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where .Storage = Byte {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Further, libraries can implement <code>OptionalStorage</code> for their own types, assuming
the interface is not marked <code>private</code>. Then the implementation of <code>Optional(T)</code>
can delegate to <code>OptionalStorage</code> for anything that can vary with <code>T</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Optional(T:! Movable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn None() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.storage = T.(OptionalStorage.MakeNone)()};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Some(x: T) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.storage = T.(OptionalStorage.Make)(x)};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private var storage: T.(OptionalStorage.Storage);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that the constraint on <code>T</code> is just <code>Movable</code>, not
<code>Movable &amp; OptionalStorage</code>, since the <code>Movable</code> requirement is
<a href="#lookup-resolution-and-specialization">sufficient to guarantee</a> that some
implementation of <code>OptionalStorage</code> exists for <code>T</code>. Carbon does not require
callers of <code>Optional</code>, even generic callers, to specify that the argument type
implements <code>OptionalStorage</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// ✅ Allowed: `T` just needs to be `Movable` to form `Optional(T)`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//             A `T:! OptionalStorage` constraint is not required.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn First[T:! Movable &amp; Eq](v: Vector(T)) -&gt; Optional(T);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Adding <code>OptionalStorage</code> to the constraints on the parameter to <code>Optional</code> would
obscure what types can be used as arguments. <code>OptionalStorage</code> is an
implementation detail of <code>Optional</code> and need not appear in its public API.</p><p>In this example, a <code>let</code> is used to avoid repeating <code>OptionalStorage</code> in the
definition of <code>Optional</code>, since it has no name conflicts with the members of
<code>Movable</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Optional(T:! Movable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private let U:! Movable &amp; OptionalStorage = T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn None() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.storage = U.MakeNone()};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn Some(x: T) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {.storage = u.Make(x)};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private var storage: U.Storage;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="future-work">Future work<a class="hash-link" href="#future-work" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dynamic-types">Dynamic types<a class="hash-link" href="#dynamic-types" title="Direct link to heading">​</a></h3><p>Generics provide enough structure to support runtime dispatch for values with
types that vary at runtime, without giving up type safety. Both Rust and Swift
have demonstrated the value of this feature.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="runtime-type-parameters">Runtime type parameters<a class="hash-link" href="#runtime-type-parameters" title="Direct link to heading">​</a></h4><p>This feature is about allowing a function&#x27;s type parameter to be passed in as a
dynamic (non-generic) parameter. All values of that type would still be required
to have the same type.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="runtime-type-fields">Runtime type fields<a class="hash-link" href="#runtime-type-fields" title="Direct link to heading">​</a></h4><p>Instead of passing in a single type parameter to a function, we could store a
type per value. This changes the data layout of the value, and so is a somewhat
more invasive change. It also means that when a function operates on multiple
values they could have different real types.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="abstract-return-types">Abstract return types<a class="hash-link" href="#abstract-return-types" title="Direct link to heading">​</a></h3><p>This lets you return an anonymous type implementing an interface from a
function. In Rust this is the
<a href="https://rust-lang.github.io/rfcs/1522-conservative-impl-trait.html" target="_blank" rel="noopener noreferrer"><code>impl Trait</code> return type</a>.</p><p>In Swift, there are discussions about implementing this feature under the name
&quot;reverse generics&quot; or &quot;opaque result types&quot;:
<a href="https://forums.swift.org/t/improving-the-ui-of-generics/22814#heading--reverse-generics" target="_blank" rel="noopener noreferrer">1</a>,
<a href="https://forums.swift.org/t/reverse-generics-and-opaque-result-types/21608" target="_blank" rel="noopener noreferrer">2</a>,
<a href="https://forums.swift.org/t/se-0244-opaque-result-types/21252" target="_blank" rel="noopener noreferrer">3</a>,
<a href="https://forums.swift.org/t/se-0244-opaque-result-types-reopened/22942" target="_blank" rel="noopener noreferrer">4</a>,
Swift is considering spelling this <code>&lt;V: Collection&gt; V</code> or <code>some Collection</code>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="evolution">Evolution<a class="hash-link" href="#evolution" title="Direct link to heading">​</a></h3><p>There are a collection of use cases for making different changes to interfaces
that are already in use. These should be addressed either by describing how they
can be accomplished with existing generics features, or by adding features.</p><p>In addition, evolution from (C++ or Carbon) templates to generics needs to be
supported and made safe.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="testing">Testing<a class="hash-link" href="#testing" title="Direct link to heading">​</a></h3><p>The idea is that you would write tests alongside an interface that validate the
expected behavior of any type implementing that interface.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="impls-with-state">Impls with state<a class="hash-link" href="#impls-with-state" title="Direct link to heading">​</a></h3><p>A feature we might consider where an <code>impl</code> itself can have state.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="generic-associated-types-and-higher-ranked-types">Generic associated types and higher-ranked types<a class="hash-link" href="#generic-associated-types-and-higher-ranked-types" title="Direct link to heading">​</a></h3><p>This would be some way to express the requirement that there is a way to go from
a type to an implementation of an interface parameterized by that type.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="generic-associated-types">Generic associated types<a class="hash-link" href="#generic-associated-types" title="Direct link to heading">​</a></h4><p>Generic associated types are about when this is a requirement of an interface.
These are also called &quot;associated type constructors.&quot;</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="higher-ranked-types">Higher-ranked types<a class="hash-link" href="#higher-ranked-types" title="Direct link to heading">​</a></h4><p>Higher-ranked types are used to represent this requirement in a function
signature. They can be
<a href="https://smallcultfollowing.com/babysteps//blog/2016/11/03/associated-type-constructors-part-2-family-traits/" target="_blank" rel="noopener noreferrer">emulated using generic associated types</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="field-requirements">Field requirements<a class="hash-link" href="#field-requirements" title="Direct link to heading">​</a></h3><p>We might want to allow interfaces to express the requirement that any
implementing type has a particular field. This would be to match the
expressivity of inheritance, which can express &quot;all subtypes start with this
list of fields.&quot;</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="bridge-for-c-customization-points">Bridge for C++ customization points<a class="hash-link" href="#bridge-for-c-customization-points" title="Direct link to heading">​</a></h3><p>See details in <a href="/carbon-lang/design/generics/goals#bridge-for-c-customization-points">the goals document</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="variadic-arguments">Variadic arguments<a class="hash-link" href="#variadic-arguments" title="Direct link to heading">​</a></h3><p>Some facility for allowing a function to generically take a variable number of
arguments.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="range-constraints-on-generic-integers">Range constraints on generic integers<a class="hash-link" href="#range-constraints-on-generic-integers" title="Direct link to heading">​</a></h3><p>We currently only support <code>where</code> clauses on type-of-types. We may want to also
support constraints on generic integers. The constraint with the most expected
value is the ability to do comparisons like <code>&lt;</code>, or <code>&gt;=</code>. For example, you might
constrain the <code>N</code> member of <a href="#associated-constants"><code>NSpacePoint</code></a> using an
expression like <code>PointT:! NSpacePoint where 2 &lt;= .N and .N &lt;= 3</code>.</p><p>The concern here is supporting this at compile time with more benefit than
complexity. For example, we probably don&#x27;t want to support integer-range based
types at runtime, and there are also concerns about reasoning about comparisons
between multiple generic integer parameters. For example, if <code>J &lt; K</code> and
<code>K &lt;= L</code>, can we call a function that requires <code>J &lt; L</code>? There is also a
secondary syntactic concern about how to write this kind of constraint on a
parameter, as opposed to an associated type, as in <code>N:! u32 where ___ &gt;= 2</code>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a class="hash-link" href="#references" title="Direct link to heading">​</a></h2><ul><li><a href="https://github.com/carbon-language/carbon-lang/pull/553" target="_blank" rel="noopener noreferrer">#553: Generics details part 1</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/731" target="_blank" rel="noopener noreferrer">#731: Generics details 2: adapters, associated types, parameterized interfaces</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/818" target="_blank" rel="noopener noreferrer">#818: Constraints for generics (generics details 3)</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/931" target="_blank" rel="noopener noreferrer">#931: Generic impls access (details 4)</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/920" target="_blank" rel="noopener noreferrer">#920: Generic parameterized impls (details 5)</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/950" target="_blank" rel="noopener noreferrer">#950: Generic details 6: remove facets</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/983" target="_blank" rel="noopener noreferrer">#983: Generic details 7: final impls</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/990" target="_blank" rel="noopener noreferrer">#990: Generics details 8: interface default and final members</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/1013" target="_blank" rel="noopener noreferrer">#1013: Generics: Set associated constants using <code>where</code> constraints</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/1084" target="_blank" rel="noopener noreferrer">#1084: Generics details 9: forward declarations</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/1088" target="_blank" rel="noopener noreferrer">#1088: Generic details 10: interface-implemented requirements</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/1144" target="_blank" rel="noopener noreferrer">#1144: Generic details 11: operator overloading</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/1146" target="_blank" rel="noopener noreferrer">#1146: Generic details 12: parameterized types</a></li><li><a href="https://github.com/carbon-language/carbon-lang/pull/1327" target="_blank" rel="noopener noreferrer">#1327: Generics: <code>impl forall</code></a></li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/details.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/carbon-lang/design/generics/appendix-coherence"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Carbon: alternatives to coherence</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/carbon-lang/design/generics/goals"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Generics: Goals</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#table-of-contents" class="table-of-contents__link toc-highlight">Table of contents</a></li><li><a href="#overview" class="table-of-contents__link toc-highlight">Overview</a></li><li><a href="#interfaces" class="table-of-contents__link toc-highlight">Interfaces</a></li><li><a href="#implementing-interfaces" class="table-of-contents__link toc-highlight">Implementing interfaces</a><ul><li><a href="#implementing-multiple-interfaces" class="table-of-contents__link toc-highlight">Implementing multiple interfaces</a></li><li><a href="#external-impl" class="table-of-contents__link toc-highlight">External impl</a></li><li><a href="#qualified-member-names-and-compound-member-access" class="table-of-contents__link toc-highlight">Qualified member names and compound member access</a></li><li><a href="#access" class="table-of-contents__link toc-highlight">Access</a></li></ul></li><li><a href="#generics" class="table-of-contents__link toc-highlight">Generics</a><ul><li><a href="#return-type" class="table-of-contents__link toc-highlight">Return type</a></li><li><a href="#implementation-model" class="table-of-contents__link toc-highlight">Implementation model</a></li></ul></li><li><a href="#interfaces-recap" class="table-of-contents__link toc-highlight">Interfaces recap</a></li><li><a href="#type-of-types" class="table-of-contents__link toc-highlight">Type-of-types</a></li><li><a href="#named-constraints" class="table-of-contents__link toc-highlight">Named constraints</a><ul><li><a href="#subtyping-between-type-of-types" class="table-of-contents__link toc-highlight">Subtyping between type-of-types</a></li></ul></li><li><a href="#combining-interfaces-by-anding-type-of-types" class="table-of-contents__link toc-highlight">Combining interfaces by anding type-of-types</a></li><li><a href="#interface-requiring-other-interfaces" class="table-of-contents__link toc-highlight">Interface requiring other interfaces</a><ul><li><a href="#interface-extension" class="table-of-contents__link toc-highlight">Interface extension</a></li><li><a href="#use-case-overload-resolution" class="table-of-contents__link toc-highlight">Use case: overload resolution</a></li></ul></li><li><a href="#adapting-types" class="table-of-contents__link toc-highlight">Adapting types</a><ul><li><a href="#adapter-compatibility" class="table-of-contents__link toc-highlight">Adapter compatibility</a></li><li><a href="#extending-adapter" class="table-of-contents__link toc-highlight">Extending adapter</a></li><li><a href="#use-case-using-independent-libraries-together" class="table-of-contents__link toc-highlight">Use case: Using independent libraries together</a></li><li><a href="#use-case-defining-an-impl-for-use-by-other-types" class="table-of-contents__link toc-highlight">Use case: Defining an impl for use by other types</a></li><li><a href="#use-case-private-impl" class="table-of-contents__link toc-highlight">Use case: Private impl</a></li><li><a href="#use-case-accessing-external-names" class="table-of-contents__link toc-highlight">Use case: Accessing external names</a></li><li><a href="#adapter-with-stricter-invariants" class="table-of-contents__link toc-highlight">Adapter with stricter invariants</a></li></ul></li><li><a href="#associated-constants" class="table-of-contents__link toc-highlight">Associated constants</a><ul><li><a href="#associated-class-functions" class="table-of-contents__link toc-highlight">Associated class functions</a></li></ul></li><li><a href="#associated-types" class="table-of-contents__link toc-highlight">Associated types</a><ul><li><a href="#implementation-model-1" class="table-of-contents__link toc-highlight">Implementation model</a></li></ul></li><li><a href="#parameterized-interfaces" class="table-of-contents__link toc-highlight">Parameterized interfaces</a><ul><li><a href="#impl-lookup" class="table-of-contents__link toc-highlight">Impl lookup</a></li><li><a href="#parameterized-named-constraints" class="table-of-contents__link toc-highlight">Parameterized named constraints</a></li></ul></li><li><a href="#where-constraints" class="table-of-contents__link toc-highlight">Where constraints</a><ul><li><a href="#constraint-use-cases" class="table-of-contents__link toc-highlight">Constraint use cases</a></li><li><a href="#implied-constraints" class="table-of-contents__link toc-highlight">Implied constraints</a></li><li><a href="#referencing-names-in-the-interface-being-defined" class="table-of-contents__link toc-highlight">Referencing names in the interface being defined</a></li><li><a href="#manual-type-equality" class="table-of-contents__link toc-highlight">Manual type equality</a></li></ul></li><li><a href="#other-constraints-as-type-of-types" class="table-of-contents__link toc-highlight">Other constraints as type-of-types</a><ul><li><a href="#is-a-derived-class" class="table-of-contents__link toc-highlight">Is a derived class</a></li><li><a href="#type-compatible-with-another-type" class="table-of-contents__link toc-highlight">Type compatible with another type</a></li><li><a href="#sized-types-and-type-of-types" class="table-of-contents__link toc-highlight">Sized types and type-of-types</a></li><li><a href="#typeid" class="table-of-contents__link toc-highlight"><code>TypeId</code></a></li><li><a href="#destructor-constraints" class="table-of-contents__link toc-highlight">Destructor constraints</a></li></ul></li><li><a href="#generic-let" class="table-of-contents__link toc-highlight">Generic <code>let</code></a></li><li><a href="#parameterized-impls" class="table-of-contents__link toc-highlight">Parameterized impls</a><ul><li><a href="#impl-for-a-parameterized-type" class="table-of-contents__link toc-highlight">Impl for a parameterized type</a></li><li><a href="#conditional-conformance" class="table-of-contents__link toc-highlight">Conditional conformance</a></li><li><a href="#blanket-impls" class="table-of-contents__link toc-highlight">Blanket impls</a></li><li><a href="#wildcard-impls" class="table-of-contents__link toc-highlight">Wildcard impls</a></li><li><a href="#combinations" class="table-of-contents__link toc-highlight">Combinations</a></li><li><a href="#lookup-resolution-and-specialization" class="table-of-contents__link toc-highlight">Lookup resolution and specialization</a></li><li><a href="#final-impls" class="table-of-contents__link toc-highlight"><code>final</code> impls</a></li><li><a href="#comparison-to-rust" class="table-of-contents__link toc-highlight">Comparison to Rust</a></li></ul></li><li><a href="#forward-declarations-and-cyclic-references" class="table-of-contents__link toc-highlight">Forward declarations and cyclic references</a><ul><li><a href="#declaring-interfaces-and-named-constraints" class="table-of-contents__link toc-highlight">Declaring interfaces and named constraints</a></li><li><a href="#declaring-implementations" class="table-of-contents__link toc-highlight">Declaring implementations</a></li><li><a href="#matching-and-agreeing" class="table-of-contents__link toc-highlight">Matching and agreeing</a></li><li><a href="#declaration-examples" class="table-of-contents__link toc-highlight">Declaration examples</a></li><li><a href="#example-of-declaring-interfaces-with-cyclic-references" class="table-of-contents__link toc-highlight">Example of declaring interfaces with cyclic references</a></li><li><a href="#interfaces-with-parameters-constrained-by-the-same-interface" class="table-of-contents__link toc-highlight">Interfaces with parameters constrained by the same interface</a></li></ul></li><li><a href="#interface-members-with-definitions" class="table-of-contents__link toc-highlight">Interface members with definitions</a><ul><li><a href="#interface-defaults" class="table-of-contents__link toc-highlight">Interface defaults</a></li><li><a href="#final-members" class="table-of-contents__link toc-highlight"><code>final</code> members</a></li></ul></li><li><a href="#interface-requiring-other-interfaces-revisited" class="table-of-contents__link toc-highlight">Interface requiring other interfaces revisited</a><ul><li><a href="#requirements-with-where-constraints" class="table-of-contents__link toc-highlight">Requirements with <code>where</code> constraints</a></li></ul></li><li><a href="#observing-a-type-implements-an-interface" class="table-of-contents__link toc-highlight">Observing a type implements an interface</a><ul><li><a href="#observing-interface-requirements" class="table-of-contents__link toc-highlight">Observing interface requirements</a></li><li><a href="#observing-blanket-impls" class="table-of-contents__link toc-highlight">Observing blanket impls</a></li></ul></li><li><a href="#operator-overloading" class="table-of-contents__link toc-highlight">Operator overloading</a><ul><li><a href="#binary-operators" class="table-of-contents__link toc-highlight">Binary operators</a></li><li><a href="#like-operator-for-implicit-conversions" class="table-of-contents__link toc-highlight"><code>like</code> operator for implicit conversions</a></li></ul></li><li><a href="#parameterized-types" class="table-of-contents__link toc-highlight">Parameterized types</a><ul><li><a href="#specialization" class="table-of-contents__link toc-highlight">Specialization</a></li></ul></li><li><a href="#future-work" class="table-of-contents__link toc-highlight">Future work</a><ul><li><a href="#dynamic-types" class="table-of-contents__link toc-highlight">Dynamic types</a></li><li><a href="#abstract-return-types" class="table-of-contents__link toc-highlight">Abstract return types</a></li><li><a href="#evolution" class="table-of-contents__link toc-highlight">Evolution</a></li><li><a href="#testing" class="table-of-contents__link toc-highlight">Testing</a></li><li><a href="#impls-with-state" class="table-of-contents__link toc-highlight">Impls with state</a></li><li><a href="#generic-associated-types-and-higher-ranked-types" class="table-of-contents__link toc-highlight">Generic associated types and higher-ranked types</a></li><li><a href="#field-requirements" class="table-of-contents__link toc-highlight">Field requirements</a></li><li><a href="#bridge-for-c-customization-points" class="table-of-contents__link toc-highlight">Bridge for C++ customization points</a></li><li><a href="#variadic-arguments" class="table-of-contents__link toc-highlight">Variadic arguments</a></li><li><a href="#range-constraints-on-generic-integers" class="table-of-contents__link toc-highlight">Range constraints on generic integers</a></li></ul></li><li><a href="#references" class="table-of-contents__link toc-highlight">References</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/carbon-language/carbon-lang" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discord.gg/ZjVdShJDAs" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/carbon-language/carbon-lang/blob/trunk/CODE_OF_CONDUCT.md" target="_blank" rel="noopener noreferrer" class="footer__link-item">Code of Conduct<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div></div></footer></div>
<script src="/carbon-lang/assets/js/runtime~main.3ad223b0.js"></script>
<script src="/carbon-lang/assets/js/main.b824e67a.js"></script>
</body>
</html>